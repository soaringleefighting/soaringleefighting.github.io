<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>macOS终端配置：zsh+iTerm2+OhMyZsh</title>
      <link href="/2021/07/17/%E3%80%90Tools%E7%B3%BB%E5%88%97%E3%80%91macOS%E7%BB%88%E7%AB%AF%E9%85%8D%E7%BD%AE%EF%BC%9Azsh+iTerm2+OhMyZsh/"/>
      <url>/2021/07/17/%E3%80%90Tools%E7%B3%BB%E5%88%97%E3%80%91macOS%E7%BB%88%E7%AB%AF%E9%85%8D%E7%BD%AE%EF%BC%9Azsh+iTerm2+OhMyZsh/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="1、前言"><a href="#1、前言" class="headerlink" title="1、前言"></a>1、前言</h2><p>macOS的终端Terminal界面非常简单，没有Linux下面的颜色设置和自动补齐等功能，用起来非常不方便。<br>本文讲解了如何配置macOS终端，使其用起来非常方便。</p><h2 id="2、参考"><a href="#2、参考" class="headerlink" title="2、参考"></a>2、参考</h2><p><a href="https://blog.csdn.net/tsingke/article/details/113788240" target="_blank" rel="noopener">Mac下安装iTerm2+oh-my-zsh+配色（详细教程）</a><br><a href="https://www.jianshu.com/p/ae2639d81780" target="_blank" rel="noopener">macOS powerlevel10k+zsh主题折腾记录(2020年）</a><br><a href="https://blog.csdn.net/u010391437/article/details/75126310?utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-4.control&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-4.control" target="_blank" rel="noopener">macOS 修改终端Terminal的颜色设置</a></p><h2 id="3、终端和vim配置效果图"><a href="#3、终端和vim配置效果图" class="headerlink" title="3、终端和vim配置效果图"></a>3、终端和vim配置效果图</h2><p><strong>1、powerlevel10k主题：</strong><br><img src="https://img-blog.csdnimg.cn/20210717160242790.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NvYXJpbmdMZWVfZmlnaHRpbmc=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong>2、agnoster主题：</strong><img src="https://img-blog.csdnimg.cn/2021071710110180.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NvYXJpbmdMZWVfZmlnaHRpbmc=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><strong>3、vim配置：</strong><br><img src="https://img-blog.csdnimg.cn/20210717113631116.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NvYXJpbmdMZWVfZmlnaHRpbmc=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="4、终端配置步骤"><a href="#4、终端配置步骤" class="headerlink" title="4、终端配置步骤"></a>4、终端配置步骤</h2><p>配置方案： zsh+iTerm2+on-my-zsh+solarized dark配色</p><p>实现功能：<br>1、自定义提示符PS1<br>2、ls针对不同类型文件名称着色<br>3、内置vim代码高亮<br>4、提示符显示git分支名<br>5、自动补全、自动推荐<br>6、实用的额外信息(时间)<br>7、自定义界面壁纸<br>8、随时唤起</p><h3 id="4-1、安装iTerm2"><a href="#4-1、安装iTerm2" class="headerlink" title="4.1、安装iTerm2"></a>4.1、安装iTerm2</h3><p><a href="https://iterm2.com" target="_blank" rel="noopener">https://iterm2.com</a></p><h3 id="4-2、安装oh-my-zsh"><a href="#4-2、安装oh-my-zsh" class="headerlink" title="4.2、安装oh-my-zsh"></a>4.2、安装oh-my-zsh</h3><p>使用 crul 安装：</p><pre><code>sh -c &quot;$(curl -fsSL https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh)&quot;</code></pre><p>或使用wget：</p><pre><code>sh -c &quot;$(wget https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh -O -)&quot;</code></pre><h3 id="4-3、主题和颜色"><a href="#4-3、主题和颜色" class="headerlink" title="4.3、主题和颜色"></a>4.3、主题和颜色</h3><p>颜色：<br>个人采用的是Solarized Dark。</p><pre><code>git clone https://github.com/mbadolato/iTerm2-Color-Schemes.git</code></pre><p>切换颜色的方法：<br>Preferences—&gt;Profiles—&gt;Colors—&gt;Color presets</p><p>主题：<br>个人比较喜欢的主题是：agnoster和powerlevel10k。</p><pre><code>https://github.com/romkatv/powerlevel10k</code></pre><p>切换主题的方法：</p><pre><code>vi ~/.zshrcZSH_THEME=&quot;agnoster&quot;</code></pre><h3 id="4-4、插件"><a href="#4-4、插件" class="headerlink" title="4.4、插件"></a>4.4、插件</h3><p>zsh-syntax-highlighting：</p><pre><code>brew install zsh-syntax-highlighting</code></pre><p>zsh-completions：</p><pre><code>git clone https://github.com/zsh-users/zsh-completions ${ZSH_CUSTOM:=~/.oh-my-zsh/custom}/plugins/zsh-completions</code></pre><p>zsh-autosuggestions：</p><pre><code>brew install zsh-autosuggestions</code></pre><p>最后在~/.zshrc中加入如下内容：</p><pre><code>plugins=(  git  zsh-completions  zsh-syntax-highlighting  zsh-autosuggestions)</code></pre><h3 id="4-5、特殊字体-Hack-herd-font"><a href="#4-5、特殊字体-Hack-herd-font" class="headerlink" title="4.5、特殊字体 Hack herd font"></a>4.5、特殊字体 Hack herd font</h3><p>Iterm2 里配置非 acsii 字体，否则对于 powerlevel10k 主题的特殊字体会显示不出来。比如终端中左侧的苹果图标和文件夹图标的显示就需要Hack herd font字体。<br>安装方法：<br>1、p10k configure按照步骤进行配置即可；</p><h3 id="4-6、vim配置"><a href="#4-6、vim配置" class="headerlink" title="4.6、vim配置"></a>4.6、vim配置</h3><p>vi ~/.vimrc</p><pre><code>syntax on         &quot; 自动语法高亮filetype on       &quot; 检测文件的类型set number        &quot; 显示行号set cindentset cursorline    &quot; 用浅色高亮当前行&quot;autocmd InsertLeave * se noculset smartindent   &quot; 开启新行时使用智能自动缩进set showmatch     &quot; 插入括号时，短暂地跳转到匹配的对应括号set ruler         &quot; 打开状态栏标尺set laststatus=2  &quot; 显示状态栏,默认值为1，不显示set tabstop=4     &quot; Tab键的宽度set shiftwidth=4  &quot; 统一缩进为4set autoindent    &quot; 自动对齐set incsearch     &quot; 输入搜索内容时就显示搜索结果set hlsearch      &quot; 搜索时高亮显示被找到的文本&quot;set statusline=\ %&lt;%F[%1*%M%*%n%R%H]%=\ %y\ %0(%{&amp;fileformat}\ %{&amp;encoding    }\ %c:%l/%L%)\                         &quot; 设置在状态行显示的信息&quot; 自动跳转到上次退出的位置if has(&quot;autocmd&quot;)     au BufReadPost * if line(&quot;&#39;\&quot;&quot;) &gt; 1 &amp;&amp; line(&quot;&#39;\&quot;&quot;) &lt;= line(&quot;$&quot;) | exe     &quot;normal! g&#39;\&quot;&quot; | endifendif</code></pre><h3 id="4-7、随时唤起"><a href="#4-7、随时唤起" class="headerlink" title="4.7、随时唤起"></a>4.7、随时唤起</h3><p>Preferences–&gt;Profiles—&gt;Keys—-&gt;hot Keys</p><h3 id="4-8、自定义界面壁纸"><a href="#4-8、自定义界面壁纸" class="headerlink" title="4.8、自定义界面壁纸"></a>4.8、自定义界面壁纸</h3><p>打开路径：iTerm2 -&gt; Preferences -&gt; Profiles -&gt; window -&gt; Background Image</p><p>选择一张自己喜欢的壁纸即可。</p><p>另外，可以通过Blending调节壁纸的透明度: 透明度为0的时候,背景变为纯色(黑色)。</p><hr><p><strong>THE  END!</strong></p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
          <category> macOS工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> macOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于AI的编码Codec何时到来？</title>
      <link href="/2021/06/14/%E3%80%90Codecs%E7%B3%BB%E5%88%97%E3%80%91%E5%9F%BA%E4%BA%8EAI%E7%9A%84%E7%BC%96%E7%A0%81Codec%E4%BD%95%E6%97%B6%E5%88%B0%E6%9D%A5%EF%BC%9F/"/>
      <url>/2021/06/14/%E3%80%90Codecs%E7%B3%BB%E5%88%97%E3%80%91%E5%9F%BA%E4%BA%8EAI%E7%9A%84%E7%BC%96%E7%A0%81Codec%E4%BD%95%E6%97%B6%E5%88%B0%E6%9D%A5%EF%BC%9F/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="1、前言"><a href="#1、前言" class="headerlink" title="1、前言"></a>1、前言</h2><p>进入六月，杭城进入了一年一度的梅雨季节，有时暴雨，有时淅淅沥沥，天气也闷热许多。适逢端午节，正好在家里学习充实自己，甚好。自从研究生开始学习和研究视频编解码课题开始，一直到工作，陆陆续续也学习了6年了，系统学习了H.265/HEVC编码标准之后，对Codec的研究方向和应用也有了大概的了解。工作之后，又学习了更早的Codec标准MPEG-2/MPEG-4，以及安防监控的国家视频编码标准SVAC，这些标准都是基于多模块技术混合的编码框架，自从H.261（1990）制定发布以来，视频编码标准发展和迭代了已有三代，走过了30年的时间，不过基于混合编码的框架没有改变，即使是2018年发布的AV1和2020年发布的H.266/VVC也都是在混合编码框架基础上进一步细化和改进。但是在压缩率提升的同时，复杂度也在急剧增加，并且不成比例。或许，建立在信息论基础上的Codec发展已经遇到了瓶颈，急需新的技术框架来突破当前的瓶颈。下面是LiveVideoStack社区组织的关于Codec未来的讨论，很有学习借鉴的意义。</p><h2 id="2、关于AI-Codec的讨论"><a href="#2、关于AI-Codec的讨论" class="headerlink" title="2、关于AI+Codec的讨论"></a>2、关于AI+Codec的讨论</h2><h3 id="2-1-传统编解码技术当前所面临的挑战，困境是什么？"><a href="#2-1-传统编解码技术当前所面临的挑战，困境是什么？" class="headerlink" title="2.1 传统编解码技术当前所面临的挑战，困境是什么？"></a>2.1 传统编解码技术当前所面临的挑战，困境是什么？</h3><p>（1）混合编码框架，如何进一步提高压缩效率？<br>更多编码模式，更加精细的编码工具，但是商用编码器的性能 实际是低于校验模型的性能，考虑到新增技术的复杂度，必须进行适当的裁剪，比如x264。<br>困境1：商用编码器的压缩效率要低于标准编码器。</p><p>（2）评价标准：PSNR/SSIM（传统评价标准）<br>基于传统评价标准的RDO对主观质量很不友好，关于失真的评价需要加入新的衡量标准，现在也有学者加入JND来衡量RDO。<br>困境2：评价指标的优化，当前RDO的评价标准没有考虑主观因素。</p><p>（3）工业界芯片面积增加2倍（从264—&gt;265）<br>实时、低延时、高密度的要求越来越迫切<br>困境3：工业界硬件编解码实现要求越来越高。</p><p>（4）信号处理的瓶颈。</p><h3 id="2-2-AI与Codec的结合，运用的方向以及带来的提升"><a href="#2-2-AI与Codec的结合，运用的方向以及带来的提升" class="headerlink" title="2.2 AI与Codec的结合，运用的方向以及带来的提升?"></a>2.2 AI与Codec的结合，运用的方向以及带来的提升?</h3><p>（1）基于神经网络的低复杂度环路滤波技术<br><img src="https://img-blog.csdnimg.cn/20210614115827834.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NvYXJpbmdMZWVfZmlnaHRpbmc=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>（2）多模块协同优化的深度学习视频编码<br><img src="https://img-blog.csdnimg.cn/20210614115800913.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NvYXJpbmdMZWVfZmlnaHRpbmc=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>（3）基于GAN特征提取与画面生成的视频解码<br>（4）基于超分（SRCNN，SRGAN）的视频编解码<br><img src="https://img-blog.csdnimg.cn/20210614115934408.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NvYXJpbmdMZWVfZmlnaHRpbmc=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>（5）AI辅助的传统编码–逐帧编码参数调整<br>参数：动态分辨率，帧率，ROI,帧平均QP, CTU/MB编码决策<br><img src="https://img-blog.csdnimg.cn/20210614120007887.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NvYXJpbmdMZWVfZmlnaHRpbmc=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>泛化能力：模型效果很差或者模型失效？这个是非常重要的一个衡量标准。能否将AI技术成功运用到Codec标准中。</p><p>参考paper: Dandan Ding, Advances in Video Compression System Using Deep Neural Network: A Review And Case Studies,<br>Processings of IEEE, 2021. DOI:10.1109/JPROC.2021.3059994.</p><h3 id="2-3-未来是否会建立基于AI的视频编解码标准？距离标准化还有什么障碍？"><a href="#2-3-未来是否会建立基于AI的视频编解码标准？距离标准化还有什么障碍？" class="headerlink" title="2.3  未来是否会建立基于AI的视频编解码标准？距离标准化还有什么障碍？"></a>2.3  未来是否会建立基于AI的视频编解码标准？距离标准化还有什么障碍？</h3><p>（1）架构上的改变，需要专用的硬件和基础设施。<br>（2）标准化的内容是什么？通用计算结构<br>（3）最大的障碍是硬件的支持，现有硬件芯片，才有操作系统。</p><p>AV2:部分模块会采用AI技术。</p><h2 id="3、总结"><a href="#3、总结" class="headerlink" title="3、总结"></a>3、总结</h2><p>Codec作为多媒体技术中一个非常重要的基础技术，不断更新迭代的过程也是不断蓬勃发展的多媒体领域的需求带来的。AI+Codec的技术方案或许是解决基于信号论的混合编码框架Codec瓶颈的一个途径，但是各个模块AI化和全局优化还需要更多的研究。标准化的过程或许还要很久，预计2030年之前（或者更早）会产生基于AI的视频编解码标准。既然AI+Codec是一个趋势，那么学习AI技术知识对于我们这些Coder也是很有必要的了。</p><p>———————————————<font color="red"><strong>THE END!</strong></font>———————————————————–</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 编解码 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Codecs </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WebAssembly(wasm)基础知识</title>
      <link href="/2021/06/08/%E3%80%90Web%E7%B3%BB%E5%88%97%E3%80%91WebAssembly(wasm)%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
      <url>/2021/06/08/%E3%80%90Web%E7%B3%BB%E5%88%97%E3%80%91WebAssembly(wasm)%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="1、参考"><a href="#1、参考" class="headerlink" title="1、参考"></a>1、参考</h2><p><a href="https://baijiahao.baidu.com/s?id=1617283920644138765&wfr=spider&for=pc" target="_blank" rel="noopener">WebAssembly从0 到 hello World</a><br><a href="https://www.jianshu.com/p/bff8aa23fe4d" target="_blank" rel="noopener">几张图让你看懂WebAssembly</a><br><a href="https://www.cnblogs.com/detectiveHLH/p/9928915.html" target="_blank" rel="noopener">WebAssembly完全入门——了解wasm的前世今身</a></p><h2 id="2、Wasm简介"><a href="#2、Wasm简介" class="headerlink" title="2、Wasm简介"></a>2、Wasm简介</h2><h3 id="2-1、官方介绍"><a href="#2-1、官方介绍" class="headerlink" title="2.1、官方介绍"></a>2.1、官方介绍</h3><p>官方网址： <a href="https://webassembly.org/" target="_blank" rel="noopener">https://webassembly.org/</a></p><ul><li>WebAssembly (abbreviated Wasm) is a binary instruction format for a stack-based virtual machine. Wasm is designed as a portable target for compilation of high-level languages like C/C++/Rust, enabling deployment on the web for client and server applications.<br>W3C牵头推出WebAssembly，最新的主流浏览器Chrome，Firefox，Safari，Edge，移动浏览器都对其提供了支持。<br>WebAssembly 或者 wasm 是一个可移植、体积小、加载快并且兼容 Web 的全新格式。</li></ul><h3 id="2-2、Wasm特点"><a href="#2-2、Wasm特点" class="headerlink" title="2.2、Wasm特点"></a>2.2、Wasm特点</h3><ul><li>高效快速</li><li>安全</li><li>开放可调试</li><li>开放web平台的一部分</li></ul><p>设计目的：主要是为了解决JavaScript（动态和解释性编程语言）的效率问题，Wasm并没有替代JavaScript的意思，两者之间是协作的关系。</p><h3 id="2-3、Wasm原理"><a href="#2-3、Wasm原理" class="headerlink" title="2.3、Wasm原理"></a>2.3、Wasm原理</h3><p>WebAssenbly的执行包括两部分：编译器前端和后端。前端部分实现将高级语言（C、C++和Rust）编译成LLVM IR码。后端负责将LLVM IR编译成各架构（x86，AMD64，ARM）对应的机器码。</p><p>实际中常用的是Emscripten，他可以将C和C++应用程序移植到WebAssembly，原生C/C++代码编译为两个文件（.wasm文件和.js文件）。</p><p>使用WebAssembly对浏览器API进行任何调用时，目前还需要JS进行交互，用JS作为入口。未来WebAssembly可能被浏览器内置支持，并使其能够直接调用DOM，Web Workers或其他浏览器API等。</p><h3 id="2-4、wasm标准规范"><a href="#2-4、wasm标准规范" class="headerlink" title="2.4、wasm标准规范"></a>2.4、wasm标准规范</h3><p>wasm API和二进制格式 规范：<br><a href="https://webassembly.github.io/spec/" target="_blank" rel="noopener">https://webassembly.github.io/spec/</a></p><h3 id="2-5、Wasm主要应用"><a href="#2-5、Wasm主要应用" class="headerlink" title="2.5、Wasm主要应用"></a>2.5、Wasm主要应用</h3><ul><li>Web高性能/密集计算（比如web AR/VR, image processing, codec）</li><li>Web在线游戏</li><li>在Web中使用C/C++/Rust/Go的库</li></ul><h2 id="3、Wasm编译"><a href="#3、Wasm编译" class="headerlink" title="3、Wasm编译"></a>3、Wasm编译</h2><p>参考： <a href="https://emscripten.org/docs/introducing_emscripten/about_emscripten.html" target="_blank" rel="noopener">https://emscripten.org/docs/introducing_emscripten/about_emscripten.html</a></p><p>Emscripten编译器可以将C/C++编译成WebAssembly。</p><p>Emscripten工具链的主要工具是 Emscripten Complier Frontend (emcc)。Emcc使用Clang和LLVM来编译WebAssembly。</p><p>Emcripten SDK(emsdk)用来安装整个工具链，包括emcc和LLVM等等。Emsdk可以在Linux,Windows和MacOS上使用。</p><h3 id="3-1、下载和安装Emscripten"><a href="#3-1、下载和安装Emscripten" class="headerlink" title="3.1、下载和安装Emscripten"></a>3.1、下载和安装Emscripten</h3><p>参考：<a href="https://emscripten.org/docs/getting_started/downloads.html" target="_blank" rel="noopener">https://emscripten.org/docs/getting_started/downloads.html</a></p><p>Emscripten是一个基于llvm的编译器，可以将C/C++代码编译为.wasm。<br> <img src="https://img-blog.csdnimg.cn/20210606230520331.png" alt="在这里插入图片描述"><br><strong>Linux下安装过程：</strong><br>① git clone <a href="https://github.com/emscripten-core/emsdk" target="_blank" rel="noopener">https://github.com/emscripten-core/emsdk</a><br>② ./emsdk update<br>③ git pull<br>④ ./emsdk install latest<br>⑤ ./emsdk activate latest<br>⑥ source ./emsdk_env.sh<br>⑦ emcc -v<br>其中每次重新打开终端都需要重新执行⑤⑥⑦。</p><h3 id="3-2、Emcc使用文档"><a href="#3-2、Emcc使用文档" class="headerlink" title="3.2、Emcc使用文档"></a>3.2、Emcc使用文档</h3><p>Emcc使用文档：<a href="https://emscripten.org/docs/tools_reference/emcc.html#emccdoc" target="_blank" rel="noopener">https://emscripten.org/docs/tools_reference/emcc.html#emccdoc</a></p><h3 id="3-3、编译示例"><a href="#3-3、编译示例" class="headerlink" title="3.3、编译示例"></a>3.3、编译示例</h3><p>参考：<a href="https://emscripten.org/docs/getting_started/Tutorial.html#tutorial" target="_blank" rel="noopener">https://emscripten.org/docs/getting_started/Tutorial.html#tutorial</a><br><a href="https://developer.mozilla.org/en-US/docs/WebAssembly/C_to_wasm" target="_blank" rel="noopener">https://developer.mozilla.org/en-US/docs/WebAssembly/C_to_wasm</a></p><p>1、通过emcc可以将C/C++文件编译成JavaScript和wasm。<br>示例：./emcc tests/hello_world.c<br>产物：a.out.js和a.out.wasm，<br>其中.wasm文件包含编译过的实际wasm代码，是二进制文件；<br>.js文件包含允许JavaScript代码运行wasm的所有框架。<br><img src="https://img-blog.csdnimg.cn/20210606230438621.png" alt="在这里插入图片描述"></p><p>2、通过emcc可以生成HTML文件<br>示例：./emcc tests/hello_world.c -o hello.html</p><p>生成了下面丑丑的效果：</p><p><img src="https://img-blog.csdnimg.cn/20210606230500848.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NvYXJpbmdMZWVfZmlnaHRpbmc=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="3-4、wasm文本格式和二进制格式"><a href="#3-4、wasm文本格式和二进制格式" class="headerlink" title="3.4、wasm文本格式和二进制格式"></a>3.4、wasm文本格式和二进制格式</h3><p><img src="https://img-blog.csdnimg.cn/20210606230631524.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NvYXJpbmdMZWVfZmlnaHRpbmc=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> Web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Wasm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WebAssembly(wasm) SIMD优化</title>
      <link href="/2021/06/06/%E3%80%90%E4%BC%98%E5%8C%96%E7%B3%BB%E5%88%97%E3%80%91WebAssembly(wasm)%20SIMD%E4%BC%98%E5%8C%96/"/>
      <url>/2021/06/06/%E3%80%90%E4%BC%98%E5%8C%96%E7%B3%BB%E5%88%97%E3%80%91WebAssembly(wasm)%20SIMD%E4%BC%98%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<p> [TOC]</p><h2 id="1、Wasm-simd优化方法"><a href="#1、Wasm-simd优化方法" class="headerlink" title="1、Wasm simd优化方法"></a>1、Wasm simd优化方法</h2><p>参考：<br><a href="https://emscripten.org/docs/porting/simd.html" target="_blank" rel="noopener">https://emscripten.org/docs/porting/simd.html</a><br><a href="https://github.com/WebAssembly/simd/blob/main/proposals/simd/SIMD.md" target="_blank" rel="noopener">https://github.com/WebAssembly/simd/blob/main/proposals/simd/SIMD.md</a><br><a href="https://v8.dev/features/simd#building-with-simd-support" target="_blank" rel="noopener">https://v8.dev/features/simd#building-with-simd-support</a> </p><h3 id="1-1-编译器优化选项"><a href="#1-1-编译器优化选项" class="headerlink" title="1.1 编译器优化选项"></a>1.1 编译器优化选项</h3><p>使用 –msimd128 选项，可以使能SIMD。它会打开LLVM的自动矢量化过程。</p><p>LLVM’s autovectorizers are enabled by default at optimization levels -O2 and -O3 when the -msimd128 flag is supplied.</p><p>-s SIMD=1</p><h3 id="1-2、缺陷和行为差异"><a href="#1-2、缺陷和行为差异" class="headerlink" title="1.2、缺陷和行为差异"></a>1.2、缺陷和行为差异</h3><p>注意：<br>1、    Emscripten不支持x86和inline汇编，只支持intrinsic汇编。<br>2、    WebAssembly SIMD无法控制浮点舍入模式的管理或非规格化处理。<br>3、    WebAssembly SIMD不支持cache line prefetch。</p><h3 id="1-3、Chrome开启SIMD支持"><a href="#1-3、Chrome开启SIMD支持" class="headerlink" title="1.3、Chrome开启SIMD支持"></a>1.3、Chrome开启SIMD支持</h3><p>chrome://flags/#enable-webassembly<br><img src="https://img-blog.csdnimg.cn/20210606231222833.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NvYXJpbmdMZWVfZmlnaHRpbmc=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="1-4、Wasm-simd头文件"><a href="#1-4、Wasm-simd头文件" class="headerlink" title="1.4、Wasm simd头文件"></a>1.4、Wasm simd头文件</h3><p><a href="https://github.com/llvm/llvm-project/tree/main/clang/lib/Headers" target="_blank" rel="noopener">https://github.com/llvm/llvm-project/tree/main/clang/lib/Headers</a></p><p>#include &lt;wasm_simd128.h&gt;</p><h3 id="1-5、Wasm-128bit-SIMD扩展"><a href="#1-5、Wasm-128bit-SIMD扩展" class="headerlink" title="1.5、Wasm 128bit SIMD扩展"></a>1.5、Wasm 128bit SIMD扩展</h3><p>Emscripten支持编译现存采用x86 SSE优化的代码，直接传递 –msse 给编译器，并且包含头文件&lt;xmmintrin.h&gt;。</p><p>当前只支持SSE1, SSE2, SSE3, SSSE3, SSE4.1, SSE4.2 和128位的 AVX指令集。</p><p>数据类型： v128</p><p>立即数:<br>•    ImmByte: A single unconstrained byte (0-255).<br>•    ImmLaneIdx2: A byte with values in the range 0–1 identifying a lane.<br>•    ImmLaneIdx4: A byte with values in the range 0–3 identifying a lane.<br>•    ImmLaneIdx8: A byte with values in the range 0–7 identifying a lane.<br>•    ImmLaneIdx16: A byte with values in the range 0–15 identifying a lane.<br>•    ImmLaneIdx32: A byte with values in the range 0–31 identifying a lane.</p><h2 id="2、wasm优化测试demo"><a href="#2、wasm优化测试demo" class="headerlink" title="2、wasm优化测试demo"></a>2、wasm优化测试demo</h2><p><a href="https://github.com/soaringleefighting/WebAssembly" target="_blank" rel="noopener">https://github.com/soaringleefighting/WebAssembly</a></p><h2 id="3、Wasm-Intrinsic优化基础"><a href="#3、Wasm-Intrinsic优化基础" class="headerlink" title="3、Wasm Intrinsic优化基础"></a>3、Wasm Intrinsic优化基础</h2><h3 id="3-1、主要Intrinsics函数"><a href="#3-1、主要Intrinsics函数" class="headerlink" title="3.1、主要Intrinsics函数"></a>3.1、主要Intrinsics函数</h3><h4 id="3-1-1-数据移位指令"><a href="#3-1-1-数据移位指令" class="headerlink" title="3.1.1 数据移位指令"></a>3.1.1 数据移位指令</h4><ul><li><p>算术右移：<br>_mm_sra_epi16: Shift packed 16-bit integers in a right by count while shifting in sign bits, and store the results in dst.</p></li><li><p>逻辑右移：<br>_mm_srl_epi16：Shift packed 16-bit integers in a right by count while shifting in zeros, and store the results in dst.</p></li></ul><p>疑问：<br>_mm_srli_si128与_mm_bsrli_si128指令区别？</p><h4 id="3-1-2-读取和存储指令"><a href="#3-1-2-读取和存储指令" class="headerlink" title="3.1.2 读取和存储指令"></a>3.1.2 读取和存储指令</h4><ul><li>32位读取和存储指令：</li></ul><p>_mm_loadu_si32<br>_mm_storeu_si32</p><ul><li>64位读取和存储指令：</li></ul><p>_mm_loadl_epi64<br>_mm_storel_epi64</p><ul><li>128位读取和存储指令：</li></ul><p>_mm_load_si128<br>_mm_store_si128</p><p>_mm_loadu_si128<br>_mm_storeu_si128</p><h4 id="3-1-3-不同位数数据扩展或转换"><a href="#3-1-3-不同位数数据扩展或转换" class="headerlink" title="3.1.3 不同位数数据扩展或转换"></a>3.1.3 不同位数数据扩展或转换</h4><ul><li><p>16位有符号整数转换为8位整数（带有无符号饱和）<br>_mm_packus_epi16: Convert packed signed 16-bit integers from a and b to packed 8-bit integers using unsigned saturation, and store the results in dst.</p></li><li><p>8位无符号整数扩展为16位整数<br>_mm_cvtepu8_epi16：Zero extend packed unsigned 8-bit integers in a to packed 16-bit integers, and store the results in dst.</p></li><li><p>8位整数有符号扩展为16位整数<br>_mm_cvtepi8_epi16：Sign extend packed 8-bit integers in a to packed 16-bit integers, and store the results in dst.</p></li><li><p>16位与32位之间数据转换<br>_mm_cvtepi16_epi32<br>_mm_cvtepu16_epi32</p></li></ul><h4 id="3-1-4-乘法指令"><a href="#3-1-4-乘法指令" class="headerlink" title="3.1.4 乘法指令"></a>3.1.4 乘法指令</h4><p>_mm_mullo_epi16： Multiply the packed 16-bit integers in a and b, producing intermediate 32-bit integers, and store the low 16 bits of the intermediate integers in dst.</p><h4 id="3-1-5-数据提取指令Shuffle"><a href="#3-1-5-数据提取指令Shuffle" class="headerlink" title="3.1.5 数据提取指令Shuffle"></a>3.1.5 数据提取指令Shuffle</h4><p>_mm_shuffle_epi32: Shuffle 32-bit integers in a using the control in imm8, and store the results in dst.</p><p>_mm_extract_epi16：Extract a 16-bit integer from a, selected with imm8, and store the result in the lower element of dst.</p><h3 id="3-2、优化点总结"><a href="#3-2、优化点总结" class="headerlink" title="3.2、优化点总结"></a>3.2、优化点总结</h3><p>未完待续。。。。。。。</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> Web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Wasm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>arm neon intrinsic方式编写arm32位汇编</title>
      <link href="/2021/05/19/%E3%80%90ARM%E7%B3%BB%E5%88%97%E3%80%91arm%20neon%20intrinsic%E6%96%B9%E5%BC%8F%E7%BC%96%E5%86%99arm32%E4%BD%8D%E6%B1%87%E7%BC%96/"/>
      <url>/2021/05/19/%E3%80%90ARM%E7%B3%BB%E5%88%97%E3%80%91arm%20neon%20intrinsic%E6%96%B9%E5%BC%8F%E7%BC%96%E5%86%99arm32%E4%BD%8D%E6%B1%87%E7%BC%96/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="1、c、arm32和intrinsic方式对比"><a href="#1、c、arm32和intrinsic方式对比" class="headerlink" title="1、c、arm32和intrinsic方式对比"></a>1、c、arm32和intrinsic方式对比</h2><pre><code class="c">int a = 32;  // c codevdup.32 d0, r0   // arm32 assembly codeint32x2_t a1=vdup_n_s32(a); // intrinsic assembly code</code></pre><h2 id="2、-数组相加"><a href="#2、-数组相加" class="headerlink" title="2、 数组相加"></a>2、 数组相加</h2><p>Intrinsic方式下同种数据类型之间进行运算，可采用类似C的方式：<br>例如：</p><pre><code class="c">uint32x4_t v11 = vpadd1q_u16(v1); //相邻两两相加uint32x4_t v21 = vpadd1q_u16(v2);v13 = vaddq_u32(v11, v21);等价于：v13 = v11 + v21;</code></pre><h2 id="3、取q寄存器的低64位和高64位"><a href="#3、取q寄存器的低64位和高64位" class="headerlink" title="3、取q寄存器的低64位和高64位"></a>3、取q寄存器的低64位和高64位</h2><p>采用q寄存器对应数组地址的方式，效率相对较高。</p><pre><code class="c">uint16x4_t* d = (uint16x4_t*)(&amp;m3); //取地址，并强制类型转换uint16x4_t m4 = d[0]; //取数组的低64位；uint16x4_t m5 = d[1]; //取数组的高64位。</code></pre><h2 id="4、-d寄存器到q寄存器"><a href="#4、-d寄存器到q寄存器" class="headerlink" title="4、 d寄存器到q寄存器"></a>4、 d寄存器到q寄存器</h2><pre><code class="c">int 32x2_t w1 = vshrn_n_s64(v1, 10);int 32x2_t w2 = vshrn_n_s64(v2,10);int32x4_t  r1 = {w1[0], w1[1], w2[0], w2[1]};//注意：此种方式效率很低。vst1q_s32(ft1+i, r1);</code></pre><h2 id="5、arm-neon-intrinsics查找手册"><a href="#5、arm-neon-intrinsics查找手册" class="headerlink" title="5、arm neon intrinsics查找手册"></a>5、arm neon intrinsics查找手册</h2><p>函数查找手册：<a href="https://developer.arm.com/technologies/neon/intrinsics" target="_blank" rel="noopener">https://developer.arm.com/technologies/neon/intrinsics</a><br>介绍： <a href="http://infocenter.arm.com/help/topic/com.arm.doc.dht0002a/DHT0002A_introducing_neon.pdf" target="_blank" rel="noopener">http://infocenter.arm.com/help/topic/com.arm.doc.dht0002a/DHT0002A_introducing_neon.pdf</a><br><a href="https://developer.arm.com/technologies/neon" target="_blank" rel="noopener">https://developer.arm.com/technologies/neon</a><br><a href="http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.dui0491h/CIHJBEFE.html" target="_blank" rel="noopener">http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.dui0491h/CIHJBEFE.html</a><br><a href="https://blog.csdn.net/hemmingway/article/details/44828303" target="_blank" rel="noopener">https://blog.csdn.net/hemmingway/article/details/44828303</a></p><hr><p><font color="red"><strong>THE END！</strong></font></p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 优化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ARM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>亿联视频会议产品矩阵简介</title>
      <link href="/2021/03/20/%E3%80%90%E8%A7%86%E9%A2%91%E4%BC%9A%E8%AE%AE%E7%B3%BB%E5%88%97%E3%80%91%E4%BA%BF%E8%81%94%E8%A7%86%E9%A2%91%E4%BC%9A%E8%AE%AE%E4%BA%A7%E5%93%81%E7%9F%A9%E9%98%B5%E7%AE%80%E4%BB%8B/"/>
      <url>/2021/03/20/%E3%80%90%E8%A7%86%E9%A2%91%E4%BC%9A%E8%AE%AE%E7%B3%BB%E5%88%97%E3%80%91%E4%BA%BF%E8%81%94%E8%A7%86%E9%A2%91%E4%BC%9A%E8%AE%AE%E4%BA%A7%E5%93%81%E7%9F%A9%E9%98%B5%E7%AE%80%E4%BB%8B/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>亿联网络对不同细分群体和场景的共性需求进行深入的总结和分析，推出了三大产品类型，包括<strong>面向桌面的语音终端</strong>、<strong>面向会议的会议音视频方案</strong>，以及<strong>面向个人场景的云办公终端</strong>，并打造不同规格的产品梯队面向各类细分场景，提供满足全方位需求的通信方案。完整的产品矩阵让平台方只需选择一家合作厂商就能打造出各类方案，产品间的相互调优还能带来更优质的体验。</p><h2 id="零、融合通信-UME"><a href="#零、融合通信-UME" class="headerlink" title="零、融合通信 UME"></a>零、融合通信 UME</h2><ul><li>UME：<a href="https://www.yealink.com.cn/product/yealink-ume" target="_blank" rel="noopener">https://www.yealink.com.cn/product/yealink-ume</a></li></ul><h2 id="一、视频话机-SIP"><a href="#一、视频话机-SIP" class="headerlink" title="一、视频话机 SIP"></a>一、视频话机 SIP</h2><ul><li>T56A：退市产品</li><li>VP59：旗舰级桌面视频话机 <a href="https://www.yealink.com.cn/product/video-conferencing-solutions-vp59" target="_blank" rel="noopener">https://www.yealink.com.cn/product/video-conferencing-solutions-vp59</a></li><li>T49G: <a href="https://www.yealink.com.cn/product/voice-communication-solutions-t49g" target="_blank" rel="noopener">https://www.yealink.com.cn/product/voice-communication-solutions-t49g</a></li><li>T58V: <a href="https://www.yealink.com.cn/product/voice-communication-solutions-t58v" target="_blank" rel="noopener">https://www.yealink.com.cn/product/voice-communication-solutions-t58v</a></li><li>CP960:  安卓触控会议电话 <a href="https://www.yealink.com.cn/product/voice-communication-solutions-cp960" target="_blank" rel="noopener">https://www.yealink.com.cn/product/voice-communication-solutions-cp960</a></li><li>CP900: 会议电话</li></ul><h2 id="二、视频会议系统-VCS-（Video-Conference-System）"><a href="#二、视频会议系统-VCS-（Video-Conference-System）" class="headerlink" title="二、视频会议系统 VCS （Video Conference System）"></a>二、视频会议系统 VCS （Video Conference System）</h2><h3 id="（1）云视频会议："><a href="#（1）云视频会议：" class="headerlink" title="（1）云视频会议："></a>（1）云视频会议：</h3><ul><li>VCD（VC Desktop）PC端 ： <a href="https://www.yealink.com.cn/product/video-conferencing-solutions-vcd" target="_blank" rel="noopener">https://www.yealink.com.cn/product/video-conferencing-solutions-vcd</a></li><li>VCM（VC Mobile）移动端 ： <a href="https://www.yealink.com.cn/product/video-conferencing-solutions-vcm" target="_blank" rel="noopener">https://www.yealink.com.cn/product/video-conferencing-solutions-vcm</a></li><li>亿联会议软终端</li></ul><h3 id="（2）会议室终端："><a href="#（2）会议室终端：" class="headerlink" title="（2）会议室终端："></a>（2）会议室终端：</h3><ul><li>M400：4K超清智能视讯终端（2000万像素、AI智能取景、多种投屏方式、8颗麦克风阵列），小型会议室 <a href="https://www.yealink.com.cn/product/video-conferencing-solutions-meetingeye400" target="_blank" rel="noopener">https://www.yealink.com.cn/product/video-conferencing-solutions-meetingeye400</a></li><li>M600: <a href="https://www.yealink.com.cn/product/video-conferencing-solutions-meetingeye600" target="_blank" rel="noopener">https://www.yealink.com.cn/product/video-conferencing-solutions-meetingeye600</a>， 中型会议室</li></ul><ul><li><p>VCH51：投屏工具</p></li><li><p>CTP18/CTP20： 协作触控平板（电子白板、辅流批注、会议控制）<br><a href="https://www.yealink.com.cn/product/video-conferencing-solutions-ctp18" target="_blank" rel="noopener">https://www.yealink.com.cn/product/video-conferencing-solutions-ctp18</a><br><a href="https://www.yealink.com.cn/product/video-conferencing-solutions-ctp20" target="_blank" rel="noopener">https://www.yealink.com.cn/product/video-conferencing-solutions-ctp20</a></p></li><li><p>WPP20：无线辅流传屏器 <a href="https://www.yealink.com.cn/product/video-conferencing-solutions-wpp20" target="_blank" rel="noopener">https://www.yealink.com.cn/product/video-conferencing-solutions-wpp20</a></p></li><li><p>Meetingbar A20：尚未上市</p></li><li><p>UVC30/40/84/86： <a href="https://www.yealink.com.cn/product/camera-uvc40" target="_blank" rel="noopener">https://www.yealink.com.cn/product/camera-uvc40</a>, USB摄像机</p></li><li><p>VC200/VC210/VC800/VC880/VC500： <a href="https://www.yealink.com.cn/product/video-conferencing-solutions-vc210" target="_blank" rel="noopener">https://www.yealink.com.cn/product/video-conferencing-solutions-vc210</a><br><a href="https://www.yealink.com.cn/product/video-conferencing-solutions-vc800" target="_blank" rel="noopener">https://www.yealink.com.cn/product/video-conferencing-solutions-vc800</a><br><a href="https://www.yealink.com.cn/product/video-conferencing-solutions-vc500" target="_blank" rel="noopener">https://www.yealink.com.cn/product/video-conferencing-solutions-vc500</a><br><a href="https://www.yealink.com.cn/product/video-conferencing-solutions-vc880" target="_blank" rel="noopener">https://www.yealink.com.cn/product/video-conferencing-solutions-vc880</a></p></li></ul><h2 id="三、视频会议服务器-YMS-Yealink-Meeting-Server-：私有化部署"><a href="#三、视频会议服务器-YMS-Yealink-Meeting-Server-：私有化部署" class="headerlink" title="三、视频会议服务器 YMS(Yealink Meeting Server)：私有化部署"></a>三、视频会议服务器 YMS(Yealink Meeting Server)：私有化部署</h2><p>亿联多媒体视频会议服务器（Yealink Meeting Server）是一款多功能视频会议系统服务器，集成了MCU、注册、穿透、会议管理、会议设备管理、企业地址簿、SIP中继、WebRTC、GK &amp; H.460和微软Skype for Business (Lync)网关和白板协作服务等多个服务模块于一体，身材小、能量大，为企业提高会议效率、节省资金与人力成本。</p><ul><li>YMS3000、YMS2000、YMS1000</li></ul><h2 id="四、USB设备"><a href="#四、USB设备" class="headerlink" title="四、USB设备"></a>四、USB设备</h2><ul><li>UVC40/84/86： <a href="https://www.yealink.com.cn/product/camera-uvc40" target="_blank" rel="noopener">https://www.yealink.com.cn/product/camera-uvc40</a></li></ul><h2 id="五、微软Teams"><a href="#五、微软Teams" class="headerlink" title="五、微软Teams"></a>五、微软Teams</h2><ul><li>VP59 Mircosoft Teams</li><li>MVC400</li><li>MVC800II</li></ul><h2 id="六、Zoom-Rooms"><a href="#六、Zoom-Rooms" class="headerlink" title="六、Zoom Rooms"></a>六、Zoom Rooms</h2><ul><li>ZVC300:  <a href="https://www.yealink.com.cn/product/yealink_zoomrooms_zvc300" target="_blank" rel="noopener">https://www.yealink.com.cn/product/yealink_zoomrooms_zvc300</a></li></ul><p>注：所有内容均来自亿联官网： <a href="https://www.yealink.com.cn/" target="_blank" rel="noopener">https://www.yealink.com.cn/</a></p>]]></content>
      
      
      <categories>
          
          <category> 产品 </category>
          
          <category> 视频会议 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 视频会议 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2021年阅读书单</title>
      <link href="/2021/02/13/%E3%80%90Books%E7%B3%BB%E5%88%97%E3%80%912021%E5%B9%B4%E9%98%85%E8%AF%BB%E4%B9%A6%E5%8D%95/"/>
      <url>/2021/02/13/%E3%80%90Books%E7%B3%BB%E5%88%97%E3%80%912021%E5%B9%B4%E9%98%85%E8%AF%BB%E4%B9%A6%E5%8D%95/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="2021年阅读书单"><a href="#2021年阅读书单" class="headerlink" title="2021年阅读书单"></a>2021年阅读书单</h2><p>1、坚持阅读，精读5本书，做好读书笔记。拓宽阅读视野。</p><h3 id="1、文学"><a href="#1、文学" class="headerlink" title="1、文学"></a>1、文学</h3><table><thead><tr><th>书籍</th><th>状态</th></tr></thead><tbody><tr><td>《啊2.0》</td><td><font color="red">未读</font></td></tr><tr><td>《围城》</td><td><font color="red">未读</font></td></tr><tr><td>《黄金时代》</td><td><font color="red">未读</font></td></tr><tr><td>《白夜行》</td><td><font color="red">未读</font></td></tr><tr><td>《摆渡人》</td><td><font color="red">未读</font></td></tr></tbody></table><h3 id="2、职场"><a href="#2、职场" class="headerlink" title="2、职场"></a>2、职场</h3><table><thead><tr><th>书籍</th><th>状态</th></tr></thead><tbody><tr><td>《拼职场》</td><td><font color="red">未读</font></td></tr><tr><td>《工匠精神》</td><td><font color="red">未读</font></td></tr><tr><td>《赢在执行》</td><td><font color="red">未读</font></td></tr></tbody></table><h3 id="3、历史"><a href="#3、历史" class="headerlink" title="3、历史"></a>3、历史</h3><table><thead><tr><th>书籍</th><th>状态</th></tr></thead><tbody><tr><td>《人类简史》</td><td><font color="red">未读</font></td></tr><tr><td>《万历十五年》</td><td><font color="red">未读</font></td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 读书 </category>
          
          <category> 书单 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Books </tag>
            
            <tag> ReadingList </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>H.264参考帧队列管理机制：初始化、重排序和标记</title>
      <link href="/2021/01/10/%E3%80%90Codecs%E7%B3%BB%E5%88%97%E3%80%91H.264%E5%8F%82%E8%80%83%E5%B8%A7%E9%98%9F%E5%88%97%E7%AE%A1%E7%90%86%E6%9C%BA%E5%88%B6%EF%BC%9A%E5%88%9D%E5%A7%8B%E5%8C%96%E3%80%81%E9%87%8D%E6%8E%92%E5%BA%8F%E5%92%8C%E6%A0%87%E8%AE%B0/"/>
      <url>/2021/01/10/%E3%80%90Codecs%E7%B3%BB%E5%88%97%E3%80%91H.264%E5%8F%82%E8%80%83%E5%B8%A7%E9%98%9F%E5%88%97%E7%AE%A1%E7%90%86%E6%9C%BA%E5%88%B6%EF%BC%9A%E5%88%9D%E5%A7%8B%E5%8C%96%E3%80%81%E9%87%8D%E6%8E%92%E5%BA%8F%E5%92%8C%E6%A0%87%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="1、参考"><a href="#1、参考" class="headerlink" title="1、参考"></a>1、参考</h2><p><a href="https://blog.csdn.net/kayson12345/article/details/105646947#33_JM_138" target="_blank" rel="noopener">H.264多参考帧管理</a><br><a href="https://blog.csdn.net/tanningzhong/article/details/52415730" target="_blank" rel="noopener">H.264句法和语法总结（六）参考帧队列重排序（reordering）句法</a><br><a href="https://blog.csdn.net/qq_42024067/article/details/108021774" target="_blank" rel="noopener">H264—参考列表—-初始化、重排序、已解码图像的标记</a></p><h2 id="2、参考帧列表和DPB"><a href="#2、参考帧列表和DPB" class="headerlink" title="2、参考帧列表和DPB"></a>2、参考帧列表和DPB</h2><p>对于每一个P帧和B帧的解码都需要从解码图像缓存DPB中选择某个参考帧。DPB中的参考帧可分为<strong>短期参考帧</strong>和<strong>长期参考帧</strong>两种，分别按照PicNum和LongTermFrameIdx索引。通过这两个索引值可以在参考帧列表中获取对应的参考帧图像。</p><p>解码不同的帧类型时，参考帧列表不同。</p><ul><li>当解码P、SP帧时，使用一个参考帧列表RefPicList0；</li><li>当解码B帧时，使用两个参考帧列表RefPicList0和RefPicList1。</li></ul><p>执行过程如下：<br>　1、对参考帧列表进行初始化；<br>　2、对参考帧列表重排序和标记。</p><p><strong>DPB管理策略：</strong><br>DPB对解码图像的存储有个策略：更倾向于存储对后面编码有用的图像（也就是参考图像）。</p><p>虽然说DPB中也可以存储非参考图像，在DPB没满的时候，会无差别地把参考图像与非参考图像一并插入DPB中；<br>但是一旦DPB满了之后：<br> 如果新重建的图像为参考图像，该参考图像需要插入DPB</p><ul><li>如果DPB中没有非参考图像，会按照滑动窗口模式把DPB序号最小的参考图像移除；</li><li>如果DPB中存在非参考图像，会把DPB中已经输出到磁盘的非参考图像移除；</li></ul><p>如果新重建的图像为非参考图像，</p><ul><li>如果DPB中不存在比当前图像POC更小的非参考图像，当前非参考图像会被直接输出到磁盘，而不插入DPB；</li><li>如果DPB中存在比当前图像POC更小的非参考图像，会把DPB中POC最小的参考图像移除，插入当前非参考图像；　<h2 id="3、参考帧列表RPL初始化"><a href="#3、参考帧列表RPL初始化" class="headerlink" title="3、参考帧列表RPL初始化"></a>3、参考帧列表RPL初始化</h2><h3 id="3-1、P帧排序"><a href="#3-1、P帧排序" class="headerlink" title="3.1、P帧排序"></a>3.1、P帧排序</h3>P帧的前向参考帧列表RefPicList0：<br>先短期参考帧（索引值小，PicNum降序排列），后长期参考帧（索引值小，LongTermPicNum升序排列）<br>一般来说，距离当前图像最近的参考图像会被当前图像用作最多的参考，距离越远则参考得越少，短期参考图像列表就是依据这种规律来进行排序的。</li></ul><p>短期参考图像的序号由FrameNumWrap进行标记，以GOP为一个周期，GOP的第一帧的FrameNumWrap为0，后面持续递增，到当前帧是FrameNumWrap为最大，因此FrameNumWrap越大代表距离当前图像越近，因此将参考帧以FrameNumWrap降序方式放在refPicList0的起始位置。 长期参考图像的序号由LongTermPicNum进行标记，以升序的方式进行排序，（LongTermPicNum由MMCO分配）。<br><img src="https://img-blog.csdnimg.cn/20210213123608544.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NvYXJpbmdMZWVfZmlnaHRpbmc=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="3-2、B帧排序"><a href="#3-2、B帧排序" class="headerlink" title="3.2、B帧排序"></a>3.2、B帧排序</h3><p>B帧的参考帧排列方式与P帧并不完全相同，B帧的短期参考帧是以POC进行排序，其中有前向参考列表refPicList0与后向参考列表refPicList1</p><ul><li>当参考帧的POC小于当前图像的POC时，将参考帧以POC降序方式放在refPicList0的起始位置上。然后剩余的短期参考图像按照POC升序的方式附加到refPicList0</li><li>当参考帧的POC大于当前图像的POC时，将参考帧以POC升序方式放在refPicList1的起始位置上。然后剩余的短期参考图像按照POC降序的方式附加到refPicList1</li><li>长期参考图像的序号由LongTermPicNum进行标记，以升序的方式进行排序，分别放进refPicList0与refPicList1中 。</li></ul><p><img src="https://img-blog.csdnimg.cn/20210213123740288.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NvYXJpbmdMZWVfZmlnaHRpbmc=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="4、参考帧列表重排序-Reordering"><a href="#4、参考帧列表重排序-Reordering" class="headerlink" title="4、参考帧列表重排序 Reordering"></a>4、参考帧列表重排序 Reordering</h2><h3 id="4-1、为什么要重排序？"><a href="#4-1、为什么要重排序？" class="headerlink" title="4.1、为什么要重排序？"></a>4.1、为什么要重排序？</h3><p>解码时，非I帧图像的解码将会以参考图像队列中的某一参考图像作为参考，宏块层需要有一个句法元素告诉解码器，当前帧所要参考的参考图像是哪一帧。编码器会给每一个参考帧分配一个唯一性的标识，也就是句法元素frame_num，但这个句法元素并非解码的时候宏块层所指定的序号，宏块层指定的序号是一个ref_id。为什么编码器在编码的时候，不在宏块层标明参考图像的frame_num，而是标明一个ref_id呢，它的目的在于节省码流。</p><p>什么是ref_id。编码器和解码器同步地维护一个参考帧队列，每解码一个片就将该队列刷新一下，把各图像按照特定的规则进行排序，排序后各图像在队列中的序号就是该图像的ref_id值。</p><p>frame_num的数值随着编解码的进行，会越来越大，如果直接用frame_num做标识，那码流的比特数开销会很大。假设，一帧1920x1088的图像以8x8的宏块单元可划分为240x136个宏块，每个宏块指定一个参考帧的序号，这个序号如果是frame_num，frame_num可能处于[0, 134]的区间，比特数开销大，如果这个是序号是ref_id，ref_id只处于[0, num_ref_idx_10_active_munus1]的区间，比特数开销小。</p><p>因此将frame_num映射为一个更小的变量ref_id。</p><h3 id="4-2、重排序过程"><a href="#4-2、重排序过程" class="headerlink" title="4.2、重排序过程"></a>4.2、重排序过程</h3><p><img src="https://img-blog.csdnimg.cn/20210213124918368.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NvYXJpbmdMZWVfZmlnaHRpbmc=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><strong>举例：</strong></p><p>我们直接看一个例子，假设现在在解码一个P slice，P帧只需要用到list0列表中的参考图像作参考，当前list0一共有5帧参考图像，而目前正解码的P帧的frame_num为158。</p><p>list0: [157, 155, 153, 1, 3]</p><p>前三帧为短期参考帧，降序排序，序号为[157， 155， 153]，后两帧为长期参考帧，升序排列，序号为[1, 3]。</p><p>当我们解析到Slice层的重排序句法时，ref_pic_list_reoredering_flag_10为真，第1个reordering_of_pic_nums_idc为0，那么将对短期参考帧重排序。初始时，ref_id为0（即refIdxL0 = 0），需要重排序的短期参考图像经过固定流程的计算，确认其序号为153。参考列表第1个元素将更新为153，而随后的短期参考图像将后移一位覆盖，也就是157，155均向后移一位，155将覆盖原153。这个所谓的固定流程的计算，也就是从当前图像的PicNum减去(abs_diff_pic_num_minus1+1)，这个计算的流程将在后续详解。</p><p>第二步如第一步类似的操作，eordering_of_pic_nums_idc为1，将对短期参考帧重排序，经过固定流程的计算，需要重排序的短期参考图像序号为155，则参考列表第2个元素将更新为155，而随后的短期参考图像将后移一位覆盖，也就是157向后移一位，157将覆盖原155。</p><p>第三步，reordering_of_pic_nums_idc = 2，我们将对长期参考帧重排序，long_term_pic_num = 3，此时refIdxL0为2，那么列表第2位的元素将从157更新为3，原157， 1这两个元素将后移一位，而最末尾的元素3是被指定要重排序的，因此将被移出列表。</p><p>第四步，reordering_of_pic_nums_idc = 3，此时重排序结束。</p><h2 id="5、参考帧列表标记过程-Marking"><a href="#5、参考帧列表标记过程-Marking" class="headerlink" title="5、参考帧列表标记过程 Marking"></a>5、参考帧列表标记过程 Marking</h2><h3 id="5-1、为什么要标记？"><a href="#5-1、为什么要标记？" class="headerlink" title="5.1、为什么要标记？"></a>5.1、为什么要标记？</h3><p>解码器在完成一幅图像的解码后，需要对已解码图像进行存储处理，如果此图像用于其他图像的参考，则要进行DPB中已解码图像的标记操作，DPB标记完成后，如果需要的话，则把当前图像插入DPB。DPB的长度大小是有限制的，更倾向于存储对后面编码有用的图像（也就是参考图像），非参考图像将被移出DPB，而且，长短期参考图像的互转将在标记中完成。标记完后，下一帧图像在解码时，参考图像列表的初始化才能从新的DPB中取出经过更新的参考图像。</p><h3 id="5-2、标记过程"><a href="#5-2、标记过程" class="headerlink" title="5.2、标记过程"></a>5.2、标记过程</h3><p><img src="https://img-blog.csdnimg.cn/20210213124935991.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NvYXJpbmdMZWVfZmlnaHRpbmc=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong>1、保存重建图像到DPB</strong></p><p>如果当前图像是IDR帧，则根据读入的语法元素no_output_of_prior_pics_flag ，指明是否清空DPB，0表示DPB中所有的图像不进行输出，但是需要从DPB中移除，1表示从DPB中移除所有图像并输出到磁盘，另外，还将根据long_term_reference_flag 确定将IDR帧作为长期参考还是短期参考。参见[图 参考图像标记流程]。</p><p>非IDR帧情况，当前帧作为短期参考插入DPB，插入DPB之前需要对当前DPB进行重新标记，如果adaptive_ref_pic_marking_mode指定为0，则采用滑动窗的机制进行标记，如果adaptive_ref_pic_marking_mode指定为1，则其中有6种标记方法，即内存管理控制操作（memory management control operation） 。参见[图 参考图像的自适应内存控制标记过程]。</p><p><strong>2、参考图像标记</strong></p><p>参考图像标记有两种方法，自动滑窗法和自定义标记法，由相应的句法元素确定采用何种方法。</p><ul><li><p>自动滑窗法：即FIFO的方法，当DPB已满时，将DPB中PicNum最小的短期参考图像（即最早的参考图像）移出DPB。</p></li><li><p>自定义标记法(adaptive_ref_pic_marking_mode)：在句法元素中指定将某一参考图像设置为何种类型的参考图像或移出。</p></li></ul><p>注：大部分参考学习自：<a href="https://blog.csdn.net/kayson12345/article/details/105646947#33_JM_138" target="_blank" rel="noopener">H.264多参考帧管理</a></p><p>———————————————<font color="red"><strong>THE END!</strong></font>———————————————————–</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 编解码 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Codecs </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>H.264时域SVC（SVC-T）编码技术</title>
      <link href="/2021/01/04/%E3%80%90Codecs%E7%B3%BB%E5%88%97%E3%80%91H.264%E6%97%B6%E5%9F%9FSVC%EF%BC%88SVC-T%EF%BC%89%E7%BC%96%E7%A0%81%E6%8A%80%E6%9C%AF/"/>
      <url>/2021/01/04/%E3%80%90Codecs%E7%B3%BB%E5%88%97%E3%80%91H.264%E6%97%B6%E5%9F%9FSVC%EF%BC%88SVC-T%EF%BC%89%E7%BC%96%E7%A0%81%E6%8A%80%E6%9C%AF/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="1、参考"><a href="#1、参考" class="headerlink" title="1、参考"></a>1、参考</h2><p><a href="https://blog.csdn.net/SoaringLee_fighting/article/details/102476307" target="_blank" rel="noopener">【Codecs系列】编解码基础知识–可伸缩编码SVC</a><br><a href="https://soaringlee.blog.csdn.net/article/details/112433819" target="_blank" rel="noopener">【Codecs系列】H.264参考帧队列管理：初始化、重排序和标记</a><br>&ensp;<a href="https://blog.csdn.net/dittychen/article/details/77885161" target="_blank" rel="noopener">H.264 SVC</a></p><h2 id="2、SVC-T编码"><a href="#2、SVC-T编码" class="headerlink" title="2、SVC-T编码"></a>2、SVC-T编码</h2><h3 id="2-1-SVC-T简介"><a href="#2-1-SVC-T简介" class="headerlink" title="2.1 SVC-T简介"></a>2.1 SVC-T简介</h3><p>&ensp; &ensp;  SVC（Scalable Video Coding）由AVC（Advanced Video Coding）发展而来，其原本是AVC标准的附录G，不过后来习惯用SVC描述可伸缩（分层）的编码，而用AVC描述不可伸缩的编码，它们都属于H264标准。<br>&ensp; &ensp; SVC分为三种，分别是SVC-T、SVC-Q和SVC-S，即按时间分层、按质量分层和按空间分层。我们现在最常用的是SVC-T，即以时间为标准给视频帧分层。<br>&ensp; &ensp; SVC-T的多层结构中，最上层的都是非参考帧，即不会被任何其它帧参考，越往下层，会被越多的帧作为参考帧，因此帧的重要性也是由上到下增加。在这样的结构中，只要不是基本层（最底层）出错，那么它都能顺利地往下解，所以这种结构有着较好的抗丢包性能。</p><h3 id="2-2-SVC-T新增句法和语义"><a href="#2-2-SVC-T新增句法和语义" class="headerlink" title="2.2 SVC-T新增句法和语义"></a>2.2 SVC-T新增句法和语义</h3><h4 id="2-2-1-Prefix-NAL头信息"><a href="#2-2-1-Prefix-NAL头信息" class="headerlink" title="2.2.1 Prefix NAL头信息"></a>2.2.1 Prefix NAL头信息</h4><p>（1）    对NAL（Network Adaptive Layer）头进行了扩展，用于描述码流的分级信息。为了便于描述AVC兼容码流的分级特性，定一个NAL类型为14的前缀NAL，该类型的NAL出现在AVC兼容码流的NAL前面，用于描述AVC基本层码流的分级信息。见下图所示:<br>（2）    使用保留的NAL类型14、20编码增强层码流（Prefix NAL）。<br><img src="https://img-blog.csdnimg.cn/20210210173140904.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210210173152100.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NvYXJpbmdMZWVfZmlnaHRpbmc=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210210173208857.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NvYXJpbmdMZWVfZmlnaHRpbmc=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/2021021017322356.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NvYXJpbmdMZWVfZmlnaHRpbmc=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h4 id="2-2-2-Slice-header头信息相关"><a href="#2-2-2-Slice-header头信息相关" class="headerlink" title="2.2.2 Slice header头信息相关"></a>2.2.2 Slice header头信息相关</h4><p><strong>1、    参考帧队列重排序：</strong><br>ref_pic_list_reordering：参考帧队列重排序句法<br><img src="https://img-blog.csdnimg.cn/20210210173344306.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NvYXJpbmdMZWVfZmlnaHRpbmc=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><strong>2、参考帧队列标记：</strong><br>dec_ref_pic_marking : 参考帧队列标记句法，MMCO句法<br>H.264编码中参考帧队列管理机制主要有两种方法：</p><ul><li>滑窗操作：FIFO</li><li>MMCO操作：自定义标记<br><img src="https://img-blog.csdnimg.cn/20210210173413586.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NvYXJpbmdMZWVfZmlnaHRpbmc=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li></ul><h3 id="2-3、SVC-T编码中的参考帧队列管理机制"><a href="#2-3、SVC-T编码中的参考帧队列管理机制" class="headerlink" title="2.3、SVC-T编码中的参考帧队列管理机制"></a>2.3、SVC-T编码中的参考帧队列管理机制</h3><p><img src="https://img-blog.csdnimg.cn/20210213130623202.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NvYXJpbmdMZWVfZmlnaHRpbmc=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>SVC-T 3层编码结构的参考帧队列管理：</p><p>1、    在第1帧（IDR，参考帧）编码结束后，第1帧更新为前向参考帧，接着编码第2帧（P帧），参考第1帧。<br>2、    在第2帧（P帧，非参考帧）编码结束后，记录下非参考帧（第2帧）的bank idx，此时重建帧buffer占用2帧。接着编码第3帧，仍然参考第1帧。<br>3、    在第3帧（P帧，参考帧）编码结束后，释放第2帧的buffer，此时重建帧buffer占用2帧。前向参考帧0更新为第3帧，前向参考帧1更新为第1帧。接着编码第4帧，参考第3帧。<br>4、    在第4帧（P帧，非参考帧）编码结束后，记录下非参考帧（第4帧）的bank idx，此时重建帧buffer占用3帧。接着编码第5帧，参考第1帧（reordering）。<br>5、    在第5帧（P帧，参考帧）编码结束后，释放第4帧和第1帧（前向参考帧1），更新前向参考帧0为第5帧，前向参考帧1为第3帧。<br>6、    后面帧的编码继续时3-5。</p><p>———————————————<font color="red"><strong>THE END!</strong></font>———————————————————–</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 编解码 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Codecs </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2020年终总结</title>
      <link href="/2021/01/03/%E3%80%90%E6%80%BB%E7%BB%93%E7%B3%BB%E5%88%97%E3%80%912020%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/"/>
      <url>/2021/01/03/%E3%80%90%E6%80%BB%E7%BB%93%E7%B3%BB%E5%88%97%E3%80%912020%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><p> 2020年，对于世间所有人来说，都是感受深刻的一年，新型冠状肺炎肆虐全球，对人们的生活和工作都产生了很大的影响。2020年年初，口罩成了稀缺资源，人们不得不戴上口罩，逆行的医生护士赶赴抗疫前线，在每天疫情数目不断增加的新闻中，人们充满了担忧和恐惧，这是对生命的敬畏。受疫情的影响，各行各业，尤其餐饮和影视，几乎关门，几个月后很多公司倒闭破产，经济形势萎靡。这是2020年的世界形势。</p><p>我的2020年呢，总结一下关键词就是换工作，感情纠结，年末忙碌。思考一下这一年的大事件，收获，遗憾和开心的事吧。</p><h2 id="一、大事件"><a href="#一、大事件" class="headerlink" title="一、大事件"></a>一、大事件</h2><p>换工作算是今年的大事件吧。也许在哪家公司工作也是一种缘分吧，第一份工作的缘分在将近3年的时间已尽，于是换了现在这家公司。虽然工资没有上涨很多，但是工作的内容和技术积累的方向和我的规划还是一致的，现在基本上也在作为负责人主导项目开发，在项目管理上可以不断积累经验，思考如何更好的做好事情。不过也存在一些发展的限制和瓶颈，后面也要重点考虑一下。</p><h2 id="二、收获"><a href="#二、收获" class="headerlink" title="二、收获"></a>二、收获</h2><p>这一年拿到了中级职称，CSDN博客专家，CSDN文章数超过1000篇，写了150篇博客，开通付费专栏，有了第三收入；离职让我懂得了很多，自我不可替代性、危机意识、核心竞争力和工作心态。个人博客每个月持续更新技术干货，文章数达到125篇。精读了4本书，并作读书笔记于个人博客。旅行去了西塘古镇、芜湖长江、合肥、济南芙蓉街，趵突泉和千佛山，杭州去了法喜寺，爬了北高峰，参加良渚古城毅行活动。老家房子基本办妥，就等入住就好。</p><h2 id="三、遗憾"><a href="#三、遗憾" class="headerlink" title="三、遗憾"></a>三、遗憾</h2><p>这一年多多少少有些遗憾，年初工作不太顺利，所以年后5月份换了一份新工作，在疫情形势不好的情况下，这份工作也算备份吧，薪资待遇和发展空间上并没有达到预期。除了工作，其他事情基本按步就班，也没有什么遗憾可言了。</p><h2 id="四、反思"><a href="#四、反思" class="headerlink" title="四、反思"></a>四、反思</h2><p>今年最大的反思就是第一份工作的离职，让我看懂了工作的本质，改变了工作心态。对于我们这些普通人，努力工作还是基本收入来源。还有就是对工作和未来发展的思考。三十而立的年纪，心境似乎还在二十而已，在父母精心呵护下的我们，似乎永远也长不大。面对生活和工作，充满希望和干劲，尽管中间遭遇短暂的曲折，也迅速恢复到正常工作和生活中了。年末的忙碌似乎冲淡了很多犹豫和彷徨，如此忙碌也是一种幸福吧。最近作为项目负责人，开发新ISP芯片的编解码功能，基本功能已经完成，想必今年的绩效和年终奖也算不错吧，希望如此。</p><h2 id="五、感情"><a href="#五、感情" class="headerlink" title="五、感情"></a>五、感情</h2><p>自从19年谈恋爱开始，感情纠结就此开始了。纠结的点还是在于定居地的问题，此时我的心里对此已经释怀了很多。19年工作不顺使我坚定了回家的想法，然而在19年底遇到了黄山的阿毛，从此开始了一段甜蜜的恋爱，从相识相知到相恋相爱，我们彼此珍惜走到了现在，中间因为定居地的问题分分合合了几次，最后我们还是愿意再商量。希望我提出的五年之约，你能够欣然接受，我也真诚的考虑到你的想法。希望我们这份感情是一朵常开不败的花。</p><h2 id="六、总结"><a href="#六、总结" class="headerlink" title="六、总结"></a>六、总结</h2><p>希望，2020年所有的遗憾，将是2021年所有惊喜的铺垫。最后对2020年的新年flag核对一下，制定一下2021年新年flag。今年开始关注健康和养生，总体不错，眼睛疲劳和腰背酸痛算是职业病了，后面需要注意一点。阅读没有达到10本书，不过也坚持了阅读了一段时间。今年运动较少，爬了几次山，没有打球。饮食不错，体重倒是增加了不少，稳定到了123左右。再见2020年，你好2021年！希望2021是新的起点，新的方向，新的生活！</p><p>———————————————<font color="red"><strong>THE END!</strong></font>———————————————————–</p>]]></content>
      
      
      <categories>
          
          <category> 生活 </category>
          
          <category> 规划 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 年终总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git rebase和git merge用法详解</title>
      <link href="/2020/12/28/%E3%80%90Tools%E7%B3%BB%E5%88%97%E3%80%91git%20rebase%E5%92%8Cgit%20merge%E7%94%A8%E6%B3%95%E8%AF%A6%E8%A7%A3/"/>
      <url>/2020/12/28/%E3%80%90Tools%E7%B3%BB%E5%88%97%E3%80%91git%20rebase%E5%92%8Cgit%20merge%E7%94%A8%E6%B3%95%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="1、参考"><a href="#1、参考" class="headerlink" title="1、参考"></a>1、参考</h2><p><a href="https://www.yiibai.com/git/git_rebase.html" target="_blank" rel="noopener">git rebase命令</a><br><a href="https://www.jianshu.com/p/4a8f4af4e803" target="_blank" rel="noopener">【Git】rebase 用法小结</a></p><h2 id="2、git-rebase的命令格式"><a href="#2、git-rebase的命令格式" class="headerlink" title="2、git-rebase的命令格式"></a>2、git-rebase的命令格式</h2><pre><code class="shell">git rebase [-i | --interactive] [options] [--onto ]  []git rebase [-i | --interactive] [options] --onto  --root []git rebase --continue | --skip | --bort</code></pre><p>从命令格式，可以看到git-rebae命令至少需要一个参数，那就是，这个参数可以是一个分支名称，也可以是一次有效的commit。</p><h2 id="3、git-rebase用法"><a href="#3、git-rebase用法" class="headerlink" title="3、git-rebase用法"></a>3、git-rebase用法</h2><p>git-rebase命令主要用在从上游分支获取最新commit信息，并有机的将当前分支和上游分支进行合并。<strong>巧妙利用git rebase可以使得提交历史干净，清晰！</strong></p><p>基本用法如下：</p><pre><code class="shell">git rebase --onto 966218f（基于这个版本） aab3002（不包含这个commit） 65fc070（包含这个commit）</code></pre><p><strong>初始状态：</strong><br><img src="https://img-blog.csdnimg.cn/20201231105023336.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NvYXJpbmdMZWVfZmlnaHRpbmc=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong>git rebase origin 后：</strong></p><p><img src="https://img-blog.csdnimg.cn/20201231105124198.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NvYXJpbmdMZWVfZmlnaHRpbmc=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/2020123111010212.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NvYXJpbmdMZWVfZmlnaHRpbmc=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><strong>另外两种用法：</strong><br>1、用法1</p><p><img src="https://img-blog.csdnimg.cn/20201231110119259.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NvYXJpbmdMZWVfZmlnaHRpbmc=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>2、用法2<br><img src="https://img-blog.csdnimg.cn/20201231110126886.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NvYXJpbmdMZWVfZmlnaHRpbmc=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="4、git-rebase冲突解决"><a href="#4、git-rebase冲突解决" class="headerlink" title="4、git rebase冲突解决"></a>4、git rebase冲突解决</h2><p>在rebase的过程中，也许会出现冲突(conflict)。在这种情况，Git会停止rebase并会让你去解决冲突；在解决完冲突后，用”git add“命令去更新这些内容的索引(index), 然后，你无需执行 git commit,只要执行:</p><pre><code class="shell">$ git rebase --continue</code></pre><p>这样git会继续应用(apply)余下的补丁。<br>在任何时候，可以用 –abort参数来终止rebase的操作，并且”mywork“ 分支会回到rebase开始前的状态。</p><pre><code class="shell">$ git rebase --abort</code></pre><h2 id="5、git-rebase与git-merge的区别"><a href="#5、git-rebase与git-merge的区别" class="headerlink" title="5、git rebase与git merge的区别"></a>5、git rebase与git merge的区别</h2><p><img src="https://img-blog.csdnimg.cn/20201231110227279.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NvYXJpbmdMZWVfZmlnaHRpbmc=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>———————————————<font color="red"><strong>THE END!</strong></font>———————————————————–</p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在Win7系统上利用Simics安装Solaris 8 SPARC操作系统</title>
      <link href="/2020/12/25/%E3%80%90Tools%E7%B3%BB%E5%88%97%E3%80%91%E5%9C%A8Win7%E7%B3%BB%E7%BB%9F%E4%B8%8A%E5%88%A9%E7%94%A8Simics%E5%AE%89%E8%A3%85Solaris%208%20SPARC%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
      <url>/2020/12/25/%E3%80%90Tools%E7%B3%BB%E5%88%97%E3%80%91%E5%9C%A8Win7%E7%B3%BB%E7%BB%9F%E4%B8%8A%E5%88%A9%E7%94%A8Simics%E5%AE%89%E8%A3%85Solaris%208%20SPARC%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><p>转载自：<a href="https://blog.csdn.net/robertchenguangzhi/article/details/41593221" target="_blank" rel="noopener">https://blog.csdn.net/robertchenguangzhi/article/details/41593221</a></p><h2 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1 介绍"></a>1 介绍</h2><p>我有一个二进制文件，是一个程序，它在Ubuntu系统上不能执行，利用file 命令得到的结果为：</p><pre><code>GraphGen: ELF 32-bit MSB executable, SPARC, version 1 (SYSV), dynamically linked (uses shared libs), not stripped</code></pre><p>根据上面的提示，我就想到了在Virtual box虚拟机上安装Soloari SPARC系列的操作系统，因为上面的提示是SPARC 硬件架构下可以执行的二进制程序。于是就下载了sol-10-11-ga-sparc-dvd.iso文件，在Oracle VM VirtualBox 上面安装，可是本能成功，因为我的电脑是x86架构的，从Google 上面搜出的结果是，要想再VirtualBox 安装Solaris 操作系统，必须安装支持X86的安装文件，不能安装支持SPARC 结构的文件。利用VirtualBox 这条路走不通。</p><p>那么，能否有一种方法，在我的X86 架构的电脑上虚拟使用SPARC 架构类型的操作系统，例如Solaris 8 等，使得我的GraphGen程序能够顺利运行呢？从网络上搜索出来的答案为：通过Simics 虚拟安装SPARC 结构的操作系统。利用VirtualBox 或者VMvare 等方法安装SPARC 架构的操作系统行不通。</p><h2 id="2-前期安装准备"><a href="#2-前期安装准备" class="headerlink" title="2 前期安装准备"></a>2 前期安装准备</h2><h3 id="2-1-下载Solaris-8-iso映像文件"><a href="#2-1-下载Solaris-8-iso映像文件" class="headerlink" title="2.1 下载Solaris 8 iso映像文件"></a>2.1 下载Solaris 8 iso映像文件</h3><p> 由于后面我使用的Simics 的版本比较低，所以我就选择了低版本的Solaris 8 操作系统映像文件。该操作系统安装文件分2个iso 文件来下载，它们的下载地址为：<br><a href="ftp://ftp.pl.freebsd.org/vol/rzm1/solaris-cd-pm/8/sparc/sol-8-u7-sparc-v1.zip" target="_blank" rel="noopener">ftp://ftp.pl.freebsd.org/vol/rzm1/solaris-cd-pm/8/sparc/sol-8-u7-sparc-v1.zip</a> <a href="ftp://ftp.pl.freebsd.org/vol/rzm1/solaris-cd-pm/8/sparc/sol-8-u7-sparc-v2.zip" target="_blank" rel="noopener">ftp://ftp.pl.freebsd.org/vol/rzm1/solaris-cd-pm/8/sparc/sol-8-u7-sparc-v2.zip</a></p><p> 由于2005年左右的时候，DVD还不是很普及，上面的2个文件的形式是为了适合CD-Rom的存储要求。事实上为了安装Solaris，我还在Oracle网站上下载了Solaris 10 的DVD iso安装文件，但最后没有用上，通过Simics 3.0.4 安装没有成功。</p><h3 id="2-2-下载并安装Simics-3-0-4软件"><a href="#2-2-下载并安装Simics-3-0-4软件" class="headerlink" title="2.2 下载并安装Simics 3.0.4软件"></a>2.2 下载并安装Simics 3.0.4软件</h3><p>Simics 软件是一个功能很强大的软件，能在不同的host 操作系统上安装。由于我的电脑时X86架构的Win7 操作系统，所以下载的Simics 安装文件是支持在Win32 系统下安装的。Simics 能够模拟不同的硬件架构，方便测试员们进行各种各样的测试，而不必拥有真实的硬件架构的电脑。</p><p> Simics 不是一个开源的操作系统，使用它需要License文件，这就需要在网络上下载keygen.exe程序来生成License 文件。</p><p>针对Win32系统上安装的Simics 安装文件可以在网络上搜索到，然后下载，安装通常的Windows下程序的安装方式安装即可。类似地，keygen.exe程序也可以从网络上搜索并下载，你可以使用搜索的关键词为Simics 3.0.4 keygen.exe。使用keygen产生License文件时，需输入我的win7系统下当前的登录名，我输入的是Administrator。产生后的License 文件存放在keygen同一个文件夹下。导入License 文件的方法有2中，一是在按照Simics 的过程中指定License文件的位置；二是，安装好Simics 后，在Simics安装目录下\Simics-3.0.4\licenses 放入生成的License文件。只有导入了License文件，你才能正常使用Simics 软件。</p><h2 id="3-在Simics-上安装Solaris-8-SPARC操作系统"><a href="#3-在Simics-上安装Solaris-8-SPARC操作系统" class="headerlink" title="3 在Simics 上安装Solaris 8 SPARC操作系统"></a>3 在Simics 上安装Solaris 8 SPARC操作系统</h2><h3 id="3-1-Simics-安装目录和Simics-workspace-目录"><a href="#3-1-Simics-安装目录和Simics-workspace-目录" class="headerlink" title="3.1 Simics 安装目录和Simics workspace 目录"></a>3.1 Simics 安装目录和Simics workspace 目录</h3><p> Simics 安装目录指的是安装该软件所在的目录，它包含了启动该软件所需要的各种文件。在你使用Simics软件后，它会要求你指定一个Workspace 目录，该目录虽然可以随意指定，我的建议是将该目录设置在空间较大的磁盘上面，因为所有你在Simics 上面安装的虚拟操作系统的硬盘文件都会建立在该目录下面。我把Workspace目录设置为F:\OS\simics\workspace，我的F盘还有80多G的空间。</p><p> 待你指定好Workspace目录后，Simics会自动在该文件夹下建立相关的文件和文件夹，如图1。</p><p>Figure 1: Simics 在Workspace目录下自动建立的内容(摘选)</p><h3 id="3-2-安装Solaris-8"><a href="#3-2-安装Solaris-8" class="headerlink" title="3.2 安装Solaris 8"></a>3.2 安装Solaris 8</h3><p> 步骤如下：</p><ol><li><p>将2个iso文件sol-8-u7-sparc-v1.iso 和sol-8-u7-sparc-v2.iso 放到F:\OS\simics\workspace文件夹下。不用担心，安装时Simics 会自动找到这两个iso文件。</p><ol start="2"><li>修改安装目录\targets \sunfire 下的文件peanut-sol8-cd-install1.simics 和peanut-sol8-cd-install2.simics。</li></ol></li></ol><p>(a) 将第一个文件的32行该为$cdrom path = “sol-8-u7-sparc-v1.iso”。将第二个文件的第6行改为$cdrom path = ”sol-8-u7-sparc-v2.iso”。</p><p>(b) 在这两个文件中都注释掉内容为run-command-file “%script%/../common/solaris8-install.include”的行。注释用井号(sharp)。不注释掉这2行会出现安装错误                 (Assertion failed: have ext net info(nc) == TRUE, file main.c line 931)，该错误是在Serial Console里面显示；注释掉这两行后安装过程中要进行许多手工设置。</p><ol start="3"><li>启动Simics, 选择File菜单下的New Session，选定Workspace目录下\targets\sunfire\peanut-sol8-cd-install1.simics，这时会出现Serial Console ttya 窗口，同时，Simics 本身的界面上也会出现相应的信息提示。ttya窗口中显示Solaris 8 SPARC 操作系统的安装过程和设置，在出现OK 的提示符后，在Console ttya 中输入boot cdrom -v命令，然后，虚拟机从CD-ROM的iso 镜像开始引导，安装过程开始，我所做的相应配置如下：</li></ol><pre><code>     Select a Language: 0 English     Select a Locale : 0 English (C - 7-bit ASCII)     What type of terminal are you using? 我这里选择VT100[我第一次装的时候用的是pc-console结果让输入domain name，在装到第2个盘的时候，出现让输入domain name，比较不妥。]     DHCP: NO     Host name: chgzhi2     IP address: 10.10.0.5     Netmask: 255.255.255.0     Enable IPv6: No     Configure Kerberos Security: No     Name service: None     F2 standard     Select 64 Bit Yes     [X] Entire Distribution plus OEM support 64-bit 1523.00 MB     Auto Reboot     Configuring disk (采用默认配置)</code></pre><p> 接下来就是漫长的等待，大概3个小时左右。不要着急，要有耐心。安装完成后，Console会显示rebooting (换行) Resetting …；同时Simics主窗口会显示Now exit Simics and continue with the peanut-sol8-cd-install2.simics script.</p><ol start="4"><li><p>在Simics 主界面的File菜单里点击Close session，接着New session，选定Workspace目录下\targets\sunfire \peanut-sol8-cd-install2.simics，进行第2个iso镜像文件的安装。在安装过程中会提示你设置root 的密码：</p><p>You will be prompted to type the root password twice; for security, the password will not be displayed on the screen as you type it.</p><blockquote><p>If you do not want a root password, press RETURN twice.</p></blockquote><p>   Root password:</p><p>  Re-enter your root password.</p><p>  Press Return to continue.</p></li></ol><p> 进入同样的漫长的等待过程，大概2个小时左右。我设置的密码为123456。在安装的过程中可能会在Console中出现sendmail[333]: unable to qualify my own domain name (chgzhi2) – using short name 的提示，同时在Simics 的主窗口中出现类似这样[sn0 info] Got UDP packet on port 520 (unknown) with no active service 的提示，遇到这样的提示，直接忽略掉即可，不影响Solaris 8 SPARC 的安装。</p><ol start="5"><li>类似地，Close session，然后New session，选定Workspace目录下\targets\sunfire\peanut-sol8-cd-install3.simics，安装第三个intall文件时，会在Serial Console里进行root登录，你要使用先前你设置的密码登录即可。该安装过程很快就会结束。结束后会提示，Serial Console会出现：Program terminated；而在simics里会出现：Now exit Simics and use the peanut-common.simics script to start the machine. Make sure that the $os variable is set to solaris9.这是一个错误提示，应该为solaris8。实际上这是脚<br>本peanut-sol8-cd-install3.simics 中的错误提示。根据该提示，将Workspace目录下文件\targets\sunfire \peanut-common.simics中的第2行前添加$os = ”solaris8” 即可。</li></ol><h2 id="4-在Simics中启动安装好的Solaris-8"><a href="#4-在Simics中启动安装好的Solaris-8" class="headerlink" title="4 在Simics中启动安装好的Solaris 8"></a>4 在Simics中启动安装好的Solaris 8</h2><p> 启动的方法很简单，通过Simics 主窗口的File 菜单下的New session，选定Workspace目录下文件\targets\sunfire \peanut-common.simics 即可。弹出的Serial Console on ttya 会提示你登录，使用root帐号和你设置的密码登录即可。此时你就可以使用虚拟的Solaris 操作系统了。启动成功后如图2所示。Have a fun.<br> ———————————————<font color="red"><strong>THE END!</strong></font>———————————————————–</p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Solaris </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Socionext芯片SC2000系统架构简介</title>
      <link href="/2020/11/29/%E3%80%90Codecs%E7%B3%BB%E5%88%97%E3%80%91Socionext%E8%8A%AF%E7%89%87SC2000%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E7%AE%80%E4%BB%8B/"/>
      <url>/2020/11/29/%E3%80%90Codecs%E7%B3%BB%E5%88%97%E3%80%91Socionext%E8%8A%AF%E7%89%87SC2000%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E7%AE%80%E4%BB%8B/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><hr><h2 id="1、SC2000芯片datesheet"><a href="#1、SC2000芯片datesheet" class="headerlink" title="1、SC2000芯片datesheet"></a>1、SC2000芯片datesheet</h2><p>SC2000包括4个Cortex-A7，1个Cortex-M0和1个DSP核。</p><p><strong>•    SMP-RTOS＠Cortex-A7 × 3</strong></p><ul><li>Application Control Layer<br>Image processing function such as AE/AWB, individual difference adjustment, additional image processing IP. And also there is system controller for whole of system.<ul><li>Imaging Core Libraries<br>Standard camera function such as Live-view, Still Capture, Video recording, Playback …</li><li>Device Drivers<br>M10V hardware and peripheral device drivers that is assigned to control on RTOS.</li></ul></li></ul><p><strong>•    Linux＠Cortex-A7 × 1</strong></p><ul><li>userland Application Layer<br>System control program, application programs and libraries.</li><li>Middleware<br>Ethernet and Wifi network protocol stack mainly.</li><li>Standard API<br>Standard function on Linux.</li><li>Device Drivers / Socionext HAL<br>M10V hardware and peripheral device drivers, which are mainly used for external connectivity functions assigned to control on Linux.</li></ul><p>•    <strong>RTOS＠Cortex-M0</strong></p><ul><li>Power Management<br>Boot process and power management must be implemented according to customers camera specs.</li><li>Peripheral Drivers<br>M10V hardware and peripheral device drivers, which are mainly necessary to power control, boot-up and etc assigned to control on Cortex-M0.</li></ul><h2 id="2、硬件资源"><a href="#2、硬件资源" class="headerlink" title="2、硬件资源"></a>2、硬件资源</h2><p><img src="https://img-blog.csdnimg.cn/20201029224201336.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NvYXJpbmdMZWVfZmlnaHRpbmc=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><h2 id="3、系统架构"><a href="#3、系统架构" class="headerlink" title="3、系统架构"></a>3、系统架构</h2><p><img src="https://img-blog.csdnimg.cn/20201029224217848.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NvYXJpbmdMZWVfZmlnaHRpbmc=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>———————————————<font color="red"><strong>THE END!</strong></font>———————————————————–</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 编解码 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Codecs </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SecureCRT文件传输模式之Zmodem</title>
      <link href="/2020/10/23/%E3%80%90Tools%E7%B3%BB%E5%88%97%E3%80%91SecureCRT%E6%96%87%E4%BB%B6%E4%BC%A0%E8%BE%93%E6%A8%A1%E5%BC%8F%E4%B9%8BZmodem/"/>
      <url>/2020/10/23/%E3%80%90Tools%E7%B3%BB%E5%88%97%E3%80%91SecureCRT%E6%96%87%E4%BB%B6%E4%BC%A0%E8%BE%93%E6%A8%A1%E5%BC%8F%E4%B9%8BZmodem/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="1、参考"><a href="#1、参考" class="headerlink" title="1、参考"></a>1、参考</h2><p><a href="https://blog.csdn.net/iteye_4389/article/details/82519428" target="_blank" rel="noopener">[Tools] SecureCRT文件传输模式介绍</a></p><h2 id="2、secureCRT文件传输方式"><a href="#2、secureCRT文件传输方式" class="headerlink" title="2、secureCRT文件传输方式"></a>2、secureCRT文件传输方式</h2><p>如下图所示，SecureCRT有5种文件传输模式：<br><img src="https://img-blog.csdnimg.cn/20201023203739149.png#pic_center" alt="在这里插入图片描述"><br>1）ASCII：最快的传输模式，但只能传文本</p><p>2）Binary：只能传二进制文件</p><p>3）Xmodem：非常古老的传输协议速度较慢，但由于使用了CRC错误侦测方法，传输的准确率可高达99.6%。</p><p>4）Ymodem：Xmodem的改良版，速度比它快</p><p>5）Zmodem：Zmodem采用了串流式（streaming）传输方式，传输速度较快，而且还具有自动改变区段大小和断点续传、快速错误侦测等功能。这是目前最流行的文件传输协议。</p><h2 id="3、Zmodem"><a href="#3、Zmodem" class="headerlink" title="3、Zmodem"></a>3、Zmodem</h2><ul><li><p>rz: receive  从服务器下载文件</p></li><li><p>sz: send 上传文件到服务器</p></li></ul><h3 id="3-1、利用Zmodem上传文件至Linux服务器"><a href="#3-1、利用Zmodem上传文件至Linux服务器" class="headerlink" title="3.1、利用Zmodem上传文件至Linux服务器"></a>3.1、利用Zmodem上传文件至Linux服务器</h3><p>首先用SecureCRT登陆到Linux主机，cd到你要上传的目录下，敲rz按回车，就会出现如下所示的对话框：<br><img src="https://img-blog.csdnimg.cn/20201023204940177.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NvYXJpbmdMZWVfZmlnaHRpbmc=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>选择你要添加的文件（可多选），点ADD，再点OK之后就开始上传文件了。</p><p>rz上传文件：</p><pre><code class="m">$ rzrz waiting to receive.Starting zmodem transfer.  Press Ctrl+C to cancel.</code></pre><h3 id="3-2、利用Zmodem下载文件至windows客户端"><a href="#3-2、利用Zmodem下载文件至windows客户端" class="headerlink" title="3.2、利用Zmodem下载文件至windows客户端"></a>3.2、利用Zmodem下载文件至windows客户端</h3><p>和rz相反，sz用来下载文件至windows客户端，命令是：sz filename1 filename2 …<br>sz会把文件下载到默认客户端目录下（由secureCRT option设置）</p><p>sz下载文件：</p><pre><code class="m"># sz --helpsz version 0.12.20Usage: sz [options] file ...   or: sz [options] -{c|i} COMMANDSend file(s) with ZMODEM/YMODEM/XMODEM protocol    (X) = option applies to XMODEM only    (Y) = option applies to YMODEM only    (Z) = option applies to ZMODEM only  -+, --append                append to existing destination file (Z)  -2, --twostop               use 2 stop bits  -4, --try-4k                go up to 4K blocksize      --start-4k              start with 4K blocksize (doesn&#39;t try 8)  -8, --try-8k                go up to 8K blocksize      --start-8k              start with 8K blocksize  -a, --ascii                 ASCII transfer (change CR/LF to LF)  -b, --binary                binary transfer  -B, --bufsize N             buffer N bytes (N==auto: buffer whole file)  -c, --command COMMAND       execute remote command COMMAND (Z)  -C, --command-tries N       try N times to execute a command (Z)  -d, --dot-to-slash          change &#39;.&#39; to &#39;/&#39; in pathnames (Y/Z)      --delay-startup N       sleep N seconds before doing anything  -e, --escape                escape all control characters (Z)  -E, --rename                force receiver to rename files it already has  -f, --full-path             send full pathname (Y/Z)  -i, --immediate-command CMD send remote CMD, return immediately (Z)  -h, --help                  print this usage message  -k, --1k                    send 1024 byte packets (X)  -L, --packetlen N           limit subpacket length to N bytes (Z)  -l, --framelen N            limit frame length to N bytes (l&gt;=L) (Z)  -m, --min-bps N             stop transmission if BPS below N  -M, --min-bps-time N          for at least N seconds (default: 120)  -n, --newer                 send file if source newer (Z)  -N, --newer-or-longer       send file if source newer or longer (Z)  -o, --16-bit-crc            use 16 bit CRC instead of 32 bit CRC (Z)  -O, --disable-timeouts      disable timeout code, wait forever  -p, --protect               protect existing destination file (Z)  -r, --resume                resume interrupted file transfer (Z)  -R, --restricted            restricted, more secure mode  -q, --quiet                 quiet (no progress reports)  -s, --stop-at {HH:MM|+N}    stop transmission at HH:MM or in N seconds      --tcp                   build a TCP connection to transmit files      --tcp-server            open socket, wait for connection  -u, --unlink                unlink file after transmission  -U, --unrestrict            turn off restricted mode (if allowed to)  -v, --verbose               be verbose, provide debugging information  -w, --windowsize N          Window is N bytes (Z)  -X, --xmodem                use XMODEM protocol  -y, --overwrite             overwrite existing files  -Y, --overwrite-or-skip     overwrite existing files, else skip      --ymodem                use YMODEM protocol  -Z, --zmodem                use ZMODEM protocol</code></pre><p>———————————————<font color="red"><strong>THE END!</strong></font>———————————————————–</p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SecureCRT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ARM优化之内联汇编（inline）优化方法</title>
      <link href="/2020/10/01/%E3%80%90%E4%BC%98%E5%8C%96%E7%B3%BB%E5%88%97%E3%80%91ARM%E4%BC%98%E5%8C%96%E4%B9%8B%E5%86%85%E8%81%94%E6%B1%87%E7%BC%96%EF%BC%88inline%EF%BC%89%E4%BC%98%E5%8C%96%E6%96%B9%E6%B3%95/"/>
      <url>/2020/10/01/%E3%80%90%E4%BC%98%E5%8C%96%E7%B3%BB%E5%88%97%E3%80%91ARM%E4%BC%98%E5%8C%96%E4%B9%8B%E5%86%85%E8%81%94%E6%B1%87%E7%BC%96%EF%BC%88inline%EF%BC%89%E4%BC%98%E5%8C%96%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>前面博客里面已经总结了ARM纯汇编优化和Intrinsic优化方法，如下：<br><a href="https://blog.csdn.net/SoaringLee_fighting/article/details/81743505" target="_blank" rel="noopener">【arm】arm架构32位汇编优化总结</a> ,<br><a href="https://blog.csdn.net/SoaringLee_fighting/article/details/82530435" target="_blank" rel="noopener">【arm】arm架构64位（AArch64）汇编优化总结</a><br><a href="https://soaringlee.blog.csdn.net/article/details/108623805" target="_blank" rel="noopener">【优化系列】ARM优化之Intrinsic汇编方法</a></p><p>本文主要讲解ARM内联汇编arm inline的编写方法和注意事项。</p><h2 id="1、系列总结"><a href="#1、系列总结" class="headerlink" title="1、系列总结"></a>1、系列总结</h2><p> <a href="https://blog.csdn.net/SoaringLee_fighting/article/details/99567833" target="_blank" rel="noopener">【ARM系列】ARM NEON汇编优化系列汇总</a></p><h2 id="2、参考"><a href="#2、参考" class="headerlink" title="2、参考"></a>2、参考</h2><p><a href="https://blog.csdn.net/duanlove/article/details/8211166" target="_blank" rel="noopener">ARM GCC的内联汇编详解 （ARM GCC Inline Assembler Cookbook）</a><br><a href="https://blog.csdn.net/hanhannina/article/details/4410741" target="_blank" rel="noopener">ARM GCC 内嵌（inline）汇编手册</a><br><a href="http://www.ethernut.de/en/documents/arm-inline-asm.html" target="_blank" rel="noopener">ARM GCC Inline Assembler Cookbook</a><br><a href="https://www.cnblogs.com/fengliu-/p/7667892.html" target="_blank" rel="noopener">ARM嵌入式开发中的GCC内联汇编<strong>asm</strong></a></p><h2 id="3、ARM内联汇编优化方法"><a href="#3、ARM内联汇编优化方法" class="headerlink" title="3、ARM内联汇编优化方法"></a>3、ARM内联汇编优化方法</h2><p>总体上，ARM内联汇编与x86内联汇编有很多共同之处。<br>对于基于ARM的RISC处理器，GNU C编译器提供了在C代码中内嵌汇编的功能。这种非常酷的特性提供了C代码没有的功能，比如手动优化软件关键部分的代码、使用相关的处理器指令。</p><h3 id="3-1-Gcc-asm声明"><a href="#3-1-Gcc-asm声明" class="headerlink" title="3.1 Gcc asm声明"></a>3.1 Gcc asm声明</h3><pre><code class="asm">asm(&quot;mov r0, r0&quot;)</code></pre><p>通用的内嵌汇编模版是这样的：</p><pre><code class="asm">asm(code : output operand list : input operand list : clobber list);</code></pre><p>汇编和C语句这间的联系是通过上面asm声明中可选的output operand list（输出操作数列表）和input operand list（输入操作数列表）。clobber list表示修饰寄存器列表。</p><h3 id="3-2-优化C代码"><a href="#3-2-优化C代码" class="headerlink" title="3.2 优化C代码"></a>3.2 优化C代码</h3><p>有两种情况决定了你必须使用汇编。1st，C限制了你更加贴近底层操作硬件，比如，C中没有直接修改程序状态寄存器（PSR）的声明。2nd就是要写出更加优化的代码。毫无疑问GNU C代码优化器做的很好，但是他的结果和我们手工写的汇编代码相差很远。</p><p>这一部分有一点很重要，也是被别人忽视最多的就是：我们在C代码中通过内嵌汇编指令添加的汇编代码，也是要被C编译器的优化器处理的。</p><p>对于ARM核的处理器，GCC4 提供了以下的限制：<br><img src="https://img-blog.csdnimg.cn/20201009102145215.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NvYXJpbmdMZWVfZmlnaHRpbmc=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>限制字符可能要单个modifier指示。要是没有modifier指示的默认为read-only operand。<br><img src="https://img-blog.csdnimg.cn/20201009193859151.png#pic_center" alt="在这里插入图片描述"></p><p>Output operands必须为write-only，相应C表达式的值必须是左值。Input operands必须为read-only。C编译器是没有能力做这个检查。</p><p>比较严格的规则是：不要试图向input operand写。但是如果你想要使用相同的operand作为input和output。限制性modifier（+）可以达到效果。</p><h3 id="3-3-应用实例"><a href="#3-3-应用实例" class="headerlink" title="3.3 应用实例"></a>3.3 应用实例</h3><p><strong>1、内联汇编作为预处理宏使用</strong></p><p>要是经常使用部分汇编，最好的方法是将它以宏的形式定义在头文件中。使用该头文件在严格的ANSI模式下会出现警告。为了避免该类问题，可以使用__asm__代替asm，__volatile__代替volatile。这可以等同于别名。下面就是个例程：</p><pre><code class="asm">#define BYTESWAP(val) \    __asm__ __volatile__ ( \        &quot;eor     r3, %1, %1, ror #16\n\t&quot; \        &quot;bic     r3, r3, #0x00FF0000\n\t&quot; \        &quot;mov     %0, %1, ror #8\n\t&quot; \        &quot;eor     %0, %0, r3, lsr #8&quot; \        : &quot;=r&quot; (val) \        : &quot;0&quot;(val) \        : &quot;r3&quot;, &quot;cc&quot; \    );</code></pre><p><strong>2、C语言桩函数</strong></p><p>宏定义包含的是相同的代码。这在大型routine中是不可以接受的。这种情况下最好定义个桩函数。</p><pre><code class="asm">unsigned long ByteSwap(unsigned long val){asm volatile (        &quot;eor     r3, %1, %1, ror #16\n\t&quot;        &quot;bic     r3, r3, #0x00FF0000\n\t&quot;        &quot;mov     %0, %1, ror #8\n\t&quot;        &quot;eor     %0, %0, r3, lsr #8&quot;        : &quot;=r&quot; (val)        : &quot;0&quot;(val)        : &quot;r3&quot;);return val;}</code></pre><p><strong>3、替换C变量的符号名</strong></p><p>默认的情况下，GCC使用同函数或者变量相同的符号名。你可以使用asm声明，为汇编代码指定一个不同的符号名</p><pre><code class="asm">unsigned long value asm(&quot;clock&quot;) = 3686400;</code></pre><p>这个声明告诉编译器使用了符号名clock代替了具体的值。</p><p><strong>4、替换C函数的符号名</strong></p><pre><code class="asm">extern long Calc(void) asm (&quot;CALCULATE&quot;);</code></pre><p><strong>5、强制使用特定的寄存器</strong><br>局部变量可能存储在一个寄存器中。你可以利用内嵌汇编为该变量指定一个特定的寄存器。</p><pre><code class="asm">void Count(void) {register unsigned char counter asm(&quot;r3&quot;);... some code...asm volatile(&quot;eor r3, r3, r3&quot; : &quot;=l&quot; (counter));... more code...}</code></pre><p><strong>6、临时使用寄存器</strong></p><p>如果你使用了寄存器，而你没有在input或output operand传递，那么你就必须向编译器指明这些。下面的例子中使用r3作为scratch 寄存器，通过在clobber list中写r3，来让编译器得知使用该寄存器。由于ands指令跟新了状态寄存器的标志位，使用cc在clobber list中指明。</p><pre><code class="asm">asm volatile(  &quot;ands    r3, %1, #3&quot;     &quot;\n\t&quot;    &quot;eor     %0, %0, r3&quot; &quot;\n\t&quot;    &quot;addne   %0, #4&quot;    : &quot;=r&quot; (len)    : &quot;0&quot; (len)    : &quot;cc&quot;, &quot;r3&quot;  );</code></pre><h3 id="3-4-通用寄存器用法"><a href="#3-4-通用寄存器用法" class="headerlink" title="3.4 通用寄存器用法"></a>3.4 通用寄存器用法</h3><p><img src="https://img-blog.csdnimg.cn/20201009195527433.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NvYXJpbmdMZWVfZmlnaHRpbmc=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>主要参考： <a href="http://www.ethernut.de/en/documents/arm-inline-asm.html" target="_blank" rel="noopener">http://www.ethernut.de/en/documents/arm-inline-asm.html</a></p><p>——————————————————<font color="red"><strong>THE END!</strong></font>——————————————————–</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 优化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ARM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>X86优化之GCC内联汇编</title>
      <link href="/2020/09/18/%E3%80%90%E4%BC%98%E5%8C%96%E7%B3%BB%E5%88%97%E3%80%91X86%E4%BC%98%E5%8C%96%E4%B9%8BGCC%E5%86%85%E8%81%94%E6%B1%87%E7%BC%96/"/>
      <url>/2020/09/18/%E3%80%90%E4%BC%98%E5%8C%96%E7%B3%BB%E5%88%97%E3%80%91X86%E4%BC%98%E5%8C%96%E4%B9%8BGCC%E5%86%85%E8%81%94%E6%B1%87%E7%BC%96/</url>
      
        <content type="html"><![CDATA[<p> [TOC]</p><h2 id="写在前面的话"><a href="#写在前面的话" class="headerlink" title="写在前面的话"></a>写在前面的话</h2><p>&ensp; &ensp;   X86汇编优化主要包括纯汇编、intrinsic汇编和内联汇编。前面已经总结了x86纯汇编优化和X86 Intrinsic优化的相关知识，本文重点讲述Gcc内联汇编的基础知识和用法。</p><h2 id="1、参考"><a href="#1、参考" class="headerlink" title="1、参考"></a>1、参考</h2><p><a href="https://www.linuxprobe.com/gcc-how-to.html" target="_blank" rel="noopener">最牛X的GCC 内联汇编</a><br><a href="https://linux.cn/article-7688-1.html" target="_blank" rel="noopener">GCC 内联汇编 HOWTO </a><br><a href="https://blog.csdn.net/tyhh2001/article/details/44351797" target="_blank" rel="noopener">2.2.1 GNU C内嵌汇编语言</a><br><a href="http://www.ibiblio.org/gferg/ldp/GCC-Inline-Assembly-HOWTO.html" target="_blank" rel="noopener">GCC-Inline-Assembly-HOWTO</a></p><p>下述内容主要参考自：<a href="http://www.ibiblio.org/gferg/ldp/GCC-Inline-Assembly-HOWTO.html" target="_blank" rel="noopener">GCC-Inline-Assembly-HOWTO</a></p><h2 id="2、Gcc内联汇编"><a href="#2、Gcc内联汇编" class="headerlink" title="2、Gcc内联汇编"></a>2、Gcc内联汇编</h2><h3 id="2-1-概览"><a href="#2-1-概览" class="headerlink" title="2.1 概览"></a>2.1 概览</h3><p>在这里，我们将学习 GCC 内联汇编。这里内联表示的是什么呢？<br>我们可以要求编译器将一个函数的代码插入到调用者代码中函数被实际调用的地方。这样的函数就是内联函数。这听起来和宏差不多？这两者确实有相似之处。<br>内联函数的优点是什么呢？<br>这种内联方法可以减少函数调用开销。同时如果所有实参的值为常量，它们的已知值可以在编译期允许简化，因此并非所有的内联函数代码都需要被包含进去。代码大小的影响是不可预测的，这取决于特定的情况。为了声明一个内联函数，我们必须在函数声明中使用 “inline” 关键字。<br>现在我们正处于一个猜测内联汇编到底是什么的点上。它只不过是一些写为内联函数的汇编程序。在系统编程上，它们方便、快速并且极其有用。我们主要集中学习（GCC）内联汇编函数的基本格式和用法。为了声明内联汇编函数，我们使用 “asm” 关键词。<br>内联汇编之所以重要，主要是因为它可以操作并且使其输出通过 C 变量显示出来。正是因为此能力， “asm” 可以用作汇编指令和包含它的 C 程序之间的接口。</p><h3 id="2-2-GCC汇编语法"><a href="#2-2-GCC汇编语法" class="headerlink" title="2.2 GCC汇编语法"></a>2.2 GCC汇编语法</h3><p>Linux上的 GNU C 编译器 GCC ，使用 <strong>AT&amp;T / UNIX</strong> 汇编语法。</p><p>AT&amp;T 语法和 Intel 语法的差别很大。我会给出主要的区别。</p><p><strong>1、源操作数和目的操作数顺序</strong><br>AT&amp;T 语法的操作数方向和 Intel 语法的刚好相反。在Intel 语法中，第一操作数为目的操作数，第二操作数为源操作数，然而在 AT&amp;T 语法中，第一操作数为源操作数，第二操作数为目的操作数。也就是说，<br>Intel 语法中的 “Op-code dst src” 变为 AT&amp;T 语法中的 “Op-code src dst”。</p><p><strong>2、寄存器命名</strong><br>寄存器名称有 “%” 前缀，即如果必须使用 “eax”，它应该用作 “%eax”。</p><p><strong>3、立即数</strong><br>AT&amp;T 立即数以 “$” 为前缀。静态 “C” 变量也使用 “$” 前缀。在 Intel 语法中，十六进制常量以 “h” 为后缀，然而 AT&amp;T 不使用这种语法，这里我们给常量添加前缀 “0x”。所以，对于十六进制，我们首先看到一个 “$”，然后是 “0x”，最后才是常量。</p><p><strong>4、操作数大小</strong><br>在 AT&amp;T 语法中，存储器操作数的大小取决于操作码名字的最后一个字符。操作码后缀 ’b’ 、’w’、’l’ 分别指明了字节（8位）、字（16位）、长型（32位）存储器引用。Intel 语法通过给存储器操作数添加 “byte ptr”、 “word ptr” 和 “dword ptr” 前缀来实现这一功能。<br>因此，Intel的 “mov al, byte ptr foo” 在 AT&amp;T 语法中为 “movb foo, %al”</p><p><strong>5、存储器操作数</strong></p><p>在 Intel 语法中，基址寄存器包含在 “[“ 和 “]” 中，然而在 AT&amp;T 中，它们变为 “(“ 和 “)”。另外，在 Intel 语法中， 间接内存引用为<br>“section:[base + index*scale + disp]”，在 AT&amp;T中变为 “section:disp(base, index, scale)”。<br>需要牢记的一点是，当一个常量用于 disp 或 scale，不能添加 “$” 前缀。<br>现在我们看到了 Intel 语法和 AT&amp;T 语法之间的一些主要差别。我仅仅写了它们差别的一部分而已。关于更完整的信息，请参考 GNU 汇编文档。现在为了更好地理解，我们可以看一些示例。</p><pre><code class="asm">+------------------------------+------------------------------------+|       Intel Code             |      AT&amp;T Code                     |+------------------------------+------------------------------------+| mov     eax,1                |  movl    $1,%eax                   |   | mov     ebx,0ffh             |  movl    $0xff,%ebx                |   | int     80h                  |  int     $0x80                     |   | mov     ebx, eax             |  movl    %eax, %ebx                || mov     eax,[ecx]            |  movl    (%ecx),%eax               || mov     eax,[ebx+3]          |  movl    3(%ebx),%eax              || mov     eax,[ebx+20h]        |  movl    0x20(%ebx),%eax           || add     eax,[ebx+ecx*2h]     |  addl    (%ebx,%ecx,0x2),%eax      || lea     eax,[ebx+ecx]        |  leal    (%ebx,%ecx),%eax          || sub     eax,[ebx+ecx*4h-20h] |  subl    -0x20(%ebx,%ecx,0x4),%eax |+------------------------------+-------------------------------------</code></pre><h3 id="2-3-基本内联"><a href="#2-3-基本内联" class="headerlink" title="2.3 基本内联"></a>2.3 基本内联</h3><p>基本内联汇编的格式非常直接了当。它的基本格式为：</p><pre><code class="asm">asm(&quot;汇编代码&quot;);</code></pre><p>例如：</p><pre><code>__asm__ (&quot;movl %eax, %ebx/n/t&quot;         &quot;movl $56, %esi/n/t&quot;         &quot;movl %ecx, $label(%edx,%ebx,$4)/n/t&quot;         &quot;movb %ah, (%ebx)&quot;);</code></pre><p>你可能注意到了这里我使用了 “asm” 和 “<strong>asm</strong>“。这两者都是有效的。如果关键词 “asm” 和我们程序的一些标识符冲突了，我们可以使用 “<strong>asm</strong>“。如果我们的指令多于一条，我们可以每个一行，并用双引号圈起，同时为每条指令添加 ’/n’ 和 ’/t’ 后缀。这是因为 gcc 将每一条当作字符串发送给as（GAS）（LCTT 译注： GAS 即 GNU 汇编器），并且通过使用换行符/制表符发送正确格式化后的行给汇编器。</p><h3 id="2-4-扩展汇编"><a href="#2-4-扩展汇编" class="headerlink" title="2.4 扩展汇编"></a>2.4 扩展汇编</h3><p>在基本内联汇编中，我们只有指令。然而在扩展汇编中，我们可以同时指定操作数。它允许我们指定输入寄存器、输出寄存器以及修饰寄存器列表。GCC 不强制用户必须指定使用的寄存器。我们可以把头疼的事留给 GCC ，这可能可以更好地适应 GCC 的优化。不管怎么说，基本格式为：</p><pre><code class="asm">asm ( 汇编程序模板: 输出操作数 /* 可选的 */: 输入操作数 /* 可选的 */: 修饰寄存器列表 /* 可选的 */);</code></pre><p>汇编程序模板由汇编指令组成。每一个操作数由一个操作数约束字符串所描述，其后紧接一个括弧括起的 C 表达式。冒号用于将汇编程序模板和第一个输出操作数分开，另一个（冒号）用于将最后一个输出操作数和第一个输入操作数分开（如果存在的话）。逗号用于分离每一个组内的操作数。总操作数的数目限制在 10 个，或者机器描述中的任何指令格式中的最大操作数数目，以较大者为准。</p><p>举例：</p><pre><code class="asm">int a=10, b;asm (&quot;movl %1, %%eax;      movl %%eax, %0;&quot;     :&quot;=r&quot;(b)        /* 输出 */     :&quot;r&quot;(a)         /* 输入 */     :&quot;%eax&quot;         /* 修饰寄存器 */     );   </code></pre><p>这里我们所做的是使用汇编指令使 ’b’ 变量的值等于 ’a’ 变量的值。一些有意思的地方是：</p><ul><li>“b” 为输出操作数，用 %0 引用，并且 “a” 为输入操作数，用 %1 引用。</li><li>“r” 为操作数约束。之后我们会更详细地了解约束（字符串）。目前，”r” 告诉 GCC 可以使用任一寄存器存储操作数。输出操作数约束应该有一个约束修饰符 “=” 。这修饰符表明它是一个只读的输出操作数。</li><li>寄存器名字以两个 % 为前缀。这有利于 GCC 区分操作数和寄存器。操作数以一个 % 为前缀。</li><li>第三个冒号之后的修饰寄存器 %eax 用于告诉 GCC %eax 的值将会在 “asm” 内部被修改，所以 GCC 将不会使用此寄存器存储任何其他值。</li></ul><h3 id="2-5-内联汇编模块"><a href="#2-5-内联汇编模块" class="headerlink" title="2.5 内联汇编模块"></a>2.5 内联汇编模块</h3><p><strong>1、汇编程序模板</strong></p><p> 汇编程序模板包含了被插入到 C 程序的汇编指令集。其格式为：每条指令用双引号圈起，或者整个指令组用双引号圈起。同时每条指令应以分界符结尾。有效的分界符有换行符（”/n”）和分号（”;”）。”/n” 可以紧随一个制表符（”/t”）。我们应该都明白使用换行符或制表符的原因了吧（LCTT 译注：就是为了排版和分隔）？和 C 表达式对应的操作数使用 %0、%1 … 等等表示。</p><p><strong>2、操作数</strong></p><p>C 表达式用作 “asm” 内的汇编指令操作数。每个操作数前面是以双引号圈起的操作数约束。对于输出操作数，在引号内还有一个约束修饰符，其后紧随一个用于表示操作数的 C 表达式。即，“操作数约束”（C 表达式）是一个通用格式。对于输出操作数，还有一个额外的修饰符。约束字符串主要用于决定操作数的寻址方式，同时也用于指定使用的寄存器。</p><ul><li>如果我们使用的操作数多于一个，那么每一个操作数用逗号隔开。</li><li>在汇编程序模板中，每个操作数用数字引用。编号方式如下。如果总共有 n 个操作数（包括输入和输出操作数），那么第一个输出操作数编号为 0 ，逐项递增，并且最后一个输入操作数编号为 n - 1 。操作数的最大数目在前一节我们讲过。</li><li>输出操作数表达式必须为左值。输入操作数的要求不像这样严格。它们可以为表达式。扩展汇编特性常常用于编译器所不知道的机器指令 。如果输出表达式无法直接寻址（即，它是一个位域），我们的约束字符串必须给定一个寄存器。在这种情况下，GCC 将会使用该寄存器作为汇编的输出，然后存储该寄存器的内容到输出。</li><li>正如前面所陈述的一样，普通的输出操作数必须为只写的； GCC 将会假设指令前的操作数值是死的，并且不需要被（提前）生成。扩展汇编也支持输入-输出或者读-写操作数。</li></ul><p>所以现在我们来关注一些示例。我们想要求一个数的5次方结果。为了计算该值，我们使用 “lea” 指令。</p><pre><code class="asm">asm (&quot;leal (%1,%1,4), %0&quot;     : &quot;=r&quot; (five_times_x)     : &quot;r&quot; (x)     );</code></pre><p><strong>3、修饰寄存器列表</strong></p><p>一些指令会破坏一些硬件寄存器内容。我们不得不在修饰寄存器中列出这些寄存器，即汇编函数内第三个 ’:’ 之后的域。这可以通知 gcc 我们将会自己使用和修改这些寄存器，这样 gcc 就不会假设存入这些寄存器的值是有效的。我们不用在这个列表里列出输入、输出寄存器。因为 gcc 知道 “asm” 使用了它们（因为它们被显式地指定为约束了）。如果指令隐式或显式地使用了任何其他寄存器，（并且寄存器没有出现在输出或者输出约束列表里），那么就需要在修饰寄存器列表中指定这些寄存器。<br>如果我们的指令可以修改条件码寄存器（cc），我们必须将 “cc” 添加进修饰寄存器列表。<br>如果我们的指令以不可预测的方式修改了内存，那么需要将 “memory” 添加进修饰寄存器列表。这可以使 GCC 不会在汇编指令间保持缓存于寄存器的内存值。如果被影响的内存不在汇编的输入或输出列表中，我们也必须添加 “volatile” 关键词。</p><p><strong>4、Volatile</strong></p><p>如果你熟悉内核源码或者类似漂亮的代码，你一定见过许多声明为 “volatile” 或者 “_<em>volatile_</em>“的函数，其跟着一个 “asm” 或者 “_<em>asm_</em>“。我之前提到过关键词 “asm” 和 “_<em>asm_</em>“。那么什么是 “volatile” 呢？<br>如果我们的汇编语句必须在我们放置它的地方执行（例如，不能为了优化而被移出循环语句），将关键词 “volatile” 放置在 asm 后面、()的前面。以防止它被移动、删除或者其他操作，我们将其声明为 “asm volatile ( … : … : … : …);”<br>如果担心发生冲突，请使用 “_<em>volatile_</em>“。<br>如果我们的汇编只是用于一些计算并且没有任何副作用，不使用 “volatile” 关键词会更好。不使用 “volatile” 可以帮助 gcc 优化代码并使代码更漂亮。</p><h3 id="2-6-更多关于约束"><a href="#2-6-更多关于约束" class="headerlink" title="2.6. 更多关于约束"></a>2.6. 更多关于约束</h3><p>到这个时候，你可能已经了解到约束和内联汇编有很大的关联。但我们对约束讲的还不多。约束用于表明一个操作数是否可以位于寄存器和位于哪种寄存器；操作数是否可以为一个内存引用和哪种地址；操作数是否可以为一个立即数和它可能的取值范围（即值的范围），等等。</p><h4 id="2-6-1-常用约束"><a href="#2-6-1-常用约束" class="headerlink" title="2.6.1 常用约束"></a>2.6.1 常用约束</h4><ol><li>寄存器操作数约束<br>当使用这种约束指定操作数时，它们存储在通用寄存器（GPR）中。请看下面示例：<pre><code class="asm">asm (&quot;movl %%eax, %0/n&quot; :&quot;=r&quot;(myval));</code></pre>这里，变量 myval 保存在寄存器中，寄存器 eax 的值被复制到该寄存器中，并且 myval 的值从寄存器更新到了内存。当指定 “r” 约束时， gcc 可以将变量保存在任何可用的 GPR 中。要指定寄存器，你必须使用特定寄存器约束直接地指定寄存器的名字。它们为：</li></ol><pre><code class="asm">+---+--------------------+| r |    Register(s)     |+---+--------------------+| a |   %eax, %ax, %al   || b |   %ebx, %bx, %bl   || c |   %ecx, %cx, %cl   || d |   %edx, %dx, %dl   || S |   %esi, %si        || D |   %edi, %di        |+---+--------------------+</code></pre><ol start="2"><li>内存操作数约束<br>当操作数位于内存时，任何对它们的操作将直接发生在内存位置，这与寄存器约束相反，后者首先将值存储在要修改的寄存器中，然后将它写回到内存位置。但寄存器约束通常用于一个指令必须使用它们或者它们可以大大提高处理速度的地方。当需要在 “asm” 内更新一个 C 变量，而又不想使用寄存器去保存它的值，使用内存最为有效。例如，IDTR 寄存器的值存储于内存位置 loc 处：</li></ol><pre><code class="asm">asm(&quot;sidt %0/n&quot; : :&quot;m&quot;(loc));</code></pre><ol start="3"><li>匹配（数字）约束<br>在某些情况下，一个变量可能既充当输入操作数，也充当输出操作数。可以通过使用匹配约束在 “asm” 中指定这种情况。<pre><code class="asm">asm (&quot;incl %0&quot; :&quot;=a&quot;(var):&quot;0&quot;(var));</code></pre>在操作数那一节中，我们也看到了一些类似的示例。在这个匹配约束的示例中，寄存器 “%eax” 既用作输入变量，也用作输出变量。 var 输入被读进 %eax，并且等递增后更新的 %eax 再次被存储进 var。这里的 “0” 用于指定与第 0 个输出变量相同的约束。</li></ol><p>其他一些约束：</p><pre><code>&quot;m&quot; : 允许一个内存操作数，可以使用机器普遍支持的任一种地址。&quot;o&quot; : 允许一个内存操作数，但只有当地址是可偏移的。即，该地址加上一个小的偏移量可以得到一个有效地址。&quot;V&quot; : 一个不允许偏移的内存操作数。换言之，任何适合 &quot;m&quot; 约束而不适合 &quot;o&quot; 约束的操作数。&quot;i&quot; : 允许一个（带有常量）的立即整形操作数。这包括其值仅在汇编时期知道的符号常量。&quot;n&quot; : 允许一个带有已知数字的立即整形操作数。许多系统不支持汇编时期的常量，因为操作数少于一个字宽。对于此种操作数，约束应该使用 &#39;n&#39; 而不是&#39;i&#39;。&quot;g&quot; : 允许任一寄存器、内存或者立即整形操作数，不包括通用寄存器之外的寄存器。</code></pre><h4 id="2-6-2-约束修饰符"><a href="#2-6-2-约束修饰符" class="headerlink" title="2.6.2 约束修饰符"></a>2.6.2 约束修饰符</h4><p>当使用约束时，对于更精确的控制超过了对约束作用的需求，GCC 给我们提供了约束修饰符。最常用的约束修饰符为：</p><ul><li>“=” : 意味着对于这条指令，操作数为只写的；旧值会被忽略并被输出数据所替换。</li><li>“&amp;” : 意味着这个操作数为一个早期改动的操作数，其在该指令完成前通过使用输入操作数被修改了。因此，这个操作数不可以位于一个被用作输出操作数或任何内存地址部分的寄存器。如果在旧值被写入之前它仅用作输入而已，一个输入操作数可以为一个早期改动操作数。</li></ul><h2 id="3、一些实用诀窍"><a href="#3、一些实用诀窍" class="headerlink" title="3、一些实用诀窍"></a>3、一些实用诀窍</h2><p>我们可以在 Linux 内核代码里看到许多汇编函数。（usr/src/linux/include/asm/*.h）。</p><p>1、首先我们从一个简单的例子入手。我们将写一个两个数相加的程序。</p><pre><code class="c">int main(void){        int foo = 10, bar = 15;        __asm__ __volatile__(&quot;addl  %%ebx,%%eax&quot;                             :&quot;=a&quot;(foo)                             :&quot;a&quot;(foo), &quot;b&quot;(bar)                             );        printf(&quot;foo+bar=%d/n&quot;, foo);        return 0;}</code></pre><p>这里我们要求 GCC 将 foo 存放于 %eax，将 bar 存放于 %ebx，同时我们也想要在 %eax 中存放结果。’=’ 符号表示它是一个输出寄存器。现在我们可以以其他方式将一个整数加到一个变量。</p><p>2、现在我们看看一些更为复杂而有用的函数。字符串拷贝。</p><pre><code class="c">static inline char * strcpy(char * dest,const char *src){int d0, d1, d2;__asm__ __volatile__(  &quot;1:/tlodsb/n/t&quot;                       &quot;stosb/n/t&quot;                       &quot;testb %%al,%%al/n/t&quot;                       &quot;jne 1b&quot;                     : &quot;=&amp;S&quot; (d0), &quot;=&amp;D&quot; (d1), &quot;=&amp;a&quot; (d2)                     : &quot;0&quot; (src),&quot;1&quot; (dest)                     : &quot;memory&quot;);return dest;}</code></pre><p>源地址存放于 esi，目标地址存放于 edi，同时开始拷贝，当我们到达 0 时，拷贝完成。约束 “&amp;S”、”&amp;D”、”&amp;a” 表明寄存器 esi、edi 和 eax 早期修饰寄存器，也就是说，它们的内容在函数完成前会被改变。这里很明显可以知道为什么 “memory” 会放在修饰寄存器列表。</p><p>3、在 Linux 中，系统调用使用 GCC 内联汇编实现。让我们看看如何实现一个系统调用。所有的系统调用被写成宏（linux/unistd.h）。</p><pre><code class="asm">{        asm(&quot;movl $1,%%eax;         /* SYS_exit is 1 */             xorl %%ebx,%%ebx;      /* Argument is in ebx, it is 0 */             int  $0x80&quot;            /* Enter kernel mode */            );}</code></pre><p>Exit 的系统调用号是 1，同时它的参数是 0。因此我们分配 eax 包含 1，ebx 包含 0，同时通过 “int $0x80” 执行 “exit(0)”。这就是 exit 的工作原理。</p><p>参考网址：<br> <a href="https://www.linuxprobe.com/gcc-how-to.html" target="_blank" rel="noopener">https://www.linuxprobe.com/gcc-how-to.html</a><br><a href="http://www.delorie.com/djgpp/doc/brennan/brennan_att_inline_djgpp.html" target="_blank" rel="noopener">Brennan’s Guide to Inline Assembly</a><br><a href="http://www.linuxassembly.org/articles/linasm.html" target="_blank" rel="noopener">Using Assembly Language in Linux.</a></p><p>———————————–<font color="red"><strong>THE END!</strong></font>——————————</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 优化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> X86 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>x86内联汇编demo</title>
      <link href="/2020/09/18/%E3%80%90%E4%BC%98%E5%8C%96%E7%B3%BB%E5%88%97%E3%80%91x86%E5%86%85%E8%81%94%E6%B1%87%E7%BC%96demo/"/>
      <url>/2020/09/18/%E3%80%90%E4%BC%98%E5%8C%96%E7%B3%BB%E5%88%97%E3%80%91x86%E5%86%85%E8%81%94%E6%B1%87%E7%BC%96demo/</url>
      
        <content type="html"><![CDATA[<p> [TOC]</p><h2 id="1、参考"><a href="#1、参考" class="headerlink" title="1、参考"></a>1、参考</h2><p><a href="https://blog.csdn.net/zhangyifei216/article/details/49788863" target="_blank" rel="noopener">内联汇编基础学习</a><br><a href="https://blog.csdn.net/qq_29343201/article/details/52199533" target="_blank" rel="noopener">GNU C 内联汇编介绍</a><br><a href="https://www.cnblogs.com/rain-blog/p/gnu-gcc-insert-asm.html" target="_blank" rel="noopener">gnu-gcc-insert-asm</a></p><h2 id="2、x86内联汇编基础知识"><a href="#2、x86内联汇编基础知识" class="headerlink" title="2、x86内联汇编基础知识"></a>2、x86内联汇编基础知识</h2><p><a href="https://soaringlee.blog.csdn.net/article/details/85417848" target="_blank" rel="noopener">【优化系列】X86优化之GCC 内联汇编</a></p><h2 id="3、x86内联汇编demo"><a href="#3、x86内联汇编demo" class="headerlink" title="3、x86内联汇编demo"></a>3、x86内联汇编demo</h2><p>在C代码中内嵌汇编代码的方法，举例如下：</p><h3 id="3-1、加法操作"><a href="#3-1、加法操作" class="headerlink" title="3.1、加法操作"></a>3.1、加法操作</h3><p>Intel格式（Windows）：</p><pre><code class="c">#include &lt;stdio.h&gt;int main(int argc, char *argv[]){    int x = 3, y = 4;    __asm    {      mov eax, x      mov ebx, y      add ebx, eax      mov y, ebx    };    printf(&quot;x + y = %d\n&quot;, y);    return 0;}</code></pre><p>AT&amp;T格式（Linux/Unix）：</p><pre><code class="c">#include &lt;stdio.h&gt;int main(int argc, char *argv[]){    int x = 3, y = 4;    __asm__(&quot;addl %%ebx, %%eax&quot;        : &quot;=a&quot; (y)        : &quot;b&quot; (x), &quot;a&quot; (y));    printf(&quot;x + y = %d\n&quot;, y);    return 0;}</code></pre><h3 id="3-2、梯度计算"><a href="#3-2、梯度计算" class="headerlink" title="3.2、梯度计算"></a>3.2、梯度计算</h3><p>Intel格式（Windows）:</p><pre><code class="c">// x86 inline(Intel syntax)int scm_generateGradientImage_inline(unsigned char *Src, unsigned char *Dst,                            int Width, int Height, int Stride){    unsigned int gradX = 0;    unsigned int gradY = 0;    unsigned char * dstImage = NULL;    unsigned char *Src_in = NULL;    unsigned char *Dst_in = NULL;    unsigned char *Src_in_disp = NULL;    unsigned char *Dst_in_disp = NULL;    // 1. 求取梯度图像    memset(Dst, 0, Width * sizeof(unsigned int)); // 第一行都为0    for ( int y = 1; y &lt; Height; y += 4 )    {        Src_in = Src + y * Stride;        Dst_in = Dst + y * Width;        for ( int x = 0; x &lt; Width; x += 8 )    //注意x从0开始，从1开始存在越界风险        {            Src_in_disp = Src_in + x;            Dst_in_disp = Dst_in + x;            __asm              {                mov        eax, Src_in_disp                sub        eax, Stride                movq    xmm0, mmword ptr [eax]                    // 上一行8个像素点                add        eax, Stride                movq    xmm1, mmword ptr [eax]                    // 第一行                add        eax, Stride                movq    xmm2, mmword ptr [eax]                    // 第二行                add        eax, Stride                movq    xmm3, mmword ptr [eax]                    // 第三行                add        eax, Stride                movq    xmm4, mmword ptr [eax]                    // 第四行                mov        eax, Src_in_disp                sub        eax, 1                movq    xmm5, mmword ptr [eax]                    // 左移一个像素第一行                add        eax, Stride                movq    xmm6, mmword ptr [eax]                    // 左移一个像素第二行                pxor    xmm7, xmm7                punpcklbw xmm0, xmm7                // 第一行                punpcklbw xmm5, xmm7                punpcklbw xmm1, xmm7                psubw      xmm5, xmm1        //gradX                psubw      xmm0, xmm1        //gradY                pabsw      xmm5, xmm5                pabsw      xmm0, xmm0                paddw      xmm0, xmm5                psraw      xmm0, 1                packuswb  xmm0, xmm0                // 第二行                punpcklbw xmm6, xmm7                punpcklbw xmm2, xmm7                psubw      xmm6, xmm2        //gradX                psubw      xmm1, xmm2        //gradY                pabsw      xmm6, xmm6                pabsw      xmm1, xmm1                paddw      xmm1, xmm6                psraw      xmm1, 1                packuswb  xmm1, xmm1                add        eax, Stride                movq    xmm5, mmword ptr [eax]                add        eax, Stride                movq    xmm6, mmword ptr [eax]                // 第三行                punpcklbw xmm5, xmm7                punpcklbw xmm3, xmm7                psubw      xmm5, xmm3        //gradX                psubw      xmm2, xmm3        //gradY                pabsw      xmm5, xmm5                pabsw      xmm2, xmm2                paddw      xmm2, xmm5                psraw      xmm2, 1                packuswb  xmm2, xmm2                // 第四行                punpcklbw xmm6, xmm7                punpcklbw xmm4, xmm7                psubw      xmm6, xmm4        //gradX                psubw      xmm3, xmm4        //gradY                pabsw      xmm6, xmm6                pabsw      xmm3, xmm3                paddw      xmm3, xmm6                psraw      xmm3, 1                packuswb  xmm3, xmm3                // 存储                mov        ebx, Dst_in_disp                movq    mmword ptr [ebx], xmm0                add        ebx, Width                movq    mmword ptr [ebx], xmm1                add        ebx, Width                movq    mmword ptr [ebx], xmm2                add        ebx, Width                movq    mmword ptr [ebx], xmm3              }        }        // 第一列为0        Dst_in[0] = 0;        Dst_in[Width] = 0;        Dst_in[2 * Width] = 0;        Dst_in[3 * Width] = 0;    }    return 0;}</code></pre><p>AT&amp;T格式（Linux/Unix）：</p><pre><code class="c">#include &quot;mmx.h&quot;// x86 inline AT&amp;T syntaxint scm_generateGradientImage_inline(unsigned char *Src, unsigned char *Dst,                            int Width, int Height, int Stride){    unsigned char *Src_in = NULL;    unsigned char *Dst_in = NULL;    unsigned char *Src_in_disp = NULL;    unsigned char *Dst_in_disp = NULL;    memset(Dst, 0, Width * sizeof(unsigned int)); // 第一行都为0    for ( int y = 1; y &lt; Height; y += 4 )    {        Src_in = Src + y * Stride;        Dst_in = Dst + y * Width;        for ( int x = 0; x &lt; Width; x += 8 )    //注意x从0开始，从1开始存在越界风险        {            Src_in_disp = Src_in + x;            Dst_in_disp = Dst_in + x;            movq_m2r(*(Src_in_disp-Stride), xmm0);            movq_m2r(*(Src_in_disp), xmm1);            movq_m2r(*(Src_in_disp+Stride), xmm2);            movq_m2r(*(Src_in_disp+2*Stride), xmm3);            movq_m2r(*(Src_in_disp+3*Stride), xmm4);            // 左移一个像素点, 前两行            movq_m2r(*(Src_in_disp-1), xmm5);            movq_m2r(*(Src_in_disp+Stride-1), xmm6);            pxor_r2r(xmm7, xmm7);            punpcklbw_r2r(xmm7, xmm0);            // 第一行            punpcklbw_r2r(xmm7,xmm5);            punpcklbw_r2r(xmm7, xmm1);            psubw_r2r(xmm1, xmm5);            psubw_r2r(xmm1, xmm0);            pabsw_r2r(xmm5, xmm5);            pabsw_r2r(xmm0, xmm0);            paddw_r2r(xmm5, xmm0);            psraw_i2r(1, xmm0);            packuswb_r2r(xmm0, xmm0);            // 第二行            punpcklbw_r2r(xmm7,xmm6);            punpcklbw_r2r(xmm7, xmm2);            psubw_r2r(xmm2, xmm6);            psubw_r2r(xmm2, xmm1);            pabsw_r2r(xmm6, xmm6);            pabsw_r2r(xmm1, xmm1);            paddw_r2r(xmm6, xmm1);            psraw_i2r(1, xmm1);            packuswb_r2r(xmm1, xmm1);            // 左移一个像素点, 后两行            movq_m2r(*(Src_in_disp+2*Stride-1), xmm5);            movq_m2r(*(Src_in_disp+3*Stride-1), xmm6);            // 第三行            punpcklbw_r2r(xmm7,xmm5);            punpcklbw_r2r(xmm7, xmm3);            psubw_r2r(xmm3, xmm5);            psubw_r2r(xmm3, xmm2);            pabsw_r2r(xmm5, xmm5);            pabsw_r2r(xmm2, xmm2);            paddw_r2r(xmm5, xmm2);            psraw_i2r(1, xmm2);            packuswb_r2r(xmm2, xmm2);            // 第四行            punpcklbw_r2r(xmm7,xmm6);            punpcklbw_r2r(xmm7, xmm4);            psubw_r2r(xmm4, xmm6);            psubw_r2r(xmm4, xmm3);            pabsw_r2r(xmm6, xmm6);            pabsw_r2r(xmm3, xmm3);            paddw_r2r(xmm6, xmm3);            psraw_i2r(1, xmm3);            packuswb_r2r(xmm3, xmm3);            // 存储            movq_r2m(xmm0,*(Dst_in_disp));            movq_r2m(xmm1,*(Dst_in_disp+Width));            movq_r2m(xmm2,*(Dst_in_disp+2*Width));            movq_r2m(xmm3,*(Dst_in_disp+3*Width));        }        // 第一列为0        Dst_in[0 * Width] = 0;        Dst_in[1 * Width] = 0;        Dst_in[2 * Width] = 0;        Dst_in[3 * Width] = 0;    }    return 0;}</code></pre><p>注意：该份代码中movq_r2m等宏的定义在头文件mmx.h中。本文暂未提供。</p><p>———————————–<font color="red"><strong>THE END!</strong></font>——————————</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 优化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> X86 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ARM架构优化之Intrinsic汇编方法</title>
      <link href="/2020/09/16/%E3%80%90%E4%BC%98%E5%8C%96%E7%B3%BB%E5%88%97%E3%80%91ARM%E4%BC%98%E5%8C%96%E4%B9%8BIntrinsic%E6%B1%87%E7%BC%96%E6%96%B9%E6%B3%95/"/>
      <url>/2020/09/16/%E3%80%90%E4%BC%98%E5%8C%96%E7%B3%BB%E5%88%97%E3%80%91ARM%E4%BC%98%E5%8C%96%E4%B9%8BIntrinsic%E6%B1%87%E7%BC%96%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="1、参考"><a href="#1、参考" class="headerlink" title="1、参考"></a>1、参考</h2><p><a href="https://blog.csdn.net/SoaringLee_fighting/article/details/82811833" target="_blank" rel="noopener">【arm】arm neon intrinsic方式编写arm32位汇编</a><br><a href="https://blog.csdn.net/yutianzuijin/article/details/79944292" target="_blank" rel="noopener">利用ARM NEON intrinsic优化常用数学运算</a><br><a href="https://www.cnblogs.com/TaigaCon/p/7455443.html" target="_blank" rel="noopener">汇编效率优化：指令处理机制</a><br><a href="https://developer.arm.com/documentation/dht0002/a/Introducing-NEON" target="_blank" rel="noopener">Introducing-NEON</a></p><h2 id="2、前言"><a href="#2、前言" class="headerlink" title="2、前言"></a>2、前言</h2><p>&ensp; &ensp;&ensp; 在ARM汇编优化中，除了ARM纯汇编assembly优化，还有arm Intrinsic优化和arm inline内联优化。前面已经讲述了ARM纯汇编优化方法：<a href="https://blog.csdn.net/SoaringLee_fighting/article/details/81743505" target="_blank" rel="noopener">【arm】arm架构32位汇编优化总结</a>和<a href="https://blog.csdn.net/SoaringLee_fighting/article/details/82530435" target="_blank" rel="noopener">【arm】arm架构64位（AArch64）汇编优化总结</a>，本文重点讲解ARM Intrinsic汇编优化方法，以及如何编写ARM Intrinsic汇编代码。</p><h2 id="3、入门知识"><a href="#3、入门知识" class="headerlink" title="3、入门知识"></a>3、入门知识</h2><p>参考：<a href="https://blog.csdn.net/sunty2016/article/details/79857825" target="_blank" rel="noopener">ARM汇编笔记（3）——NEON intrinsics 函数</a></p><p>Neon Intrinsics采用函数调用的方式替代了汇编指令，与纯汇编最大的区别是开发者只需要关注算法和调用函数就可以了，不需要关注寄存器的分配以及堆栈的管理，这些都是由编译器完成。</p><h2 id="4、arm-intrinsic头及编译方法"><a href="#4、arm-intrinsic头及编译方法" class="headerlink" title="4、arm intrinsic头及编译方法"></a>4、arm intrinsic头及编译方法</h2><p>参考：<a href="https://developer.arm.com/documentation/dht0002/a/Introducing-NEON/Developing-for-NEON/Intrinsics" target="_blank" rel="noopener">https://developer.arm.com/documentation/dht0002/a/Introducing-NEON/Developing-for-NEON/Intrinsics</a></p><p>为了支持NEON intrinsic，需要包含下面头文件:</p><pre><code class="c">#include &lt;arm_neon.h&gt;</code></pre><p><strong>示例：</strong></p><pre><code class="c">#include &lt;arm_neon.h&gt;uint32x4_t double_elements(uint32x4_t input){    return(vaddq_u32(input, input));}</code></pre><p><strong>编译方法：</strong><br>采用GCC编译，对于ARM32位在编译选项中需要指定<code>-mfpu=neon</code>。</p><p>编译命令行：</p><pre><code>arm-none-linux-gnueabi-gcc -mfpu=neon intrinsic.c</code></pre><p>Depending on your toolchain, you might also have to add -mfloat-abi=softfp to indicate to the compiler that NEON variables must be passed in general purpose registers.</p><h2 id="5、arm-intrinsic数据类型及函数介绍"><a href="#5、arm-intrinsic数据类型及函数介绍" class="headerlink" title="5、arm intrinsic数据类型及函数介绍"></a>5、arm intrinsic数据类型及函数介绍</h2><p>参考：<a href="http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.dui0472j/chr1360928373893.html" target="_blank" rel="noopener">http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.dui0472j/chr1360928373893.html</a></p><h3 id="5-1-数据类型"><a href="#5-1-数据类型" class="headerlink" title="5.1 数据类型"></a>5.1 数据类型</h3><pre><code>&lt;基本类型&gt;x&lt;lane个数&gt;x&lt;向量个数&gt;_t，向量个数如果省略表示只有一个。如int8x8_t，uint8x8x3_t。</code></pre><ul><li>基本类型: int8，int16，int32，int64，uint8，uint16，uint32，uint64，float16，float32</li><li>lane个数表示并行处理的基本类型数据的个数。</li><li>对于多个向量的类型实际上是结构体：<pre><code class="c">typedef struct {uint8x8_t val[3];} uint8x8x3_t</code></pre></li></ul><h3 id="5-2-intrinsic函数"><a href="#5-2-intrinsic函数" class="headerlink" title="5.2 intrinsic函数"></a>5.2 intrinsic函数</h3><p>Intrinsic functions and data types, or intrinsics, provide similar functionality to inline assembly, and provide additional features like type checking and automatic register allocation. An intrinsic function appears as a function call in C or C++, but is replaced during compilation by a sequence of low-level instructions. This means you can express low-level architectural behavior in a high-level language.</p><p>函数命名：</p><pre><code>&lt;指令名&gt;[后缀]_&lt;数据基本类型简写&gt;  </code></pre><ul><li>其中后缀如果没有，表示64位并行；如果后缀是q，表示128位并行。</li><li>如果后缀是l，表示长指令，输出数据的基本类型位数是输入的2倍；如果后缀是n，表示窄指令，输出数据的基本类型位数是输入的一半。</li><li>数据基本类型简写：s8，s16，s32，s64，u8，u16，u32，u64，f16，f32</li></ul><p>例如：<br>vadd_u16：两个uint16x4相加为一个uint16x4<br>vaddq_u16：两个uint16x8相加为一个uint16x8<br>vaddl_u16：两个uint8x8相加为一个uint16x8</p><h3 id="5-3-intrinsic函数介绍"><a href="#5-3-intrinsic函数介绍" class="headerlink" title="5.3 intrinsic函数介绍"></a>5.3 intrinsic函数介绍</h3><p>1、算术和位运算指令： vadd，vsub，vmul，vand，vorr，vshl，vshr等。<br>2、数据移动指令： vdup, vset, vget, vmov<br>3、访存指令：vld, vst<br>4、条件指令： vce, vcle, vcge, vcgt</p><p>更多函数参考：第6章指令查找手册</p><h2 id="6、指令查找手册"><a href="#6、指令查找手册" class="headerlink" title="6、指令查找手册"></a>6、指令查找手册</h2><p>&lt;1&gt; Neon Intrinsics Reference在线手册： <a href="https://developer.arm.com/architectures/instruction-sets/simd-isas/neon/intrinsics" target="_blank" rel="noopener">https://developer.arm.com/architectures/instruction-sets/simd-isas/neon/intrinsics</a><br>&lt;2&gt; Arm Neon Intrinsics Reference文档下载：<a href="https://developer.arm.com/documentation/ihi0073/latest" target="_blank" rel="noopener">https://developer.arm.com/documentation/ihi0073/latest</a></p><h2 id="7、Automatic-vectorization"><a href="#7、Automatic-vectorization" class="headerlink" title="7、Automatic vectorization"></a>7、Automatic vectorization</h2><p>参考：<a href="https://developer.arm.com/documentation/dht0002/a/Introducing-NEON/Developing-for-NEON/Automatic-vectorization" target="_blank" rel="noopener">https://developer.arm.com/documentation/dht0002/a/Introducing-NEON/Developing-for-NEON/Automatic-vectorization</a></p><p> The compiler can also perform automatic vectorization on your C or C++ source code. This gives access to high NEON performance without writing assembly code or using intrinsics. This permits your source code to remain portable between different tools and target platforms.</p><p>使用方法：在GCC编译选项中指定<code>-mfpu=neon -ftree-vectorize</code>。</p><pre><code>arm-none-linux-gnueabi-gcc -mfpu=neon -ftree-vectorize -c vectorized.c</code></pre><h2 id="8、arm-neon-Intrinsic-demo"><a href="#8、arm-neon-Intrinsic-demo" class="headerlink" title="8、arm neon Intrinsic demo"></a>8、arm neon Intrinsic demo</h2><p><a href="https://github.com/soaringleefighting/AssemblySample" target="_blank" rel="noopener">https://github.com/soaringleefighting/AssemblySample</a> 中的scm_gradientImage_neon_arm_intrin.c</p><p>———————————–<font color="red"><strong>THE END!</strong></font>——————————</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 优化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ARM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>X86&amp;ARM汇编模板AssemblySample</title>
      <link href="/2020/09/06/%E3%80%90%E5%B7%A5%E7%A8%8B%E5%8C%96%E7%B3%BB%E5%88%97%E3%80%91X86&amp;ARM%E6%B1%87%E7%BC%96%E6%A8%A1%E6%9D%BFAssemblySample/"/>
      <url>/2020/09/06/%E3%80%90%E5%B7%A5%E7%A8%8B%E5%8C%96%E7%B3%BB%E5%88%97%E3%80%91X86&amp;ARM%E6%B1%87%E7%BC%96%E6%A8%A1%E6%9D%BFAssemblySample/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="1、参考"><a href="#1、参考" class="headerlink" title="1、参考"></a>1、参考</h2><p><a href="https://soaringlee.blog.csdn.net/article/details/108424127" target="_blank" rel="noopener">【优化系列】X86架构汇编优化系列汇总</a><br><a href="https://blog.csdn.net/SoaringLee_fighting/article/details/99567833" target="_blank" rel="noopener">【ARM系列】ARM NEON汇编优化系列汇总</a></p><h2 id="2、X86-amp-ARM汇编模板AssemblySample"><a href="#2、X86-amp-ARM汇编模板AssemblySample" class="headerlink" title="2、X86&amp;ARM汇编模板AssemblySample"></a>2、X86&amp;ARM汇编模板AssemblySample</h2><p>该模板主要用于快速入门X86 MMX/SSE/AVX/AVX2/AVX512汇编和ARM NEON汇编优化方法，主要包括了X86/ARM纯汇编优化方法、X86/ARM Intrinsic汇编优化方法和X86 Inline汇编优化方法。这个sample也是自己对X86和ARM汇编优化这方面知识的技术总结。</p><h2 id="3、README"><a href="#3、README" class="headerlink" title="3、README"></a>3、README</h2><pre><code>AssemblySampleThis is a sample project for demonstrating how to write assembly code simply.Sample功能和搭建目的1、支持x86 assembly, inline, instrinsic的demo及编译2、支持ARM assembly, inline, intrinsic的demo及编译3、通过该Sample旨在快速入门X86和ARM汇编程序编写方法和使用方法。Linux/ARM编译方法（1）编译64位程序： make或者make platform=x86_64（2）编译32位程序：make platform=x86_32</code></pre><h2 id="4、模板开源地址"><a href="#4、模板开源地址" class="headerlink" title="4、模板开源地址"></a>4、模板开源地址</h2><p><a href="https://github.com/soaringleefighting/AssemblySample" target="_blank" rel="noopener">https://github.com/soaringleefighting/AssemblySample</a></p><p><font color="red">THE END!</font></p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 开源项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> X86 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>X86优化之Intrinsic汇编方法</title>
      <link href="/2020/09/05/%E3%80%90%E4%BC%98%E5%8C%96%E7%B3%BB%E5%88%97%E3%80%91X86%E4%BC%98%E5%8C%96%E4%B9%8BIntrinsic%E6%B1%87%E7%BC%96%E6%96%B9%E6%B3%95/"/>
      <url>/2020/09/05/%E3%80%90%E4%BC%98%E5%8C%96%E7%B3%BB%E5%88%97%E3%80%91X86%E4%BC%98%E5%8C%96%E4%B9%8BIntrinsic%E6%B1%87%E7%BC%96%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p> <a href="http://www.voidcn.com/article/p-rhuayhet-brz.html" target="_blank" rel="noopener">x86架构intrinsic优化</a></p><h2 id="1、SSE-Intrisic-based-on-x86"><a href="#1、SSE-Intrisic-based-on-x86" class="headerlink" title="1、SSE Intrisic based on x86"></a>1、SSE Intrisic based on x86</h2><p>&ensp; &ensp; &ensp; x86架构下的优化有多种手段，常见的有纯汇编优化、inline汇编、Intrinsic优化。前两种对编译器的依赖比较大，跨平台（windows\linux等）编译问题比较多，例如纯汇编：win32、win64、linux64下函数形参入栈规则都不一样，且需要保护的寄存器也有较大区别，此外还有汇编重定位问题等等；而inline汇编在windows下是intel格式，在linux下是AT&amp;T格式。intrinsic入门快，且没有以上诸多问题，比较适合初学者，但是其性能相对纯汇编或Inline汇编，会差一些。本文就intrinsic优化作一些简单的介绍，具体需结合实践理解学习。　　　</p><h3 id="1-1-指令集对应的位数"><a href="#1-1-指令集对应的位数" class="headerlink" title="1.1 指令集对应的位数"></a>1.1 指令集对应的位数</h3><table><thead><tr><th>指令集类型</th><th>所占位数</th></tr></thead><tbody><tr><td>MMX</td><td>Multi Media Extensions 8 x 64bit (1997)</td></tr><tr><td>SSE/SSE2/SSE3/SSSE3/SSE4.x</td><td>Streaming SIMD Extensions 8 x 128bit (1999)</td></tr><tr><td>AVX/AVX2/FMA</td><td>Advanced Vector Extensions 16 x 256 bit (2008)</td></tr><tr><td>AVX-512/KNC</td><td>Advanced Vector Extensions 32 x 512 bit (2012)</td></tr><tr><td>备注：第二列8*64代表MMX寄存器有8个，每个是64位；8x128道理类似。</td><td></td></tr></tbody></table><h3 id="1-2-指令集intrinsic对应的头文件"><a href="#1-2-指令集intrinsic对应的头文件" class="headerlink" title="1.2 指令集intrinsic对应的头文件"></a>1.2 指令集intrinsic对应的头文件</h3><p>(1)、不同版本的指令集对应的intrinsic头文件如表1.1所示；表1.1中也列出了不同版本的VS对Intrinsic的支持能力不一。<br>此外，需要注意的是:</p><ul><li>1&gt;、在VS中如果想win32及win64都能编译通过，应避免使用__m64类型的数据，数据类型在本文中会有讲述；</li><li>2&gt;、如果想在linux中编译成功，需在编译选项中加 -msse、-msse4.1等。</li></ul><p><img src="https://img-blog.csdnimg.cn/20200905220402568.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NvYXJpbmdMZWVfZmlnaHRpbmc=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><h2 id="2、-数据类型"><a href="#2、-数据类型" class="headerlink" title="2、 数据类型"></a>2、 数据类型</h2><p><img src="https://img-blog.csdnimg.cn/20200905220443132.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NvYXJpbmdMZWVfZmlnaHRpbmc=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br> 备注：MMX指令集使用 64位数据类型、SSE指令集使用128数据类型、AVX指令集使用256位数据类型。</p><h3 id="2-1-数据类型的转换"><a href="#2-1-数据类型的转换" class="headerlink" title="2.1 数据类型的转换"></a>2.1 数据类型的转换</h3><p>　SSE汇编指令和其Intrinsic函数之间基本存在这一一对应的关系，有了汇编的实现再改为Intrinsic是挺简单的。</p><p>类型转换主要以下几种：<br>1&gt;. 浮点数和整数的转换及32位浮点数和64位浮点数之间的转换。 这种转换简单直接，只需要调用相应的函数指令即可。<br>2&gt;. 有符号整数的高位扩展将8位、16位、32位有符号整数扩展为16位、32位、64位。<br>4&gt;. 无符号整数到有符号整数的扩展。</p><p>在Intrinsic函数中 上述类型转换的格式</p><ul><li>_mm_cvtepixx_epixx （xx是位数8/16/32/64）这是有符号整数之间的转换</li><li>_mm_cvtepixx_ps / _mm_cvtepixx_pd 整数到单精度/双精度浮点数之间的转换</li><li>_mm_cvtepuxx_epixx 无符号整数向有符号整数的扩展，采用高位0扩展的方式，这些函数是对无符号高位0扩展变成相应位数的有符号整数。没有32位无符号整数转换为16位有符号整数这样的操作。</li><li>_mm_cvtepuxx_ps / _mm_cvtepuxx_pd 无符号整数转换为单精度/双精度浮点数。</li></ul><h2 id="3、-intrinsic函数命名"><a href="#3、-intrinsic函数命名" class="headerlink" title="3、 intrinsic函数命名"></a>3、 intrinsic函数命名</h2><pre><code class="m">Naming convention: _mm_&lt;intrin_op&gt;_&lt;suffix&gt;</code></pre><p>where mm is the prefix for working on the 64-bit registers or 128-bit registers; intrin_op is the operation, like add for addition or sub for subtraction; and suffix denotes the type of data to operate on, with the first letters denoting packed (p), extended packed (ep), or scalar (s). The remaining letters are the types given in the table below.suffix Markings.</p><p><img src="https://img-blog.csdnimg.cn/20200905221611147.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NvYXJpbmdMZWVfZmlnaHRpbmc=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><h2 id="4、示例"><a href="#4、示例" class="headerlink" title="4、示例"></a>4、示例</h2><p>C代码</p><pre><code class="c">void add(float *a, float *b, float *c){   int i;   for (i = 0; i &lt; 4; i++) {       c[i] = a[i] + b[i];    }}</code></pre><p>对应的Intrinsic代码：</p><pre><code class="asm">#include &lt;xmmintrin.h&gt;void add(float *a, float *b, float *c){    __m128 t0, t1;    t0 = _mm_load_ps(a);    t1 = _mm_load_ps(b);    t0 = _mm_add_ps(t0, t1);    _mm_store_ps(c, t0);}</code></pre><p>备注：代码摘自<a href="https://software.intel.com/sites/default/files/managed/9e/bc/64-ia-32-architectures-optimization-manual.pdf" target="_blank" rel="noopener">https://software.intel.com/sites/default/files/managed/9e/bc/64-ia-32-architectures-optimization-manual.pdf</a> 4.3.1.2 小节.</p><h2 id="5、附录"><a href="#5、附录" class="headerlink" title="5、附录"></a>5、附录</h2><p>intel intrinsic手册 ： <a href="https://software.intel.com/en-us/articles/intel-sdm" target="_blank" rel="noopener">https://software.intel.com/en-us/articles/intel-sdm</a></p><h3 id="5-1-Latency-and-Throughput"><a href="#5-1-Latency-and-Throughput" class="headerlink" title="5.1 Latency and Throughput"></a>5.1 Latency and Throughput</h3><p>Latency: 指令占据多少个时钟周期，此后数据才可被下一条指令使用。<br>Throughput:指令占据运算单元多少个时钟周期，此后运算单元才可被下一条指令使用。<br>参考网址：<a href="https://software.intel.com/en-us/articles/measuring-instruction-latency-and-throughput" target="_blank" rel="noopener">https://software.intel.com/en-us/articles/measuring-instruction-latency-and-throughput</a></p><p>参考网址：<br><a href="https://blog.csdn.net/brookicv/article/details/52295043" target="_blank" rel="noopener">https://blog.csdn.net/brookicv/article/details/52295043</a><br><a href="https://software.intel.com/en-us/comment/1758892" target="_blank" rel="noopener">https://software.intel.com/en-us/comment/1758892</a><br><a href="http://verchetensna.ga/software/4247intel-intrinsics-guide-download.html#" target="_blank" rel="noopener">http://verchetensna.ga/software/4247intel-intrinsics-guide-download.html#</a><br><a href="https://www-m17.ma.tum.de/foswiki/pub/M17/Lehrstuhl/LehreWiSe1516ATHPSC/INT1.pdf" target="_blank" rel="noopener">https://www-m17.ma.tum.de/foswiki/pub/M17/Lehrstuhl/LehreWiSe1516ATHPSC/INT1.pdf</a><br><a href="https://db.in.tum.de/~finis/x86-intrin-cheatsheet-v2.1.pdf" target="_blank" rel="noopener">https://db.in.tum.de/~finis/x86-intrin-cheatsheet-v2.1.pdf</a><br><a href="https://www.inf.ethz.ch/personal/markusp/teaching/263-2300-ETH-spring11/slides/class17.pdf" target="_blank" rel="noopener">https://www.inf.ethz.ch/personal/markusp/teaching/263-2300-ETH-spring11/slides/class17.pdf</a><br><a href="http://sseplus.sourceforge.net/fntable.html" target="_blank" rel="noopener">http://sseplus.sourceforge.net/fntable.html</a><br><a href="https://stackoverflow.com/questions/661338/sse-sse2-and-sse3-for-gnu-c/662250#662250" target="_blank" rel="noopener">https://stackoverflow.com/questions/661338/sse-sse2-and-sse3-for-gnu-c/662250#662250</a><br><a href="https://stackoverflow.com/questions/7156908/sse-intrinsic-functions-reference" target="_blank" rel="noopener">https://stackoverflow.com/questions/7156908/sse-intrinsic-functions-reference</a><br><a href="https://gcc.gnu.org/onlinedocs/gcc-4.3.3/gcc/i386-and-x86_002d64-Options.html#i386-and-x86_002d64-Options" target="_blank" rel="noopener">https://gcc.gnu.org/onlinedocs/gcc-4.3.3/gcc/i386-and-x86_002d64-Options.html#i386-and-x86_002d64-Options</a><br><a href="http://www.agner.org/optimize/" target="_blank" rel="noopener">http://www.agner.org/optimize/</a><br><a href="http://www.ehu.eus/sgi/ARCHIVOS/c_ug_lnx.pdf" target="_blank" rel="noopener">http://www.ehu.eus/sgi/ARCHIVOS/c_ug_lnx.pdf</a></p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 优化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> X86 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>X86优化之Intrinsic汇编demo</title>
      <link href="/2020/09/05/%E3%80%90%E4%BC%98%E5%8C%96%E7%B3%BB%E5%88%97%E3%80%91X86%E4%BC%98%E5%8C%96%E4%B9%8BIntrinsic%E6%B1%87%E7%BC%96demo/"/>
      <url>/2020/09/05/%E3%80%90%E4%BC%98%E5%8C%96%E7%B3%BB%E5%88%97%E3%80%91X86%E4%BC%98%E5%8C%96%E4%B9%8BIntrinsic%E6%B1%87%E7%BC%96demo/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="1、Demo的C代码"><a href="#1、Demo的C代码" class="headerlink" title="1、Demo的C代码"></a>1、Demo的C代码</h2><pre><code class="c">// 计算当前图像的梯度图int generateGradientImage(unsigned char *Src, unsigned char *Dst,    int Width, int Height, int Stride){    unsigned int gradX = 0;    unsigned int gradY = 0;    unsigned char * dstImage = NULL;    // 1. 求取梯度图像    memset(Dst, 0, Width * sizeof(unsigned int));         // 第一行都为0    for (int y = 1; y &lt; Height; y++)    {        dstImage = Dst + y * Width + 1;        dstImage[-1] = 0;                                    // 第一列为0        for (int x = 1; x &lt; Width; x++)        {            gradX = abs(Src[y * Stride + x] - Src[y * Stride + x - 1]);            gradY = abs(Src[y * Stride + x] - Src[(y - 1) * Stride + x]);            dstImage[x - 1] = (gradX + gradY) &gt;&gt; 1;        }    }    return 0;}</code></pre><h2 id="2、X86-Intrinsic代码"><a href="#2、X86-Intrinsic代码" class="headerlink" title="2、X86 Intrinsic代码"></a>2、X86 Intrinsic代码</h2><pre><code class="asm">#include &lt;mmintrin.h&gt;        /* MMX */#include &lt;emmintrin.h&gt;        /* SSE2 */#include &lt;tmmintrin.h&gt;        /* SSSE3 */#include &lt;smmintrin.h&gt;        /* SSE4.1 */#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;/******************************************************************/*    KunPeng Technology CO. LTD/*    2001-2020 Copyright reversed./*    @Funtion Name        :  scm_generateGradientImage_sse4/*    @Description        :  calculate gradient image for current image/*    @Input para        :  unsigned char *Src    : source image/*                           int Width            : width of image/*                           int Height            : height of image/*                           int Stride            : stride of image/*      @Output para        :  unsigned int *Dst    : dstination gradient image/*    @Return            :  0: Success  -1: Failure/*    @Author            :  lipeng/*    @Revison History    :/*        1. Date            : 2020.9.5/*           Author        : lipeng/*           Modification    : create the function/********************************************************************/int scm_generateGradientImage_intrinsic_sse4(unsigned char *Src, unsigned char *Dst,                            int Width, int Height, int Stride){    __m128i last_line, firstline, second_line, third_line, four_line;    __m128i first_line_lt, second_line_lt, third_line_lt, four_line_lt;    unsigned char *Src_in = NULL;    unsigned char *Dst_in = NULL;    // 初始化    memset( Dst, 0, Width * sizeof(unsigned int) );         // 第一行都为0    for (int y = 1; y &lt; Height; y+=4)    {        Src_in = Src + y * Stride;        Dst_in = Dst + y * Width;        for (int x = 0; x &lt; Width; x+=8)        {            // 1.加载原始像素值            last_line = _mm_loadl_epi64((__m128i const*)(Src_in - Stride));            // 上一行            firstline = _mm_loadl_epi64((__m128i const*)Src_in);                    // 取出第一行8个像素点            second_line = _mm_loadl_epi64((__m128i const*)(Src_in + Stride));        // 第二行            third_line = _mm_loadl_epi64((__m128i const*)(Src_in + 2 * Stride));    // 第三行            four_line = _mm_loadl_epi64((__m128i const*)(Src_in + 3 * Stride));        // 第四行            // 2.左移一个像素点            if (x == 0) /*  考虑边界上内存读取越界的风险（第一列） */            {                first_line_lt = _mm_slli_epi64(firstline, 8);                second_line_lt = _mm_slli_epi64(second_line, 8);                third_line_lt = _mm_slli_epi64(third_line, 8);                four_line_lt = _mm_slli_epi64(four_line, 8);            }            else            {                first_line_lt = _mm_loadl_epi64((__m128i const*)(Src_in - 1));                second_line_lt = _mm_loadl_epi64((__m128i const*)(Src_in - 1 + Stride));    // 第二行                third_line_lt = _mm_loadl_epi64((__m128i const*)(Src_in - 1 + 2 * Stride));    // 第三行                four_line_lt = _mm_loadl_epi64((__m128i const*)(Src_in - 1 + 3 * Stride));    // 第四行            }            // 3.8位扩展到16位            __m128i zero = _mm_setzero_si128();            last_line = _mm_unpacklo_epi8(last_line, zero);            firstline = _mm_unpacklo_epi8(firstline, zero);            second_line = _mm_unpacklo_epi8(second_line, zero);            third_line = _mm_unpacklo_epi8(third_line, zero);            four_line = _mm_unpacklo_epi8(four_line, zero);            first_line_lt = _mm_unpacklo_epi8(first_line_lt, zero);            second_line_lt = _mm_unpacklo_epi8(second_line_lt, zero);            third_line_lt = _mm_unpacklo_epi8(third_line_lt, zero);            four_line_lt = _mm_unpacklo_epi8(four_line_lt, zero);            // 4.第一行梯度计算            __m128i one = { 1 };            last_line      = _mm_sub_epi16(last_line, firstline);            // gradY            first_line_lt = _mm_sub_epi16(first_line_lt, firstline);        // gradX            last_line      = _mm_abs_epi16(last_line);                        // abs(gradY)            first_line_lt = _mm_abs_epi16(first_line_lt);                    // abs(gradX)            first_line_lt = _mm_add_epi16(first_line_lt, last_line);        // abs(gradX)+abs(gradY)            first_line_lt = _mm_sra_epi16(first_line_lt, one);                // &gt;&gt;1            first_line_lt = _mm_packus_epi16(first_line_lt, first_line_lt);            // 5.第二行梯度计算            firstline = _mm_sub_epi16(firstline, second_line);                // gradY            second_line_lt = _mm_sub_epi16(second_line_lt, second_line);    // gradX            second_line_lt = _mm_abs_epi16(second_line_lt);                    // abs(gradY)            firstline = _mm_abs_epi16(firstline);                            // abs(gradX)            second_line_lt = _mm_add_epi16(firstline, second_line_lt);        // abs(gradX)+abs(gradY)            second_line_lt = _mm_sra_epi16(second_line_lt, one);            // &gt;&gt;1            second_line_lt = _mm_packus_epi16(second_line_lt, second_line_lt);            // 6.第三行梯度计算            second_line = _mm_sub_epi16(second_line, third_line);            // gradY            third_line_lt = _mm_sub_epi16(third_line_lt, third_line);        // gradX            third_line_lt = _mm_abs_epi16(third_line_lt);                    // abs(gradY)            second_line = _mm_abs_epi16(second_line);                        // abs(gradX)            third_line_lt = _mm_add_epi16(second_line, third_line_lt);        // abs(gradX)+abs(gradY)            third_line_lt = _mm_sra_epi16(third_line_lt, one);                // &gt;&gt;1            third_line_lt = _mm_packus_epi16(third_line_lt, third_line_lt);            // 7.第四行梯度计算            third_line = _mm_sub_epi16(third_line, four_line);                // gradY            four_line_lt = _mm_sub_epi16(four_line_lt, four_line);            // gradX            four_line_lt = _mm_abs_epi16(four_line_lt);                        // abs(gradY)            third_line = _mm_abs_epi16(third_line);                            // abs(gradX)            four_line_lt = _mm_add_epi16(third_line, four_line_lt);            // abs(gradX)+abs(gradY)            four_line_lt = _mm_sra_epi16(four_line_lt, one);                // &gt;&gt;1            four_line_lt = _mm_packus_epi16(four_line_lt, four_line_lt);            // 第一列为0            if (x == 0)            {                zero = _mm_insert_epi32(_mm_insert_epi32(zero, 0xFFFFFF00, 0), 0xFFFFFFFF, 1);                first_line_lt = _mm_and_si128(first_line_lt, zero);                second_line_lt = _mm_and_si128(second_line_lt, zero);                third_line_lt = _mm_and_si128(third_line_lt, zero);                four_line_lt = _mm_and_si128(four_line_lt, zero);            }            // 8.存储            _mm_storel_epi64((__m128i*)Dst_in, first_line_lt);            _mm_storel_epi64((__m128i*)(Dst_in + Width), second_line_lt);            _mm_storel_epi64((__m128i*)(Dst_in + Width * 2), third_line_lt);            _mm_storel_epi64((__m128i*)(Dst_in + Width * 3), four_line_lt);            Src_in += 8;            Dst_in += 8;        }    }    return 0;}</code></pre><p>———————————–<font color="red"><strong>THE END!</strong></font>——————————</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 优化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> X86 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言编程规范</title>
      <link href="/2020/08/16/%E3%80%90%E5%B7%A5%E7%A8%8B%E5%8C%96%E7%B3%BB%E5%88%97%E3%80%91C%E8%AF%AD%E8%A8%80%E7%BC%96%E7%A8%8B%E8%A7%84%E8%8C%83/"/>
      <url>/2020/08/16/%E3%80%90%E5%B7%A5%E7%A8%8B%E5%8C%96%E7%B3%BB%E5%88%97%E3%80%91C%E8%AF%AD%E8%A8%80%E7%BC%96%E7%A8%8B%E8%A7%84%E8%8C%83/</url>
      
        <content type="html"><![CDATA[<p>[toc]</p><hr><h2 id="1、参考"><a href="#1、参考" class="headerlink" title="1、参考"></a>1、参考</h2><p><a href="https://blog.csdn.net/SoaringLee_fighting/article/details/93773779" target="_blank" rel="noopener">【编程系列】编程规范之文件头和函数头格式</a></p><h2 id="2、C语言编程规范"><a href="#2、C语言编程规范" class="headerlink" title="2、C语言编程规范"></a>2、C语言编程规范</h2><h3 id="2-1-代码总体原则"><a href="#2-1-代码总体原则" class="headerlink" title="2.1 代码总体原则"></a>2.1 代码总体原则</h3><ul><li>1、清晰第一</li><li>2、简洁为美</li><li>3、选择合适的风格，与代码原有风格保持一致。</li></ul><p>（1）一般情况下，代码的可阅读性高于性能，只有确定性能是瓶颈时，才应该主动优化。<br>（2）废弃的代码(没有被调用的函数和全局变量)要及时清除，重复代码应该尽可能提炼成函数。<br>（3）对于C语言来说，头文件的设计体现了大部分的系统设计。</p><h3 id="2-2-（一）、头文件"><a href="#2-2-（一）、头文件" class="headerlink" title="2.2 （一）、头文件"></a>2.2 （一）、头文件</h3><p><strong>原则1.1</strong>  头文件中适合放置接口的声明，但不适合放置实现。<br><strong>原则1.2</strong> 头文件应当职责单一。<br><strong>规则1.1</strong> 每一个.c文件应有一个同名.h文件，用于声明需要对外公开的接口。<br><strong>规则1.2</strong> 禁止头文件循环依赖。<br><strong>规则1.3</strong> .c/.h文件禁止包含用不到的头文件。<br><strong>规则1.4</strong> 头文件应当自包含。<br><strong>规则1.5</strong> 总是编写内部#include保护符（#define 保护）。</p><pre><code class="c"> #define SCM_ENCODE_H</code></pre><p><strong>规则1.6</strong> 禁止在头文件中定义变量。<br><strong>规则1.7</strong> 只能通过包含头文件的方式使用其他.c提供的接口，禁止在.c中通过extern的方式使用外部函数接口、变量。</p><h3 id="2-3-（二）、函数"><a href="#2-3-（二）、函数" class="headerlink" title="2.3  （二）、函数"></a>2.3  （二）、函数</h3><p>函数设计的精髓：编写整洁函数，同时把代码有效组织起来。<br><strong>原则2.1</strong> 一个函数仅完成一件功能。<br><strong>原则2.2</strong> 重复代码应该尽可能提炼成函数。<br><strong>规则2.1</strong> 避免函数过长，新增函数不超过50行（非空非注释行）。<br><strong>规则2.2</strong> 避免函数的代码块嵌套过深，新增函数的代码块嵌套不超过4层。<br><strong>规则2.3</strong> 可重入函数应避免使用共享变量（全局变量或静态变量）；若需要使用，则应通过互斥手段（关中断、信号量）对其加以保护。<br><strong>规则2.4</strong> 对参数的合法性检查，由调用者负责还是由接口函数负责，应在项目组/模块内应统一规定。缺省由调用者负责。对函数的错误返回码要全面处理。（错误返回机制）<br><strong>规则2.6</strong> 设计高扇入，合理扇出（小于7）的函数。<br><strong>规则2.7</strong> 废弃代码（没有被调用的函数和变量)要及时清除。</p><h3 id="2-4-（三）、标识符-命名与定义"><a href="#2-4-（三）、标识符-命名与定义" class="headerlink" title="2.4  （三）、标识符 命名与定义"></a>2.4  （三）、标识符 命名与定义</h3><p>不建议采用匈牙利命名法（前缀_基本类型_限定词）。<br><strong>规则3.1</strong> 产品/项目组内部应保持统一的命名风格。<br>b 全局变量应增加“g_”前缀。<br><strong>规则3.3</strong> 静态变量应增加“s_”前缀。Mgpast/sz<br><strong>规则3.4</strong> 对于数值或者字符串等等常量的定义，建议采用全大写字母，单词之间加下划线\„_\‟的方式命名（枚举同样建议使用此方式定义）。</p><p><strong>建议3.5</strong> 重构/修改部分代码时，应保持和原有代码的命名风格一致。<br><strong>建议3.6</strong> 文件命名统一采用小写字符。<br><strong>建议3.7</strong> 不建议使用匈牙利命名法。<br> 使用名词或者形容词＋名词方式命名变量。<br><strong>建议3.9</strong> 函数命名应以函数要执行的动作命名，一般采用动词或者动词＋名词的结构。</p><h3 id="2-5-（四）、变量"><a href="#2-5-（四）、变量" class="headerlink" title="2.5 （四）、变量"></a>2.5 （四）、变量</h3><p><strong>规则4.1</strong> 防止局部变量与全局变量同名。<br><strong>规则4.2</strong> 通讯过程中使用的结构，必须注意字节序。<br><strong>规则4.3</strong> 严禁使用未经初始化的变量作为右值。所有变量定义时必须初始化。</p><p><strong>建议4.1</strong> 在首次使用前初始化变量，初始化的地方离使用的地方越近越好。<br><strong>建议4.2</strong> 尽量减少没有必要的数据类型默认转换与强制转换。</p><h3 id="2-6-（五）、宏、常量"><a href="#2-6-（五）、宏、常量" class="headerlink" title="2.6  （五）、宏、常量"></a>2.6  （五）、宏、常量</h3><p><strong>规则5.1</strong> 用宏定义表达式时，要使用完备的括号。<br><strong>规则5.2</strong> 将宏所定义的多条表达式放在大括号中。（更好的方法是多条语句写成do while(0)的方式）<br><strong>规则5.3</strong> 使用宏时，不允许参数发生变化。<br><strong>规则5.4</strong> 不允许直接使用魔鬼数字。MAGIC NUMBER<br><strong>建议5.1</strong> 常量建议使用const定义代替宏。<br><strong>建议5.2</strong> 宏定义中尽量不使用return、goto、continue、break等改变程序流程的语句。</p><p><strong>规则6.5</strong> 所有的if … else if结构应该由else子句结束 ；switch语句必须有default分支。<br><strong>建议6.2</strong> if语句尽量加上else分支，对没有else分支的语句要小心对待。<br><strong>建议6.3</strong> 不要滥用goto语句。<br><strong>建议7.1</strong> 将不变条件的计算移到循环体外。<br><strong>建议7.4</strong> 将多次被调用的 “小函数”改为inline函数或者宏实现。</p><h3 id="2-7-（六）、注释"><a href="#2-7-（六）、注释" class="headerlink" title="2.7 （六）、注释"></a>2.7 （六）、注释</h3><p><strong>原则8.1</strong> 优秀的代码可以自我解释，不通过注释即可轻易读懂。建议 /* <em>/<br>*</em>原则8.2** 注释的内容要清楚、明了，含义准确，防止注释二义性。<br><strong>原则8.3</strong> 在代码的功能、意图层次上进行注释，即注释解释代码难以直接表达的意图，而不是重复描述代码。<br><strong>规则8.1</strong> 修改代码时，维护代码周边的所有注释，以保证注释与代码的一致性。不再有用的注释要删除。<br><strong>规则8.2</strong> 文件头部应进行注释，注释必须列出：版权说明、版本号、生成日期、作者姓名、工号、内容、功能说明、与其它文件的关系、修改日志等，头文件的注释中还应有函数功能简要说明。</p><h3 id="2-8-（七）、排版与格式"><a href="#2-8-（七）、排版与格式" class="headerlink" title="2.8 （七）、排版与格式"></a>2.8 （七）、排版与格式</h3><p><strong>规则9.1</strong> 程序块采用缩进风格编写，每级缩进为4个空格。<br><strong>规则9.2</strong> 相对独立的程序块之间、变量说明之后必须加空行。<br><strong>规则9.3</strong> 一条语句不能过长，如不能拆分需要分行写。一行到底多少字符换行比较合适，产品可以自行确定。<br><strong>规则9.4</strong> 多个短语句（包括赋值语句）不允许写在同一行内，即一行只写一条语句。<br><strong>规则9.6</strong> 在两个以上的关键字、变量、常量进行对等操作时，它们之间的操作符之前、之后或者前后要加空格；进行非对等操作时，如果是关系密切的立即操作符（如－&gt;），后不应加空格。（“松散方式”）</p><h3 id="2-9-（八）、安全性"><a href="#2-9-（八）、安全性" class="headerlink" title="2.9 （八）、安全性"></a>2.9 （八）、安全性</h3><p><strong>原则13.1</strong> 对用户输入进行检查。<br><strong>规则13.1</strong> 确保所有字符串是以NULL结束。</p><p>———————————–<font color="red"><strong>THE END!</strong></font>——————————</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 工程化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux下编译makefile将宏参数传递给C文件</title>
      <link href="/2020/08/02/%E3%80%90%E5%B7%A5%E7%A8%8B%E5%8C%96%E7%B3%BB%E5%88%97%E3%80%91linux%E4%B8%8B%E7%BC%96%E8%AF%91makefile%E5%B0%86%E5%AE%8F%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92%E7%BB%99C%E6%96%87%E4%BB%B6/"/>
      <url>/2020/08/02/%E3%80%90%E5%B7%A5%E7%A8%8B%E5%8C%96%E7%B3%BB%E5%88%97%E3%80%91linux%E4%B8%8B%E7%BC%96%E8%AF%91makefile%E5%B0%86%E5%AE%8F%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92%E7%BB%99C%E6%96%87%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><hr><h2 id="1、前言"><a href="#1、前言" class="headerlink" title="1、前言"></a>1、前言</h2><p>&ensp; &ensp;  在项目开发过程中，遇到需要将makefile中解析的参数（比如git log解析出的hash值）传入到C代码中。下面详细讲解如何实现将makefile中参数传递到C文件中。</p><h2 id="2、参考"><a href="#2、参考" class="headerlink" title="2、参考"></a>2、参考</h2><p><a href="https://blog.csdn.net/amddma/article/details/81206192" target="_blank" rel="noopener">linux下编译 makefile 将参数传递给c文件</a></p><h2 id="3、C文件"><a href="#3、C文件" class="headerlink" title="3、C文件"></a>3、C文件</h2><pre><code class="c">#include &lt;stdio.h&gt;int main(){    printf(&quot;Make Time: %s  \n&quot;,MAKE_TIME);    return 0;}</code></pre><h2 id="4、makefile文件"><a href="#4、makefile文件" class="headerlink" title="4、makefile文件"></a>4、makefile文件</h2><pre><code class="makefile">GET_DATE := $(shell date +%F)GET_TIME := $(shell date +%H:%M:%S)all: main.o    gcc -o main main.omain.o: main.cpp    g++ -o main.o -DMAKE_TIME=\&quot;$(GET_DATE)\ $(GET_TIME)\&quot; -c main.cppclean:    @-rm main    @-rm *.o    @ls -laths</code></pre><p>编译过程：<br><img src="https://img-blog.csdnimg.cn/20200802124807589.png" alt="编译过程"></p><p>运行结果：<br><img src="https://img-blog.csdnimg.cn/20200802124839699.png" alt="运行结果"></p><h2 id="5、解析"><a href="#5、解析" class="headerlink" title="5、解析"></a>5、解析</h2><p>在本例中，主要是通过-D参数进行传递 。-D参数为gcc编译添加宏定义选项，编译时将宏定义传递给C文件。</p><p>——————<font color="red"><strong>THE END!</strong></font>———————</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 工程化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> makefile </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++类中引用另一个类内的指针变量</title>
      <link href="/2020/07/31/%E3%80%90C++%E7%B3%BB%E5%88%97%E3%80%91C++%E7%B1%BB%E4%B8%AD%E5%BC%95%E7%94%A8%E5%8F%A6%E4%B8%80%E4%B8%AA%E7%B1%BB%E5%86%85%E7%9A%84%E6%8C%87%E9%92%88%E5%8F%98%E9%87%8F/"/>
      <url>/2020/07/31/%E3%80%90C++%E7%B3%BB%E5%88%97%E3%80%91C++%E7%B1%BB%E4%B8%AD%E5%BC%95%E7%94%A8%E5%8F%A6%E4%B8%80%E4%B8%AA%E7%B1%BB%E5%86%85%E7%9A%84%E6%8C%87%E9%92%88%E5%8F%98%E9%87%8F/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="1、参考"><a href="#1、参考" class="headerlink" title="1、参考"></a>1、参考</h2><p><a href="https://blog.csdn.net/martinkeith/article/details/90240886" target="_blank" rel="noopener">c++类内引用另一个类的指针</a></p><p><a href="https://blog.csdn.net/Mr_xiao_1/article/details/80219162" target="_blank" rel="noopener">C++中一个类访问另外一个类的成员变量或者成员函数</a></p><h2 id="2、C-一个类访问另一个类的成员函数"><a href="#2、C-一个类访问另一个类的成员函数" class="headerlink" title="2、C++一个类访问另一个类的成员函数"></a>2、C++一个类访问另一个类的成员函数</h2><h3 id="2-1、实现方法"><a href="#2-1、实现方法" class="headerlink" title="2.1、实现方法"></a>2.1、实现方法</h3><p>通过在一个类中定义另外一个类的成员为指针类型。并用this指针管理对象的内存，实现数据的传递。<br>这样，TEncSearch类中就可以访问TEncTop类中的m_integralImage指针和m_integralImage指针了。</p><p>访问方法：</p><pre><code class="cpp">TEncSearch encSearch;encSearch.m_cTEncTop_integral-&gt;m_integralImageencSearch.m_cTEncTop_integral-&gt;m_grad_integralImage</code></pre><h3 id="2-2、示例如下"><a href="#2-2、示例如下" class="headerlink" title="2.2、示例如下"></a>2.2、示例如下</h3><p>两个类的定义如下：</p><pre><code class="cpp">class TEncSearch{public:    TEncSearch();    virtual ~TEncSearch();    TEncTop       *m_cTEncTop_integral;};class TEncTop{private:    TEncSearch              m_cSearch;    ///&lt; encoder search classpublic:    TEncTop();    virtual ~TEncTop();    void   create();    void   destroy();void   create_search(){    m_cSearch.m_cTEncTop_integral = this;}unsigned int* m_integralImage;                // integral image for current frameunsigned int* m_grad_integralImage;        // integral image for gradient imag};</code></pre><p>———————————————-<font color="red"><strong>THE END!</strong></font>——————————————</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>积分图算法</title>
      <link href="/2020/07/31/%E3%80%90CV%E7%B3%BB%E5%88%97%E3%80%91%E7%A7%AF%E5%88%86%E5%9B%BE%E7%AE%97%E6%B3%95/"/>
      <url>/2020/07/31/%E3%80%90CV%E7%B3%BB%E5%88%97%E3%80%91%E7%A7%AF%E5%88%86%E5%9B%BE%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="0、前言"><a href="#0、前言" class="headerlink" title="0、前言"></a>0、前言</h2><p>&ensp; &ensp;   在求图像直流分量优化过程中，发现了积分图像这个神器。通过利用这个积分图，可以实现任意矩形区域求和运算，效率很高。</p><h2 id="1、参考"><a href="#1、参考" class="headerlink" title="1、参考"></a>1、参考</h2><p><a href="https://blog.csdn.net/wangkexue/article/details/7955406" target="_blank" rel="noopener">OpenCV中Integral Image的源码</a><br><a href="https://blog.csdn.net/myzhouwang/article/details/84641833" target="_blank" rel="noopener">opencv 积分图源码</a><br><a href="https://blog.csdn.net/xiaowei_cqu/article/details/17928733" target="_blank" rel="noopener">【图像处理】快速计算积分图</a><br><a href="https://blog.csdn.net/h763247747/article/details/101615811" target="_blank" rel="noopener">积分图像（Integral image）</a><br><a href="https://www.cnblogs.com/Imageshop/p/6219990.html" target="_blank" rel="noopener">13行代码实现最快速最高效的积分图像算法。</a></p><h2 id="2、积分图是啥？"><a href="#2、积分图是啥？" class="headerlink" title="2、积分图是啥？"></a>2、积分图是啥？</h2><p>在积分图像中，每个点存储的是其左上方所有像素之和。</p><p>如下图所示：<br><img src="https://img-blog.csdnimg.cn/2020073116134826.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NvYXJpbmdMZWVfZmlnaHRpbmc=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="3、积分图能干啥？"><a href="#3、积分图能干啥？" class="headerlink" title="3、积分图能干啥？"></a>3、积分图能干啥？</h2><p>利用积分图可以快速计算求和运算(sum norm)。</p><h2 id="4、积分图怎么用？"><a href="#4、积分图怎么用？" class="headerlink" title="4、积分图怎么用？"></a>4、积分图怎么用？</h2><p>参考Imageshop的实现，show me code：</p><pre><code class="c">void GetGrayIntegralImage(unsigned char *Src, int *Integral, int Width, int Height, int Stride){    memset(Integral, 0, (Width + 1) * sizeof(int));                    //    第一行都为0    for (int Y = 0; Y &lt; Height; Y++)    {        unsigned char *LinePS = Src + Y * Stride;        int *LinePL = Integral + Y * (Width + 1) + 1;                　　//    上一行位置        int *LinePD = Integral + (Y + 1) * (Width + 1) + 1;            //    当前位置，注意每行的第一列的值都为0        LinePD[-1] = 0;                                                //    第一列的值为0        for (int X = 0, Sum = 0; X &lt; Width; X++)        {            Sum += LinePS[X];                                        //    行方向累加            LinePD[X] = LinePL[X] + Sum;                            //    更新积分图        }    }}</code></pre><h2 id="5、OpenCV中积分图实现"><a href="#5、OpenCV中积分图实现" class="headerlink" title="5、OpenCV中积分图实现"></a>5、OpenCV中积分图实现</h2><p><a href="https://blog.csdn.net/qingzhuyuxian/article/details/84584264" target="_blank" rel="noopener">Opencv中integral计算积分图</a></p><p>使用demo代码如下：</p><pre><code class="cpp">#include &quot;highgui/highgui.hpp&quot;#include &quot;imgproc/imgproc.hpp&quot;using namespace cv;int main(int argc,char *argv[]){    Mat image=imread(argv[1]);        //cvtColor(image,image,CV_RGB2GRAY); //原图像是三通道，积分图也是三通道    Mat imageIntegral;    integral(image,imageIntegral,CV_32F); //计算积分图    normalize(imageIntegral,imageIntegral,0,255,CV_MINMAX);  //归一化，方便显示    Mat imageIntegralNorm;    convertScaleAbs(imageIntegral,imageIntegralNorm); //精度转换为8位int整型    imshow(&quot;Source Image&quot;,image);    imshow(&quot;Integral Image&quot;,imageIntegralNorm);    waitKey();}</code></pre><p><img src="https://img-blog.csdnimg.cn/20200731215245144.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NvYXJpbmdMZWVfZmlnaHRpbmc=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>——————————–<font color="red"><strong>THE END!</strong></font>————————————————</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 图像处理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CV </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《亲爱的安德烈》读书笔记</title>
      <link href="/2020/07/25/%E3%80%90Books%E7%B3%BB%E5%88%97%E3%80%91%E3%80%8A%E4%BA%B2%E7%88%B1%E7%9A%84%E5%AE%89%E5%BE%B7%E7%83%88%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
      <url>/2020/07/25/%E3%80%90Books%E7%B3%BB%E5%88%97%E3%80%91%E3%80%8A%E4%BA%B2%E7%88%B1%E7%9A%84%E5%AE%89%E5%BE%B7%E7%83%88%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><p>&ensp; &ensp; 读《亲爱的安德烈》，断断续续已有一月有余，我不喜欢一口气就读完一本书，总是喜欢慢慢读慢慢品，就像在享受读书这个过程一般。这个月慢慢养成了读书的习惯，下班回家洗漱之后，就拿起书看里面的故事，感觉还是比较有趣比较充实的。</p><p><img src="https://img-blog.csdnimg.cn/20200725112532745.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NvYXJpbmdMZWVfZmlnaHRpbmc=,size_16,color_FFFFFF,t_70" alt="《亲爱的安德烈》"></p><h2 id="1、亲子沟通"><a href="#1、亲子沟通" class="headerlink" title="1、亲子沟通"></a>1、亲子沟通</h2><p>&ensp; &ensp; 这本书是两代之间的36封家书，里面讲述了父母与孩子之间交流的很多方面。正如龙应台所言：“我知道他爱我，但是，爱，不等于不喜欢，爱，不等于不认识。爱，其实是很多不喜欢、不认识、不沟通的借口。因为有爱，所以正常的沟通仿佛可以不必了。不，我不要掉进这样的陷阱。”亲子沟通是一件很重要的事情。</p><p>&ensp; &ensp;  读这本书的过程中，很羡慕安德烈是一个很有个人想法的人，也很羡慕他能够如此有耐心地与自己的母亲互通书信。毕竟，在现在这个浮躁的社会上，耐心已是难能可贵。这本书里面讨论的一些话题，也深深引起了我的共鸣，这也许是我们成长过程中要经历的事情吧。</p><h2 id="2、父母"><a href="#2、父母" class="headerlink" title="2、父母"></a>2、父母</h2><p>&ensp; &ensp; 所谓父母，就是那个不断对着背影既欣喜又悲伤、想追回拥抱又不敢声张的人。看到书中的这段话，感觉只有成为父母才会有这样的感受吧。父母对子女的爱是无私的不求回报的爱，也许世上最爱我们的人就是父母吧，想到此刻，我不知道拿什么来回报我的父母？</p><h2 id="3、平庸"><a href="#3、平庸" class="headerlink" title="3、平庸"></a>3、平庸</h2><p>&ensp; &ensp;  关于平庸的对话：对我最重要的，安德烈，不是你是否有成就，而是你是否快乐。而在现代的生活架构里，什么样的工作比较可能给你快乐？第一，它给你意义；第二，它给你时间。你的工作是你觉得有意义的，你的工作绑架你使你成为工作的俘虏，容许你充分体验生活，你就比较可能是快乐的。至于金钱和名声，哪里是快乐的核心元素呢？当你的工作在你心目中有意义，你就有成就感。当你的工作给你时间，不剥夺你的生活，你就有尊严。成就感和尊严，给你快乐。我怕你变成画长颈鹿的提摩，不是因为他没钱没名，而是因为他找不到意义。我也要求你读书用功，不是因为我要你跟别人比成就，而是因为，我希望你将来会拥有选择的权利，选择有意义、有时间的工作，而不是被迫谋生。这段对话深深触动了我，一直思考我想要过什么样的生活？我想要做什么样的工作？是的，有意义和有时间的工作才是值得的。一直以为，人生其实一个不断受锤的过程，我们在锤炼过程中，不断完善；而工作似乎是锤炼的介质，我们打怪升级，完成一个个项目，实现自己的价值。或许，我们终其一生，都在寻找有意义和有时间的工作。</p><h2 id="4、认同"><a href="#4、认同" class="headerlink" title="4、认同"></a>4、认同</h2><p>看到一封关于认同的信，颇有感触：龙应台说：“我们这一代人，因为受过’国家’太多的欺骗，心里有太多的不信任，太多的不屑，太多的不赞成。”所以，在这样的背景和环境下面，我们国家才没有表达自由和民主的游行；但另一方面，作为”愚民”也有好处，至少生活少了很多忧愁，国家给了我们足够的安全感。好了就写这么多吧。</p><p>————————————–<font color="red"><strong>THE END!</strong></font>——————————–</p>]]></content>
      
      
      <categories>
          
          <category> 读书 </category>
          
          <category> 读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Books </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>利用性能分析工具valgrind+KCachegrind分析</title>
      <link href="/2020/07/24/%E3%80%90Tools%E7%B3%BB%E5%88%97%E3%80%91%E5%88%A9%E7%94%A8%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7valgrind+KCachegrind%E5%88%86%E6%9E%90/"/>
      <url>/2020/07/24/%E3%80%90Tools%E7%B3%BB%E5%88%97%E3%80%91%E5%88%A9%E7%94%A8%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7valgrind+KCachegrind%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<p>[toc]</p><h2 id="1、简述"><a href="#1、简述" class="headerlink" title="1、简述"></a>1、简述</h2><p>本文讲述如何应用callgrind和kcachegrind进行性能分析。该工具可以方便分析出可执行文件函数的执行时间及函数调用关系。通过充分利用工具，来提供我们的工作效率。</p><p>主要参考：<a href="https://blog.csdn.net/fengjingge/article/details/41727265" target="_blank" rel="noopener">性能分析工具使用-callgrind+kcachegrind</a></p><h2 id="2、KCachegrind下载"><a href="#2、KCachegrind下载" class="headerlink" title="2、KCachegrind下载"></a>2、KCachegrind下载</h2><p>KCachegrind是个图形化界面，主要用于对callgrind分析来的数据进行可视化。<br><a href="https://sourceforge.net/projects/kcachegrind/" target="_blank" rel="noopener">https://sourceforge.net/projects/kcachegrind/</a></p><p>KCachegrind visualizes traces generated by profiling, including a tree map and a call graph visualization of the calls happening. It’s designed to be fast for very large programs like KDE applications.</p><p>来自 <a href="https://sourceforge.net/projects/kcachegrind/" target="_blank" rel="noopener">https://sourceforge.net/projects/kcachegrind/</a></p><p><a href="http://kcachegrind.sourceforge.net/html/Home.html" target="_blank" rel="noopener">http://kcachegrind.sourceforge.net/html/Home.html</a></p><p><a href="https://kcachegrind.github.io/html/Home.html" target="_blank" rel="noopener">https://kcachegrind.github.io/html/Home.html</a></p><p>Kcachegrind下载：<a href="http://kcachegrind.sourceforge.net/html/Download.html" target="_blank" rel="noopener">http://kcachegrind.sourceforge.net/html/Download.html</a><br>Qcachegrind下载：<a href="https://sourceforge.net/projects/qcachegrindwin/" target="_blank" rel="noopener">https://sourceforge.net/projects/qcachegrindwin/</a></p><h2 id="3、分析过程"><a href="#3、分析过程" class="headerlink" title="3、分析过程"></a>3、分析过程</h2><h3 id="3-1、安装valgrind和KCachegrind"><a href="#3-1、安装valgrind和KCachegrind" class="headerlink" title="3.1、安装valgrind和KCachegrind"></a>3.1、安装valgrind和KCachegrind</h3><p>首先安装valgrind：<a href="https://www.valgrind.org/" target="_blank" rel="noopener">https://www.valgrind.org/</a><br>(1) 获取源代码：wget <a href="http://www.valgrind.org/downloads/valgrind-3.14.0.tar.bz2" target="_blank" rel="noopener">http://www.valgrind.org/downloads/valgrind-3.14.0.tar.bz2</a><br>(2) 解压缩： tar -jxvf valgrind-3.14.0.tar.bz2<br>(3) 进入目录,进行安装,其中/home/user1/valgrind是你想安装的目录</p><pre><code>cd valgrind-3.14.0./configure --prefix=/home/user1/valgrindmakemake install</code></pre><p>(4) 配置环境变量，首先打开~/.bashrc</p><pre><code>vim ~/.bashrcexport PATH=$PATH:~/valgrind/bin/source ~/.bashrc</code></pre><p>然后安装Kcachegrind：</p><p>Kcachegrind下载：<a href="http://kcachegrind.sourceforge.net/html/Download.html" target="_blank" rel="noopener">http://kcachegrind.sourceforge.net/html/Download.html</a></p><h3 id="3-2、利用valgrind生成性能日志"><a href="#3-2、利用valgrind生成性能日志" class="headerlink" title="3.2、利用valgrind生成性能日志"></a>3.2、利用valgrind生成性能日志</h3><pre><code>valgrind --tool=callgrind ./test_demo</code></pre><p><img src="https://img-blog.csdnimg.cn/20200725161616264.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NvYXJpbmdMZWVfZmlnaHRpbmc=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="3-3、利用kcachegrind可视化"><a href="#3-3、利用kcachegrind可视化" class="headerlink" title="3.3、利用kcachegrind可视化"></a>3.3、利用kcachegrind可视化</h3><p><img src="https://img-blog.csdnimg.cn/20200725162043165.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NvYXJpbmdMZWVfZmlnaHRpbmc=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><hr><p> <font color="red"> <strong>THE END!</strong> </font></p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
          <category> 调试工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> valgrind </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用VScode+Anaconda搭建舒服的Python环境</title>
      <link href="/2020/07/19/%E3%80%90Python%E7%B3%BB%E5%88%97%E3%80%91%E4%BD%BF%E7%94%A8VScode+Anaconda%E6%90%AD%E5%BB%BA%E8%88%92%E6%9C%8D%E7%9A%84Python%E7%8E%AF%E5%A2%83/"/>
      <url>/2020/07/19/%E3%80%90Python%E7%B3%BB%E5%88%97%E3%80%91%E4%BD%BF%E7%94%A8VScode+Anaconda%E6%90%AD%E5%BB%BA%E8%88%92%E6%9C%8D%E7%9A%84Python%E7%8E%AF%E5%A2%83/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="1、Visual-Studio-Code"><a href="#1、Visual-Studio-Code" class="headerlink" title="1、Visual Studio Code"></a>1、Visual Studio Code</h2><p>下载地址：<a href="https://code.visualstudio.com/" target="_blank" rel="noopener">https://code.visualstudio.com/</a></p><p>VScode是一款支持多种语言的IDE，是微软大厂开源的一款编辑器软件，界面很清爽也很炫酷，值得尝试。使用Python语言开发多年，一直没有找到比较好用的IDE，发现VS code可以作为开发Python程序的一款轻量级的工具！<br>当然了，开发大型的Python程序，可以选择PyCharm软件，小编目前主要是采用Python语言编写一些自动化测试脚本，使用VS code足矣。</p><h2 id="2、Anaconda"><a href="#2、Anaconda" class="headerlink" title="2、Anaconda"></a>2、Anaconda</h2><p>Anaconda下载：<a href="https://www.anaconda.com/products/individual" target="_blank" rel="noopener">https://www.anaconda.com/products/individual</a></p><p>这里配置anaconda3。</p><h2 id="3、Python-IDE环境搭建"><a href="#3、Python-IDE环境搭建" class="headerlink" title="3、Python IDE环境搭建"></a>3、Python IDE环境搭建</h2><h3 id="3-1、IDE环境配置：采用VScode"><a href="#3-1、IDE环境配置：采用VScode" class="headerlink" title="3.1、IDE环境配置：采用VScode"></a>3.1、IDE环境配置：采用VScode</h3><p>1、安装Python插件<br><img src="https://img-blog.csdnimg.cn/20200719211316703.png" alt="在这里插入图片描述"><br>2、配置python.pythonPath<br>文件—》首选项—-》设置<br><img src="https://img-blog.csdnimg.cn/20200719211612903.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NvYXJpbmdMZWVfZmlnaHRpbmc=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="3-2、调试配置"><a href="#3-2、调试配置" class="headerlink" title="3.2、调试配置"></a>3.2、调试配置</h3><p>1、设置断点<br>2、F5调试</p><h3 id="3-3-配置遇到的bug"><a href="#3-3-配置遇到的bug" class="headerlink" title="3.3  配置遇到的bug"></a>3.3  配置遇到的bug</h3><p>参考：<a href="https://github.com/microsoft/vscode-python/issues/2732" target="_blank" rel="noopener">Timeout waiting for debugger connection</a><br><img src="https://img-blog.csdnimg.cn/20200719213236492.png" alt="在这里插入图片描述"><br>github中说是由于win10系统的更新导致了这个问题，经过半天的折腾，终于找到了一个解决方案：<br>将launch.json中的配置：<br>“console:”: “internalConsole”<br><img src="https://img-blog.csdnimg.cn/20200719213352510.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NvYXJpbmdMZWVfZmlnaHRpbmc=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="4、参考"><a href="#4、参考" class="headerlink" title="4、参考"></a>4、参考</h2><p><a href="https://www.cnblogs.com/v5captain/p/6414177.html" target="_blank" rel="noopener">Anaconda3中Python3.5和Python2.7共存</a><br><a href="https://zhuanlan.zhihu.com/p/30324113" target="_blank" rel="noopener">VS Code + Anaconda打造舒适的Python环境</a><br><a href="https://www.cnblogs.com/Alier/p/6363218.html" target="_blank" rel="noopener">Visual Studio Code搭建python开发环境</a><br><a href="https://blog.csdn.net/Marvellor/article/details/80877201" target="_blank" rel="noopener">vs code 中配置和调试Python脚本</a></p><hr><p>THE END!</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git常用命令</title>
      <link href="/2020/07/11/%E3%80%90Tools%E7%B3%BB%E5%88%97%E3%80%91Git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
      <url>/2020/07/11/%E3%80%90Tools%E7%B3%BB%E5%88%97%E3%80%91Git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><p>一般来说，日常使用只要记住下图6个命令，就可以了。但是熟练使用，恐怕要要记住60~100个命令。<br><img src="https://img-blog.csdnimg.cn/2020060111214194.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NvYXJpbmdMZWVfZmlnaHRpbmc=,size_16,color_FFFFFF,t_70#pic_center" alt="Git使用方法"></p><p>下面整理的 Git 命令清单。几个专业名词的译名如下。</p><pre><code>Workspace：工作区Index / Stage：暂存区Repository：仓库区（本地仓库）Remote：远程仓库</code></pre><h2 id="1、新建版本仓库"><a href="#1、新建版本仓库" class="headerlink" title="1、新建版本仓库"></a>1、新建版本仓库</h2><pre><code># 在当前目录新建一个Git代码库$ git init# 新建一个目录，将其初始化为Git代码库$ git init [project-name]# 下载一个项目和它的整个代码历史, -o 给远程仓库起名:faker,默认origin$ git clone [-o faker] [url]</code></pre><h2 id="2、配置"><a href="#2、配置" class="headerlink" title="2、配置"></a>2、配置</h2><p>Git的设置文件为.gitconfig，它可以在用户主目录下（全局配置），也可以在项目目录下（项目配置）。</p><pre><code># 显示当前的Git配置$ git config --list# 编辑Git配置文件$ git config -e [--global]# 设置提交代码时的用户信息$ git config [--global] user.name &quot;[name]&quot;$ git config [--global] user.email &quot;[email address]&quot;# 设置大小写敏感（windows不区分大小写的解决办法）$ git config core.ignorecase  false</code></pre><h2 id="3、增加-删除文件"><a href="#3、增加-删除文件" class="headerlink" title="3、增加/删除文件"></a>3、增加/删除文件</h2><pre><code># 添加指定文件到暂存区$ git add [file1] [file2] ...# 添加指定目录到暂存区，包括子目录$ git add [dir]# 添加当前目录的所有文件到暂存区$ git add .# 添加每个变化前，都会要求确认# 对于同一个文件的多处变化，可以实现分次提交$ git add -p# 删除工作区文件，并且将这次删除放入暂存区$ git rm [file1] [file2] ...# 停止追踪指定文件，但该文件会保留在工作区$ git rm --cached [file]# 改名文件，并且将这个改名放入暂存区$ git mv [file-original] [file-renamed]</code></pre><h2 id="4、代码提交"><a href="#4、代码提交" class="headerlink" title="4、代码提交"></a>4、代码提交</h2><pre><code># 提交暂存区到仓库区$ git commit -m [message]# 提交暂存区的指定文件到仓库区$ git commit [file1] [file2] ... -m [message]# 提交工作区自上次commit之后的变化，直接到仓库区$ git commit -a# 提交时显示所有diff信息$ git commit -v# 使用一次新的commit，替代上一次提交# 如果代码没有任何新变化，则用来改写上一次commit的提交信息$ git commit --amend -m [message]# 重做上一次commit，并包括指定文件的新变化$ git commit --amend [file1] [file2] ...</code></pre><h2 id="5、分支"><a href="#5、分支" class="headerlink" title="5、分支"></a>5、分支</h2><pre><code># 列出所有本地分支$ git branch# 列出所有远程分支$ git branch -r# 列出所有本地分支和远程分支$ git branch -a# 列出所有本地分支，并展示没有分支最后一次提交的信息$ git branch -v# 列出所有本地分支，并展示没有分支最后一次提交的信息和远程分支的追踪情况$ git branch -vv# 列出所有已经合并到当前分支的分支$ git branch --merged# 列出所有还没有合并到当前分支的分支$ git branch --no-merged# 新建一个分支，但依然停留在当前分支$ git branch [branch-name]# 新建一个分支，并切换到该分支$ git checkout -b [branch]# 新建一个与远程分支同名的分支，并切换到该分支$ git checkout --track [branch-name]# 新建一个分支，指向指定commit$ git branch [branch] [commit]# 新建一个分支，与指定的远程分支建立追踪关系$ git branch --track [branch] [remote-branch]# 切换到指定分支，并更新工作区$ git checkout [branch-name]# 切换到上一个分支$ git checkout -# 建立追踪关系，在现有分支与指定的远程分支之间$ git branch --set-upstream-to=[remote-branch]$ git branch --set-upstream [branch] [remote-branch] # 已被弃用# 合并指定分支到当前分支$ git merge [branch]# 中断此次合并（你可能不想处理冲突）$ git merge --abort# 选择一个commit，合并进当前分支$ git cherry-pick [commit]# 删除分支$ git branch -d [branch-name]#新增远程分支 远程分支需先在本地创建,再进行推送$ git push origin [branch-name]# 删除远程分支$ git push origin --delete [branch-name]$ git branch -dr [remote/branch]</code></pre><h2 id="6、标签"><a href="#6、标签" class="headerlink" title="6、标签"></a>6、标签</h2><pre><code># 列出所有tag$ git tag# 新建一个tag在当前commit$ git tag [tag]# 新建一个tag在指定commit$ git tag [tag] [commit]# 删除本地tag$ git tag -d [tag]# 删除远程tag$ git push origin :refs/tags/[tagName]# 查看tag信息$ git show [tag]# 提交指定tag$ git push [remote] [tag]# 提交所有tag$ git push [remote] --tags# 新建一个分支，指向某个tag$ git checkout -b [branch] [tag]</code></pre><h2 id="7、查看信息-搜索"><a href="#7、查看信息-搜索" class="headerlink" title="7、查看信息/搜索"></a>7、查看信息/搜索</h2><pre><code># 显示有变更的文件$ git status [-sb] #s:short,给一个短格式的展示，b:展示当前分支# 显示当前分支的版本历史$ git log# 显示commit历史，以及每次commit发生变更的文件$ git log --stat# 搜索提交历史，根据关键词$ git log -S [keyword]# 显示某个commit之后的所有变动，每个commit占据一行$ git log [tag] HEAD --pretty=format:%s# 显示某个commit之后的所有变动，其&quot;提交说明&quot;必须符合搜索条件$ git log [tag] HEAD --grep feature# 显示某个文件的版本历史，包括文件改名$ git log --follow [file]$ git whatchanged [file]# 显示指定文件相关的每一次diff$ git log -p [file]# 显示过去5次提交$ git log -5 --pretty --oneline# 图形化显示所有分支$ git log --oneline --graph --all# 显示在分支2而不在分支1中的提交$ git log [分支1]..[分支2]$ git log ^[分支1] [分支2]$ git log [分支2] --not [分支1]# 显示两个分支不同时包含的提交$ git log [分支1]...[分支2]# 显示所有提交过的用户，按提交次数排序$ git shortlog -sn# 显示指定文件是什么人在什么时间修改过$ git blame [file]# 显示暂存区和工作区的差异$ git diff# 显示暂存区和上一个commit的差异$ git diff --cached [file]# 显示工作区与当前分支最新commit之间的差异$ git diff HEAD# 显示两次提交之间的差异$ git diff [first-branch]...[second-branch]# 显示今天你写了多少行代码$ git diff --shortstat &quot;@{0 day ago}&quot;# 显示某次提交的元数据和内容变化$ git show [commit]# 显示某次提交发生变化的文件$ git show --name-only [commit]# 显示某次提交时，某个文件的内容$ git show [commit]:[filename]# 显示当前分支的最近几次提交$ git reflog# 搜索你工作目录的文件，输出匹配行号$ git grep -n [关键字]# 搜索你工作目录的文件，输出每个文件包含多少个匹配$ git grep --count [关键字]# 优化阅读$ git grep --break --heading [关键字]# 查询iCheck这个字符串那次提交的$ git log -SiCheck --oneline# 查询git_deflate_bound函数每一次的变更$ git log -L :git_deflate_bound:zlib.c</code></pre><h2 id="8、远程同步"><a href="#8、远程同步" class="headerlink" title="8、远程同步"></a>8、远程同步</h2><pre><code># 下载远程仓库的所有变动 [shortname] 为远程仓库的shortname, 如origin,为空时:默认origin$ git fetch [shortname]# 显示所有远程仓库$ git remote -v#显式地获得远程引用的完整列表 [shortname] 为远程仓库的shortname, 如origin,为空时:默认origin$ git ls-remote [shortname]# 显示某个远程仓库的信息 [remote] 为远程仓库的shortname, 如origin$ git remote show [shortname]# 增加一个新的远程仓库，并命名$ git remote add [shortname] [url]# 重命名一个远程仓库（shortname）$ git remote rename [旧仓库名] [新仓库名]# 删除一个远程链接$ git remote rm [shortname] [url]$ git remote remove [shortname] [url]# 修改远程仓库地址$ git remote set-url [shortname] [url]# 取回远程仓库的变化，并与本地分支合并$ git pull [remote] [branch]# 上传本地当前分支到远程仓库git push [remote]# 上传本地指定分支到远程仓库$ git push [remote] [branch]# 推送所有分支到远程仓库$ git push [remote] --all# 强行推送当前分支到远程仓库，即使有冲突$ git push [remote] --force</code></pre><h2 id="9、撤销"><a href="#9、撤销" class="headerlink" title="9、撤销"></a>9、撤销</h2><pre><code># 恢复暂存区的指定文件到工作区$ git checkout [file]# 恢复某个commit的指定文件到暂存区和工作区$ git checkout [commit] [file]# 恢复暂存区的所有文件到工作区$ git checkout .# 只会保留源码（工作区），回退commit(本地仓库)与index（暂存区）到某个版本$ git reset &lt;commit_id&gt;   #默认为 --mixed模式$ git reset --mixed &lt;commit_id&gt;# 保留源码（工作区）和index（暂存区），只回退commit（本地仓库）到某个版本$ git reset --soft &lt;commit_id&gt;# 源码（工作区）、commit（本地仓库）与index（暂存区）都回退到某个版本$ git reset --hard &lt;commit_id&gt;# 恢复到最后一次提交的状态$ git reset --hard HEAD# 新建一个commit，用来撤销指定commit# 后者的所有变化都将被前者抵消，并且应用到当前分支$ git revert [commit]# 将工作区和暂存区的代码全都存储起来了$ git stash [save]# 只保存工作区，不存储暂存区$ git stash --keep-index# 存储工作区、暂存区和未跟踪文件$ git stash -u$ git stash --include-untracked# 不存储所有改动的东西，但会交互式的提示那些改动想要被储藏、哪些改动需要保存在工作目录中$ git stash --patch# 不指定名字，Git认为指定最近的储藏，将存储的代码（工作区和暂存区）都应用到工作区$ git stash apply [stash@{2}]# 存储的工作区和暂存区的代码应用到工作区和暂存区$ git stash apply [stash@{2}] --index# 将存储的代码（工作区和暂存区）都应用到工作区，并从栈上扔掉他$ git stash pop# 删除stash@{2}的存储$ git stash drop [stash@{2}]# 获取储藏的列表$ git stash list# 移除工作目录中所有未跟踪的文件及口口那个的子目录，不会移除.gitiignore忽略的文件$ git clean -f -d</code></pre><h2 id="10、其他"><a href="#10、其他" class="headerlink" title="10、其他"></a>10、其他</h2><pre><code># 生成一个可供发布的压缩包$ git archive</code></pre>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>gitalk评论报错Error_Validation_Failed</title>
      <link href="/2020/07/11/%E3%80%90Tools%E7%B3%BB%E5%88%97%E3%80%91gitalk%E8%AF%84%E8%AE%BA%E6%8A%A5%E9%94%99Error_Validation_Failed/"/>
      <url>/2020/07/11/%E3%80%90Tools%E7%B3%BB%E5%88%97%E3%80%91gitalk%E8%AF%84%E8%AE%BA%E6%8A%A5%E9%94%99Error_Validation_Failed/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h1 id="1、参考"><a href="#1、参考" class="headerlink" title="1、参考"></a>1、参考</h1><p><a href="https://www.cnblogs.com/mart1n/p/10389663.html" target="_blank" rel="noopener">gittalk报错Error</a><br><a href="https://blog.csdn.net/weiwosuoai/article/details/90573929" target="_blank" rel="noopener">如何通过Gitalk评论插件，5分钟为你的博客快速集成评论功能</a><br><a href="https://www.cnblogs.com/JosonLee/p/10053715.html" target="_blank" rel="noopener">Hexo添加gitalk评论插件</a><br><a href="https://blog.csdn.net/death05/article/details/83618887" target="_blank" rel="noopener">gitalk Error: Validation Failed</a></p><h1 id="2、问题描述"><a href="#2、问题描述" class="headerlink" title="2、问题描述"></a>2、问题描述</h1><p><img src="https://img-blog.csdnimg.cn/20200711161549491.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NvYXJpbmdMZWVfZmlnaHRpbmc=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200711161457741.png" alt="在这里插入图片描述"></p><h1 id="3、问题原因"><a href="#3、问题原因" class="headerlink" title="3、问题原因"></a>3、问题原因</h1><p><a href="https://github.com/gitalk/gitalk/issues/102" target="_blank" rel="noopener">报错出现 Error: Validation Failed. #102</a><br>这是由于 Github 限制 labal 长度不能超过 50 引起的问题。</p><h1 id="4、解决方案"><a href="#4、解决方案" class="headerlink" title="4、解决方案"></a>4、解决方案</h1><p>网上出现了很多针对这个问题的解决方案，比如采用md5处理，更多参考：<br><a href="https://github.com/gitalk/gitalk/issues/102" target="_blank" rel="noopener">报错出现 Error: Validation Failed. #102</a></p><p>个人认为比较好的一种解决方案：<br><a href="https://github.com/gitalk/gitalk/issues/378" target="_blank" rel="noopener">解决label 长度50的一种方法 #378</a><br><img src="https://img-blog.csdnimg.cn/2020071116050157.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NvYXJpbmdMZWVfZmlnaHRpbmc=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>终于，对于比较长的中文tilte，gitalk也是可以的了！<br><img src="https://img-blog.csdnimg.cn/20200711161422653.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NvYXJpbmdMZWVfZmlnaHRpbmc=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><font color="red">THE END!</font></p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSConvertKit&amp;YUVProcessKit</title>
      <link href="/2020/07/07/%E3%80%90%E5%B7%A5%E7%A8%8B%E5%8C%96%E7%B3%BB%E5%88%97%E3%80%91CSConvertKit&amp;YUVProcessKit/"/>
      <url>/2020/07/07/%E3%80%90%E5%B7%A5%E7%A8%8B%E5%8C%96%E7%B3%BB%E5%88%97%E3%80%91CSConvertKit&amp;YUVProcessKit/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h1 id="1、CSConvertKit"><a href="#1、CSConvertKit" class="headerlink" title="1、CSConvertKit"></a>1、CSConvertKit</h1><p>CSConvertKit：CSConvertKit is a series of projects for Converting YUV colorspace, such as YUV420P(I420,YV12),YUV420SP(NV21,NV12), NV16, RGB24, BGR24, YUV422P, YUV444 and so on.</p><p>开源地址：<a href="https://github.com/soaringleefighting/CSConvertKit.git" target="_blank" rel="noopener">https://github.com/soaringleefighting/CSConvertKit.git</a></p><h1 id="2、YUVProcessKit"><a href="#2、YUVProcessKit" class="headerlink" title="2、YUVProcessKit"></a>2、YUVProcessKit</h1><p>YUVProcessKit： YUVProcessKit is a series of projects for Processing YUV sequences, such as horizontal combiner, compare, connect, extract, scale and split and so on.</p><p>开源地址： <a href="https://github.com/soaringleefighting/YUVProcessKit.git" target="_blank" rel="noopener">https://github.com/soaringleefighting/YUVProcessKit.git</a></p><p><font color="red">THE END!</font></p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 开源项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> YUV </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>编解码一致性和性能测试脚本autoCodecTest</title>
      <link href="/2020/07/07/%E3%80%90%E5%B7%A5%E7%A8%8B%E5%8C%96%E7%B3%BB%E5%88%97%E3%80%91%E7%BC%96%E8%A7%A3%E7%A0%81%E4%B8%80%E8%87%B4%E6%80%A7%E5%92%8C%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%E8%84%9A%E6%9C%ACautoCodecTest/"/>
      <url>/2020/07/07/%E3%80%90%E5%B7%A5%E7%A8%8B%E5%8C%96%E7%B3%BB%E5%88%97%E3%80%91%E7%BC%96%E8%A7%A3%E7%A0%81%E4%B8%80%E8%87%B4%E6%80%A7%E5%92%8C%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%E8%84%9A%E6%9C%ACautoCodecTest/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h1 id="1、autoCodecTest"><a href="#1、autoCodecTest" class="headerlink" title="1、autoCodecTest"></a>1、autoCodecTest</h1><p>AutoCodecTest: This is a codecs coherence and performance test script.</p><p>开源地址： <a href="https://github.com/soaringleefighting/autoCodecTest.git" target="_blank" rel="noopener">https://github.com/soaringleefighting/autoCodecTest.git</a></p><p>一、Shell脚本：Linux(ARM)平台<br>说明：编解码器在开发过程中，通常需要和标准或参考编解码进行对比以验证编解码一致性，以及测试测试编解码的性能。该脚本可用于在Linux平台、arm平台上对编解码器单独编解码或者用于一致性验证和性能测试。</p><p>二、Python脚本：Windows平台、Linux(ARM)平台<br>1、支持批量进行编码或解码；<br>2、支持对编解码的性能进行数据统计；<br>3、支持对编解码进行一致性验证；<br>4、支持对待验证编解码器进行valgrind内存检查；<br>5、支持gprof。</p><p><font color="red">THE END!</font></p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 开源项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Codec </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>H.263&amp;H.263+标准研究总结</title>
      <link href="/2020/07/06/%E3%80%90Codecs%E7%B3%BB%E5%88%97%E3%80%91H.263_H.263+%E6%A0%87%E5%87%86%E7%A0%94%E7%A9%B6%E6%80%BB%E7%BB%93/"/>
      <url>/2020/07/06/%E3%80%90Codecs%E7%B3%BB%E5%88%97%E3%80%91H.263_H.263+%E6%A0%87%E5%87%86%E7%A0%94%E7%A9%B6%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p>﻿[TOC]</p><h2 id="1-H-263相关资料路径"><a href="#1-H-263相关资料路径" class="headerlink" title="1.   H.263相关资料路径"></a>1.   H.263相关资料路径</h2><p>1）、H.263官方标准下载</p><p><a href="https://www.itu.int/rec/T-REC-H.263-199603-S/en" target="_blank" rel="noopener">https://www.itu.int/rec/T-REC-H.263-199603-S/en</a></p><p>2）、H.263标准相关文献</p><p>H.263: video coding for low-bit-rate<br>communication：<a href="https://sci-hub.tw/10.1109/35.556485" target="_blank" rel="noopener">https://sci-hub.tw/10.1109/35.556485</a></p><p><a href="https://docs.microsoft.com/en-us/windows-hardware/drivers/display/itu-t-h-263" target="_blank" rel="noopener">https://docs.microsoft.com/en-us/windows-hardware/drivers/display/itu-t-h-263</a></p><p>3）、H.263+相关</p><p>H.263+: the new ITU-T Recommendation for<br>video coding at low bit rates</p><p><a href="https://ieeexplore.ieee.org/document/679710" target="_blank" rel="noopener">https://ieeexplore.ieee.org/document/679710</a></p><p>H.263+: video coding at low bit rates</p><p><a href="https://pdfs.semanticscholar.org/5e5e/8a4940c796a161f994b15a4fa321e5b86705.pdf" target="_blank" rel="noopener">https://pdfs.semanticscholar.org/5e5e/8a4940c796a161f994b15a4fa321e5b86705.pdf</a></p><p>4）、H.263与H.261比较</p><p>Comparison of the H.263 and H.261 video<br>compression standards</p><p><a href="https://ui.adsabs.harvard.edu/abs/1995SPIE10282E..0DG/abstract" target="_blank" rel="noopener">https://ui.adsabs.harvard.edu/abs/1995SPIE10282E..0DG/abstract</a></p><p>5）、H.263++相关</p><p><a href="https://www.itu.int/rec/T-REC-H.263-200011-S!AnnU/en" target="_blank" rel="noopener">https://www.itu.int/rec/T-REC-H.263-200011-S!AnnU/en</a></p><p><a href="https://www.itu.int/rec/T-REC-H.263-200011-S!AnnV/en" target="_blank" rel="noopener">https://www.itu.int/rec/T-REC-H.263-200011-S!AnnV/en</a></p><p><a href="https://www.itu.int/rec/T-REC-H.263-200011-S!AnnW/en" target="_blank" rel="noopener">https://www.itu.int/rec/T-REC-H.263-200011-S!AnnW/en</a></p><p>关于H.263和H.263+编码技术：<a href="http://www.txrzx.com/i2708-0.html" target="_blank" rel="noopener">http://www.txrzx.com/i2708-0.html</a></p><h2 id="2-H-263核心编码技术"><a href="#2-H-263核心编码技术" class="headerlink" title="2.   H.263核心编码技术"></a>2.   H.263核心编码技术</h2><p>H.263编码采用了基于运动补偿的帧间预测和DCT变换的混合编码框架，相比于H.261进行了局部算法改进和引入了可选的高级编码选项，提高了压缩效率和容错性，适用于低比特率编码的视频会议和可视话机的应用场景。</p><p>H.263标准包括如下的4个核心编码技术：</p><p>（1）  基于运动补偿的帧间预测</p><p>（2） DCT变换编码</p><p>（3）量化</p><p>（4） 熵编码</p><p>下面在详细讲解这4个核心编码技术之前，先看一下码流结构和编解码框架。</p><h3 id="2-1-码流结构（图像结构）"><a href="#2-1-码流结构（图像结构）" class="headerlink" title="2.1. 码流结构（图像结构）"></a>2.1. 码流结构（图像结构）</h3><p>H.263采用分层结构的方式组织码流，如下图所示。<br><img src="https://img-blog.csdnimg.cn/20200527090957968.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NvYXJpbmdMZWVfZmlnaHRpbmc=,size_16,color_FFFFFF,t_70" alt="H.263码流结构"></p><p>（1）    图像层Picture：<br><img src="https://img-blog.csdnimg.cn/20200527091003249.png" alt="图像层"></p><p>（2）    块组层GOB:</p><p><img src="https://img-blog.csdnimg.cn/20200527091007157.png" alt="块组层"></p><p>（3）    宏块层Macroblock:<br><img src="https://img-blog.csdnimg.cn/2020052709101181.png" alt="宏块层"></p><p>（4）    块层Block：</p><p><img src="https://img-blog.csdnimg.cn/20200527091014419.png" alt="块层"></p><h3 id="2-2-编解码框架"><a href="#2-2-编解码框架" class="headerlink" title="2.2. 编解码框架"></a>2.2. 编解码框架</h3><p><img src="https://img-blog.csdnimg.cn/20200527091030906.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NvYXJpbmdMZWVfZmlnaHRpbmc=,size_16,color_FFFFFF,t_70" alt="编解码框架"></p><p>图 H.263编码流程</p><h3 id="2-3-预测编码"><a href="#2-3-预测编码" class="headerlink" title="2.3. 预测编码"></a>2.3. 预测编码</h3><p>使用时域预测的模式称为INTER模式，不使用时域预测的模式称为INTRA模式。</p><p>注：INTRA编码模式可以使用在图像级（I帧的INTRA或者P帧的INTER）或者P帧中的宏块。</p><p>支持5种图像分辨率：sub-QCIF(128x96)，QCIF(176x144)，CIF（352x288），4CIF(704x576)和16CIF(1408x1152)。编码配置在语法PTYPE中。</p><h4 id="2-3-1-宏块划分方式"><a href="#2-3-1-宏块划分方式" class="headerlink" title="2.3.1. 宏块划分方式"></a>2.3.1. 宏块划分方式</h4><p>帧内编码以16x16宏块为单位进行，没有像素域预测。</p><p>帧间编码以16x16宏块为单位进行，采用时域预测。</p><h4 id="2-3-2-运动补偿精度和半像素插值"><a href="#2-3-2-运动补偿精度和半像素插值" class="headerlink" title="2.3.2. 运动补偿精度和半像素插值"></a>2.3.2. 运动补偿精度和半像素插值</h4><p>（1） 运动补偿精度</p><p>H.263支持半像素精度的运动估计和运动补偿，通过运动补偿的帧间预测来降低时域冗余。</p><p>在可选的PB帧模式中，B帧中的模式都是INTER模式。B帧是部分双向预测的。（此处如何理解？）====》参考Annex G（PB帧预测模式）</p><p>理解：在PB帧预测模式中，B帧预测可以是双向预测，也可以是前向预测。</p><p>（2） 半像素预测插值</p><p>半像素精度的值通过双线性插值获得，如下图所示：<br><img src="https://img-blog.csdnimg.cn/20200527091056927.png" alt="半像素预测插值"></p><h4 id="2-3-3-亮度MV获取"><a href="#2-3-3-亮度MV获取" class="headerlink" title="2.3.3. 亮度MV获取"></a>2.3.3. 亮度MV获取</h4><p>MV=MVP+MVD（MVD在码流中传输，通过VLC解码得到），MVD的VLC表部分如下：<br><img src="https://img-blog.csdnimg.cn/20200527091141773.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NvYXJpbmdMZWVfZmlnaHRpbmc=,size_16,color_FFFFFF,t_70" alt="VLC"></p><ul><li>相邻块可用性：</li></ul><p>对于在当前GOB或者图像边界的情况，相邻块可用性按照如下顺序进行判定：</p><p>（1）    当对应宏块采用INTRA编码模式或者不编码（COD=1）,则候选预测MV为(0, 0)；</p><p>（2）    当对应宏块超出图像边界（左边块），则候选预测MV1设置为(0, 0)；</p><p>（3）    如果对应宏块超出图像边界（上边块和右上块）或者GOB边界，则候选预测预测MV2和MV3设置为MV1；</p><p>（4）    如果对应宏块超出图像边界（右边），则候选预测MV3为(0, 0)。</p><ul><li>MVP获取过程：</li></ul><p><img src="https://img-blog.csdnimg.cn/20200527091216559.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NvYXJpbmdMZWVfZmlnaHRpbmc=,size_16,color_FFFFFF,t_70" alt="MVP获取过程"></p><p>说明：当前MV的预测运动矢量MVP采用三个候选预测运动矢量的中值。</p><h4 id="2-3-4-色度MV获取"><a href="#2-3-4-色度MV获取" class="headerlink" title="2.3.4. 色度MV获取"></a>2.3.4. 色度MV获取</h4><p>色度MV是亮度MV除以2即可。</p><p>生成的四分之一像素精度矢量的分量值修改成接近半像素位置，如下表所示：</p><p>（为什么要对色度MV进行修正？）</p><p>理解：<br><img src="https://img-blog.csdnimg.cn/20200527091235629.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200527091238769.png" alt="在这里插入图片描述"></p><h4 id="2-3-5-参考帧获取"><a href="#2-3-5-参考帧获取" class="headerlink" title="2.3.5. 参考帧获取"></a>2.3.5. 参考帧获取</h4><p>H.263中的P帧的参考帧只支持前向单参考，即当前解码P帧参考前一帧解码的P帧或者I帧。</p><h3 id="2-4-分块DCT变换"><a href="#2-4-分块DCT变换" class="headerlink" title="2.4. 分块DCT变换"></a>2.4. 分块DCT变换</h3><h4 id="2-4-1-DCT变换"><a href="#2-4-1-DCT变换" class="headerlink" title="2.4.1. DCT变换"></a>2.4.1. DCT变换</h4><p>采用通用的DCT变换算法，需要注意精度要求（具体参见Annex A）。</p><p>inverse transform mismatch error</p><p>DCT变换以8x8块为单位进行，反变换公式如下：<br><img src="https://img-blog.csdnimg.cn/20200527091301966.png" alt="反变换"></p><h4 id="2-4-2-范围限制"><a href="#2-4-2-范围限制" class="headerlink" title="2.4.2. 范围限制"></a>2.4.2. 范围限制</h4><p>反变换后的像素取值范围为[-256, +255]。</p><h3 id="2-5-量化-反量化"><a href="#2-5-量化-反量化" class="headerlink" title="2.5. 量化/反量化"></a>2.5. 量化/反量化</h3><h4 id="2-5-1-量化"><a href="#2-5-1-量化" class="headerlink" title="2.5.1. 量化"></a>2.5.1. 量化</h4><p>The quantizers consist of equally spaced reconstruction levels<br>with a dead zone centered at zero.</p><p>量化参数取值为1-31。</p><p>每个宏块采用相同的量化步长，帧内DC块的量化步长为8，其他系数的量化步长为2到62。(同H.261标准)</p><p>注：关于量化死区的理解：量化后为0的区域称为量化死区dead-zone</p><p><strong>H.263量化方法：</strong></p><ul><li>帧内DC系数： F’’[0][0] = dc_scaler * QF[0][0]，其中dc_scaler为8。</li></ul><ul><li>其他系数：量化参数quantiser_scale是从1到2^(<br>quant_precision-1)的整数，量化步长是quantiser_scale的两倍，此处quant_precision为6，量化步长为2~62的偶数。</li></ul><p>特别注意：宏块中的除了帧内DC系数外的所有系数采用相同的量化步长。</p><h4 id="2-5-2-反量化"><a href="#2-5-2-反量化" class="headerlink" title="2.5.2. 反量化"></a>2.5.2. 反量化</h4><p>（1）帧内DC系数反量化：乘以8<br><img src="https://img-blog.csdnimg.cn/2020052709141348.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NvYXJpbmdMZWVfZmlnaHRpbmc=,size_16,color_FFFFFF,t_70" alt="反量化"></p><p>（2）其他系数的反量化：</p><p>反量化公式如下：</p><p>|REC| = QUANT · (2 · |LEVEL| + 1) if QUANT = “odd”</p><p>|REC| = QUANT · (2 · |LEVEL| + 1) – 1 if QUANT = “even”</p><p>REC = sign(LEVEL) · |REC|</p><h4 id="2-5-3-范围限制"><a href="#2-5-3-范围限制" class="headerlink" title="2.5.3. 范围限制"></a>2.5.3. 范围限制</h4><p>反量化后的残差系数的取值范围被限制到[-2048, 2047]。</p><h3 id="2-6-熵编码"><a href="#2-6-熵编码" class="headerlink" title="2.6. 熵编码"></a>2.6. 熵编码</h3><p>H.263标准支持可变长编码3D-VLC（LAST, RUN, LEVEL）。</p><p>注：标准中一些句法的VLC解析都是采用查表的方式进行的。</p><h3 id="2-7-扫描方式"><a href="#2-7-扫描方式" class="headerlink" title="2.7. 扫描方式"></a>2.7. 扫描方式</h3><p>针对量化后的变换系数按照8x8块大小采用Zigzag扫描方式将二维残差矩阵转换为一维扫描系数。</p><p>目的：通过Zigzag重排量化后的变换系数，有利于采用游程编码和变长编码，进一步降低空间冗余和统计冗余。</p><p>如下所示：<br><img src="https://img-blog.csdnimg.cn/20200527091440290.png" alt="扫描"></p><h3 id="2-8-块的重建"><a href="#2-8-块的重建" class="headerlink" title="2.8. 块的重建"></a>2.8. 块的重建</h3><p>（1）    重建：</p><ul><li><p>对于INTRA块： 重建值=反变换后的残差值</p></li><li><p>对于INTER块： 重建值=反变换后的残差值+预测值</p></li></ul><p>（2）    范围限制Clipping:</p><p>对重建值的取值范围限制在[0,255]。</p><h2 id="3-H-263标准可选编码选项"><a href="#3-H-263标准可选编码选项" class="headerlink" title="3.   H.263标准可选编码选项"></a>3.   H.263标准可选编码选项</h2><ul><li><p>Annex D: 无限制运动矢量模式UMV</p></li><li><p>Annex E: 基于句法的算术编码模式SAC</p></li><li><p>Annex F: 高级预测模式（OBMC，Inter4V）</p></li><li><p>Annex G: PB帧模式</p></li></ul><h3 id="3-1-无限制运动矢量模式UMV"><a href="#3-1-无限制运动矢量模式UMV" class="headerlink" title="3.1. 无限制运动矢量模式UMV"></a>3.1. 无限制运动矢量模式UMV</h3><p>在这种模式下，运动矢量可以指向图像边界的外面。使用图像边界上的像素来填充扩充边界的像素。此时，MV的范围从[-16,+15.5]扩展到了[-31.5, +31.5]。</p><p>优点：这种模式对于存在跨图像边界的运动情况（比如相机移动）的编码效率很高，尤其对于小的图像分辨率。</p><h3 id="3-2-基于句法的算术编码模式SAC"><a href="#3-2-基于句法的算术编码模式SAC" class="headerlink" title="3.2. 基于句法的算术编码模式SAC"></a>3.2. 基于句法的算术编码模式SAC</h3><p>使用基于句法的算术编码模式，压缩效率要高于可变长编码VLC，但编码复杂度要高很多。</p><p>具体结合实现进行理解？注意是基于句法，不是基于概率。</p><h3 id="3-3-高级预测模式"><a href="#3-3-高级预测模式" class="headerlink" title="3.3. 高级预测模式"></a>3.3. 高级预测模式</h3><ul><li>OBMC： Overlapped Block Motion Compensation</li></ul><p>采用OBMC在提高预测精度的同时还可以减少块效应。</p><p>核心思想：对于块的上半部分的像素使用当前块上面块的运动矢量；对于块的左半部分的像素使用当前块左边块的运动矢量。对于8x8块的预测，OBMC使用了3个运动矢量。</p><p>p(i, j) = (q(i, j) × H0(i, j) + r(i, j) × H1(i, j) + s(i, j) × H2(i, j) + 4) / 8，</p><p>q(i, j) = p(i + MV0,x, j + MV0,y)</p><p>r(i, j) = p(i + MV1,x, j + MV1,y)</p><p>s(i, j) = p(i + MV2,x, j + MV2,y)</p><p>其中q,r,s表示参考像素，MV0表示当前块的运动矢量，MV1表示上边块或下边块的运动矢量，MV2表示左边块或右边块的运动矢量，H0，H1和H2表示加权矩阵。</p><ul><li>Inter4V: 对于一些宏块，采用4个8x8大小的运动矢量。</li></ul><h3 id="3-4-PB帧模式"><a href="#3-4-PB帧模式" class="headerlink" title="3.4. PB帧模式"></a>3.4. PB帧模式</h3><p>PB帧模式就是将P帧和B帧两帧图像编码为一个单元。 如下图所示：<br><img src="https://img-blog.csdnimg.cn/20200527091610308.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NvYXJpbmdMZWVfZmlnaHRpbmc=,size_16,color_FFFFFF,t_70" alt="PB帧模式"></p><p>PB帧的编码模式INTRA具有如下含义：</p><p>（1）    P块是INTRA编码</p><p>（2）    B块是INTER编码，并使用了对INTER块的预测。</p><h4 id="3-4-1-PB中块层的组织"><a href="#3-4-1-PB中块层的组织" class="headerlink" title="3.4.1. PB中块层的组织"></a>3.4.1. PB中块层的组织</h4><p>在PB帧模式中，一个宏块中包含12个块（6个P块和6个B块）。B帧和P帧量化后的DCT系数是交织存放在一个宏块中。先存放P帧宏块，再存放B帧宏块。</p><h4 id="3-4-2-PB帧中B帧MV的计算"><a href="#3-4-2-PB帧中B帧MV的计算" class="headerlink" title="3.4.2. PB帧中B帧MV的计算"></a>3.4.2. PB帧中B帧MV的计算</h4><p>假设P帧中对应块的运动矢量为MV，则B帧中宏块的前向运动矢量MVF和MVB是由MV和一个delta矢量（由句法MVDB给出）计算得到的。</p><p>MVF = (TRB × MV) / TRD + MVD</p><p>MVB = ((TRB – TRD) × MV) / TRD    if MVD is equal to 0</p><p>MVB = MVF – MV<br>if MVD is unequal to 0</p><h4 id="3-4-3-PB帧中B块的预测"><a href="#3-4-3-PB帧中B块的预测" class="headerlink" title="3.4.3. PB帧中B块的预测"></a>3.4.3. PB帧中B块的预测</h4><p>在解码端，P宏块首先被解码出来，</p><p>假设P宏块的重建块为PREC，</p><ul><li><p>对于后向运动矢量MVB指向PREC 的内部的像素，采用双向预测；</p></li><li><p>对于所有的其他像素，采用前向预测。</p></li></ul><h4 id="3-4-4-PB帧模式的优点"><a href="#3-4-4-PB帧模式的优点" class="headerlink" title="3.4.4. PB帧模式的优点"></a>3.4.4. PB帧模式的优点</h4><p>可以在增加较少比特数的情况下增加帧率。</p><h2 id="4-H-263-标准可选编码选项"><a href="#4-H-263-标准可选编码选项" class="headerlink" title="4.   H.263+标准可选编码选项"></a>4.   H.263+标准可选编码选项</h2><p>H.263+标准是H.263标准的第二个版本，H.263 version2，相比于H.263，在压缩性能、包网络支持、视频格式的扩展支持和其他新功能上更加完善和优越。</p><p>在H.263基础上增加12种可选编码模式：</p><h3 id="4-1-无限制运动矢量模式"><a href="#4-1-无限制运动矢量模式" class="headerlink" title="4.1. 无限制运动矢量模式"></a>4.1. 无限制运动矢量模式</h3><p>无限制运动矢量模式（Unrestricted Motion Vector Mode）</p><p>(1)  Mvd的编码方式不同于H.263</p><p>new reversible VLC’s (RVLC’s) are used for encoding the difference motion vectors. These</p><p>codes are single valued, as opposed to the earlier H.263 VLC’s which were double valued.</p><p>(2)  MV的范围扩展到了[-256, +255.5]（H.263中是[-31.5, +31.5]）</p><h3 id="4-2-高级帧内编码模式"><a href="#4-2-高级帧内编码模式" class="headerlink" title="4.2. 高级帧内编码模式"></a>4.2. 高级帧内编码模式</h3><p>高级帧内编码模式（Advanced Intra Coding Mode）</p><p>（1）支持三种预测模式：DC模式、水平预测模式和垂直预测模式。</p><p>（2）并且针对采用不同预测模式的残差块系数采用不同的扫描方式：</p><ul><li><p>DC预测采用基本的Zigzag扫描；</p></li><li><p>水平预测采用垂直交替扫描方式（同Mpeg2标准）</p></li><li><p>垂直预测采用水平交替扫描方式。</p></li></ul><p>（3）针对帧内编码块，采用单独的VLC表（即针对帧内和帧间残差系数分别采用不同的VLC表）。</p><h3 id="4-3-去块滤波模式"><a href="#4-3-去块滤波模式" class="headerlink" title="4.3. 去块滤波模式"></a>4.3. 去块滤波模式</h3><p>去块滤波模式（Deblocking Filter Mode）</p><p>（1）    针对8x8块的边界进行滤波，先水平方向，然后垂直方向；</p><p>（2）    滤波系数的选择与量化步长有关系，量化越粗糙，滤波系数就越大。</p><h3 id="4-4-Slice结构模式"><a href="#4-4-Slice结构模式" class="headerlink" title="4.4. Slice结构模式"></a>4.4. Slice结构模式</h3><p>Slice结构模式（Slice Structured Mode）</p><p>不同于GOB结构，可以将图像分割成包含可变数目宏块的片段。</p><p>H.263+标准首次引入Slice片的技术。</p><p>优点：</p><p>（1）    增加对于不同环境和应用的的灵活性</p><p>（2）    Slice头可以作为同步点，实现在比特错误或者丢包情况下的解码恢复。</p><h3 id="4-5-SEI模式"><a href="#4-5-SEI模式" class="headerlink" title="4.5. SEI模式"></a>4.5. SEI模式</h3><p>SEI模式（Supplemente Enhancement Information Mode）</p><p>提供显示相关特性的信息，比如图像冻结，图像截图，视频分割等。</p><h3 id="4-6-改善的PB帧模式"><a href="#4-6-改善的PB帧模式" class="headerlink" title="4.6. 改善的PB帧模式"></a>4.6. 改善的PB帧模式</h3><p>改善的PB帧模式（Improved PB-Frames Mode）</p><p>PB帧中B块的预测支持双向模式、前向模式和后向模式。</p><p>后向模式预测没有mv?</p><ul><li><p>双向模式：与H.263中的PB帧模式基本一样，不同的是H.263+中不需要传输delta vector；</p></li><li><p>前向模式：采用前一个P宏块进行预测，需要传输一个前向MV;</p></li><li><p>后向模式：预测块就是“未来的”P宏块，因此不需要传输MV。</p></li></ul><h3 id="4-7-参考帧选择模式"><a href="#4-7-参考帧选择模式" class="headerlink" title="4.7. 参考帧选择模式"></a>4.7. 参考帧选择模式</h3><p>参考帧选择模式（Reference Picture Selection Mode）</p><p>目的：减少错误传播，增加容错机制</p><p>实现方式：在解码端需要存储多个参考帧，在编码码流中会指定选择的参考帧。通过这种模式可以选择用于预测的参考帧，减少时域错误传播。</p><h3 id="4-8-可分级编码"><a href="#4-8-可分级编码" class="headerlink" title="4.8. 可分级编码"></a>4.8. 可分级编码</h3><p>可分级编码（Temporal,SNR and Spatial Scalability Mode）</p><p>（1）    时域可分级：</p><ul><li><p>功能：通过增加显示帧率来增强感知质量。</p></li><li><p>实现方式：通过插入B帧实现。其中B帧属于增强层，IPPP属于基本层。如下图所示：<br><img src="https://img-blog.csdnimg.cn/20200527091832949.png" alt="在这里插入图片描述"></p></li></ul><p>（2）    空域可分级：</p><ul><li><p>功能：生成多分辨率的码流，实现不同显示需求或限制。</p></li><li><p>实现方式：在本质上和SNR可分级一样，通过在增强层提供更高分辨率的编码图像。      </p></li></ul><p><img src="https://img-blog.csdnimg.cn/20200527091837558.png" alt="在这里插入图片描述"></p><p>（3）    SNR可分级：</p><ul><li><p>功能：生成多比特率的码流。</p></li><li><p>实现方式：通过在增强层采用更好的量化器来编码差值图像。</p></li></ul><p>如下图所示：<br><img src="https://img-blog.csdnimg.cn/20200527091841786.png" alt="在这里插入图片描述"></p><h3 id="4-9-降分辨率更新模式"><a href="#4-9-降分辨率更新模式" class="headerlink" title="4.9. 降分辨率更新模式"></a>4.9. 降分辨率更新模式</h3><p>通过低分辨率图像编码和更新信息生成高分辨率图像。适用于背景复杂的快速运动场景。</p><h3 id="4-10-参考帧重采样模式"><a href="#4-10-参考帧重采样模式" class="headerlink" title="4.10.   参考帧重采样模式"></a>4.10.   参考帧重采样模式</h3><p>在对当前帧图像进行预测之前提供不同分辨率、转换和wrap的参考图像。</p><h3 id="4-11-独立分割解码模式"><a href="#4-11-独立分割解码模式" class="headerlink" title="4.11.   独立分割解码模式"></a>4.11.   独立分割解码模式</h3><p>在这种模式下，图像分割边界看做是图像边界，在图像分割边界两侧是没有数据依赖的。</p><p>这种模式适用于Slice结构。</p><h3 id="4-12-可选择的帧间VLC模式"><a href="#4-12-可选择的帧间VLC模式" class="headerlink" title="4.12.   可选择的帧间VLC模式"></a>4.12.   可选择的帧间VLC模式</h3><p>针对采用小的量化步长的帧间宏块，可选择采用帧内VLC表。</p><p>设计思想：</p><p>采用小的量化步长的帧间宏块，量化后的残差系数值较大并且连续0的run值较小，类似于帧内宏块残差系数的特点，因此使用帧内VLC表进行编码。</p><h3 id="4-13-修改的量化模式"><a href="#4-13-修改的量化模式" class="headerlink" title="4.13.   修改的量化模式"></a>4.13.   修改的量化模式</h3><p>（1）    允许码率控制方法在宏块级更加灵活的更改量化系数；</p><p>H.263中可以在很小范围内（正负1或者正负2）在宏块级修改量化参数；</p><p>而H.263+中修改的量化模式允许在宏块级修改量化参数到任何值。</p><p>（2）    通过采用一个更小的色度量化步长来增强色度质量；</p><p>而在H.263中，亮度块和色度块采用相同的量化步长（QP step）。</p><p>（3）    通过扩展可表示的量化的DCT系数的范围来改善图像质量。</p><h2 id="5-H-263-码率控制模型"><a href="#5-H-263-码率控制模型" class="headerlink" title="5.   H.263+码率控制模型"></a>5.   H.263+码率控制模型</h2><p>这里介绍一种TMN8采用的码率控制算法，适用于低延时的视频会议应用场景。</p><p>参考文献：Rate Control in DCT Video Coding for Low-Delay<br>Communications，IEEE TCSVT， 1999.</p><p>TMN8码率控制是为低延迟视频通信设计的码率控制算法。</p><p>TMN8码率控制分为帧级码率控制和宏块级码率控制。帧级码率控制会为当前帧选择合适的目标比特数，宏块级码率控制会为当前帧内的每个宏块计算QP（或者QPstep）。如果缓冲区溢出，则跳过当前的编码。</p><h3 id="5-1-帧级码率控制"><a href="#5-1-帧级码率控制" class="headerlink" title="5.1. 帧级码率控制"></a>5.1. 帧级码率控制</h3><p>在帧级码率控制中，帧的目标比特数由缓冲区buffer的充盈度、帧率和信道速度决定。在编码当前帧前通过下式计算缓冲区充盈度W:<br><img src="https://img-blog.csdnimg.cn/20200527091929895.png" alt="在这里插入图片描述"></p><p>其中，</p><p>B’表示编码前一帧的比特数，</p><p>Wpred表示buffer中前一个比特数；（初始状态下，Wpred=0，B’表示I帧的编码比特数）</p><p>R表示信道速度，F表示帧率。</p><p>当W大于最大值M（M=R/F）,编码器跳过要编码的帧直到缓冲区充盈度小于M。每跳过一帧，缓冲区的充盈度减小R/F。</p><p>当前帧分配的目标比特如下：</p><p><img src="https://img-blog.csdnimg.cn/20200527091943632.png" alt="在这里插入图片描述"><br>其中，delta表示为：<br><img src="https://img-blog.csdnimg.cn/20200527091948782.png" alt="在这里插入图片描述"><br>其中Z为0.1。delta是一个很小的值来提供对缓冲区充盈度的反馈。如果W大于M的10%，目标比特数B会稍微减少；否则，B会稍微增加。</p><h3 id="5-2-宏块级码率控制"><a href="#5-2-宏块级码率控制" class="headerlink" title="5.2. 宏块级码率控制"></a>5.2. 宏块级码率控制</h3><p>宏块级码率控制按照扫描顺序为帧内每个MB计算量化步长。第i个宏块的量化步长计算如下：</p><p><img src="https://img-blog.csdnimg.cn/20200527092000403.png" alt="在这里插入图片描述"></p><p>其中，<br><img src="https://img-blog.csdnimg.cn/20200527092007730.png" alt="在这里插入图片描述"></p><p>宏块级码率控制从第一个MB开始用上式计算Q1，然后用Q1编码MB。然后用该帧的目标比特数减去估计的头比特数和已经使用的比特数得到剩余目标比特数，用剩余比特数按同样的方法编码接下来的MB，每编码完一个宏块就更新模型参数K和C。</p><h2 id="6-H-263-标准可选编码选项"><a href="#6-H-263-标准可选编码选项" class="headerlink" title="6.   H.263++标准可选编码选项"></a>6.   H.263++标准可选编码选项</h2><p>在H.263+基础上增加了3种可选编码选项：</p><p>（1）    Annex U: Enhanced reference picture selection mode</p><p>（2）    Annex V: Data-partitioned slice mode</p><p>（3）    Annex W: Additional supplement enhancement information specification</p><p>分别对上面三个高级编码选项进行分析：</p><h3 id="6-1-增强的参考帧选择模式–ERPS"><a href="#6-1-增强的参考帧选择模式–ERPS" class="headerlink" title="6.1. 增强的参考帧选择模式–ERPS"></a>6.1. 增强的参考帧选择模式–ERPS</h3><p>ERPS模式可以增强容错性和提高编码效率。</p><p>（1）    对于容错性，ERPS模式可以使用后向通道信息，由解码器发送消息给编码器告知哪些帧解码错误。</p><p>（2）    对于编码效率，运动补偿可以扩展成支持多参考帧的预测。</p><h3 id="6-2-数据分割的Slice模式–DPS"><a href="#6-2-数据分割的Slice模式–DPS" class="headerlink" title="6.2. 数据分割的Slice模式–DPS"></a>6.2. 数据分割的Slice模式–DPS</h3><p>  DPS模式可以增强容错性，尤其是在传输过程中的局部码流错误。</p><p>数据分割技术在易错环境中提供了鲁棒性。这种功能是通过对H.263句法进行重排来实现对传输错误的提前监测和恢复。</p><p>（1）    分离头数据和运动矢量数据</p><p>采用数据分割时，slice中的数据会进行重新排列，首先是宏块的头信息，然后是运动矢量信息，最后是DCT系数。</p><p>（2）    使用可逆表示来保护运动矢量数据</p><p>采用RVLC编码运动矢量数据。</p><h3 id="6-3-额外的补充增强信息–SEI"><a href="#6-3-额外的补充增强信息–SEI" class="headerlink" title="6.3. 额外的补充增强信息–SEI"></a>6.3. 额外的补充增强信息–SEI</h3><p>额外的SEI信息包括：</p><p>（1）    指示使用特定的定点IDCT;</p><p>（2）    图像信息，包括的信息类型有：</p><ul><li>任意的二进制数据</li></ul><ul><li><p>文本信息（任意文本、版权、视频描述、URI信息）</p></li><li><p>场信息（顶场还是底场）</p><p>额外的SEI信息存放在图像层的PSUFF字段中。</p></li></ul><h2 id="7-H-263标准与H-261和H-262（MPEG-2）标准的比较"><a href="#7-H-263标准与H-261和H-262（MPEG-2）标准的比较" class="headerlink" title="7.   H.263标准与H.261和H.262（MPEG-2）标准的比较"></a>7.   H.263标准与H.261和H.262（MPEG-2）标准的比较</h2><p>比较的维度如下所示：</p><h3 id="7-1-标准发布时间和目的"><a href="#7-1-标准发布时间和目的" class="headerlink" title="7.1. 标准发布时间和目的"></a>7.1. 标准发布时间和目的</h3><ul><li><p>H.261: 1990年，实现在ISDN上进行视频会议或可视电话等对称应用。</p></li><li><p>H.262: 1994年，实现视音频服务与应用交互的可能性，基于对象的编码。</p></li><li><p>H.263: 1996年，为低码率通信设计。</p></li></ul><h3 id="7-2-编解码框架和压缩率"><a href="#7-2-编解码框架和压缩率" class="headerlink" title="7.2. 编解码框架和压缩率"></a>7.2. 编解码框架和压缩率</h3><ul><li>H.261：压缩率为20~30，小于MPEG-1，采用基于运动补偿的帧间预测、分块DCT和量化相结合的混合编码方法。</li></ul><ul><li>H.262: 压缩率为30~40，采用基于运动补偿的帧间预测（单双向预测）、DCT和量化的混合编码方法，支持可伸缩性，前向兼容MPEG-1。</li></ul><ul><li>H.263：压缩率高于H.262，采用基于运动补偿的帧间预测（单双向预测），DCT和量化的混合编码，并进行局部算法改进和支持可选编码选项，支持可伸缩性。</li></ul><h3 id="7-3-码流结构"><a href="#7-3-码流结构" class="headerlink" title="7.3. 码流结构"></a>7.3. 码流结构</h3><ul><li><p>H.261：分层结构，同H.263。</p></li><li><p>H.262: 分层结构，分成6层，自上而下分别是：图像序列层（Video Sequence）、图像组层（GOP）、图像层（Picture）、宏块条层（Slice）、宏块层（Macroblock）和块层（block）。</p></li><li><p>H.263：分层结构，分成4层，自上而下分别是：图像层（Picture Frame）、块组层（GOB）、宏块层（Macorblock）和块层（Block）。</p></li></ul><h3 id="7-4-支持的分辨率"><a href="#7-4-支持的分辨率" class="headerlink" title="7.4. 支持的分辨率"></a>7.4. 支持的分辨率</h3><ul><li><p>H.261: 支持CIF和QCIF两种分辨率</p></li><li><p>H.262：支持CIF，4CIF，16CIF，1920x1152等多种分辨率。</p></li><li><p>H.263: 支持SQCIF、QCIF、CIF、4CIF和16CIF五种分辨率。</p></li></ul><h3 id="7-5-运动补偿精度和MV范围"><a href="#7-5-运动补偿精度和MV范围" class="headerlink" title="7.5. 运动补偿精度和MV范围"></a>7.5. 运动补偿精度和MV范围</h3><ul><li><p>H.261: 支持全像素精度，只支持1个MV（1个MB 分配一个MV），MV范围为[-15,+15]</p></li><li><p>H.262：支持半像素精度，MV范围为[-512,511.5]</p></li><li><p>H.263：支持半像素精度，支持1MV和4MV（高级预测模式下才支持），MV范围为[-16,+15.5]，无限制运动矢量模式中扩展为[-31.5, +31.5]</p></li></ul><h3 id="7-6-熵编码"><a href="#7-6-熵编码" class="headerlink" title="7.6. 熵编码"></a>7.6. 熵编码</h3><ul><li><p>H.261：不支持熵编码。</p></li><li><p>H.262: 支持VLC编码</p></li><li><p>H.263：支持3D-VLC编码和基于句法的算术编码（高级编码选项）</p></li></ul><h3 id="7-7-双向预测（B帧）"><a href="#7-7-双向预测（B帧）" class="headerlink" title="7.7. 双向预测（B帧）"></a>7.7. 双向预测（B帧）</h3><ul><li><p>H.261：不支持B帧，只支持I帧和P帧。</p></li><li><p>H.262：支持B帧，使用前后向预测。</p></li><li><p>H.263：支持B帧，使用前后向预测、前向预测和后向预测。</p></li></ul><h3 id="7-8-I帧预测"><a href="#7-8-I帧预测" class="headerlink" title="7.8. I帧预测"></a>7.8. I帧预测</h3><ul><li><p>H.261：没有I帧预测，只有P帧预测。</p></li><li><p>H.262：没有I帧预测，支持帧内DC系数（量化后残差系数）的预测。</p></li><li><p>H.263：没有I帧预测（没有使用预测模式称为INTRA模式）；在H.263+中的高级帧内编码模式中支持三种帧内预测模式（DC，水平预测和垂直预测）。</p></li></ul><h3 id="7-9-参考帧"><a href="#7-9-参考帧" class="headerlink" title="7.9. 参考帧"></a>7.9. 参考帧</h3><ul><li><p>H.261：P帧支持前向单参考预测；</p></li><li><p>H.262：P帧支持前向单参考预测，B帧可以有两个参考帧。</p></li><li><p>H.263：P帧支持前向预测，B帧可以有两个参考帧。在H.263+中的参考帧选择模式中支持多参考帧预测。</p></li></ul><h3 id="7-10-量化参数"><a href="#7-10-量化参数" class="headerlink" title="7.10.   量化参数"></a>7.10.   量化参数</h3><ul><li><p>H.261：量化参数为1-31，帧内dc系数的量化步长为8，其他系数的量化步长取值为2~62的偶数（量化步长是量化参数的2倍）。</p></li><li><p>H.262：量化参数为0-31，采用MPEG量化方法。</p></li><li><p>H.263：同H.261标准。</p></li></ul><h2 id="8-FFmpeg中H-263编解码器的实现分析"><a href="#8-FFmpeg中H-263编解码器的实现分析" class="headerlink" title="8.   FFmpeg中H.263编解码器的实现分析"></a>8.   FFmpeg中H.263编解码器的实现分析</h2><p>在FFmpeg中支持H.263和H.263+编解码器，但不支持H.263++。</p><h3 id="8-1-编码命令行"><a href="#8-1-编码命令行" class="headerlink" title="8.1. 编码命令行"></a>8.1. 编码命令行</h3><p>H.263编码：</p><pre><code class="c">./ffmpeg -s 352x288  -pix_fmt  yuv420p -i bus_cif.yuv -an  -vcodec h263-b:v 128 -r 15   outfile.h263</code></pre><p>H.263+编码：</p><pre><code class="c">./ffmpeg -s 352x288  -pix_fmt  yuv420p -i bus_cif.yuv -an  -vcodec h263p-b:v 128 -r 15   outfile.h263</code></pre><h3 id="8-2-H-263编码流程"><a href="#8-2-H-263编码流程" class="headerlink" title="8.2. H.263编码流程"></a>8.2. H.263编码流程</h3><p><img src="https://img-blog.csdnimg.cn/20200527092607971.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NvYXJpbmdMZWVfZmlnaHRpbmc=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>1、注册组件（注册所有的编解码器）</p><p>avcodec_register_all</p><p>2、找到对应编码器</p><p>avcodec_find_encoder</p><p>3、打开ffmpeg的输入输出文件</p><p>avcodec_open2</p><p>4、编码</p><p>avcodec_encode_video2</p><p>ret = avctx-&gt;codec-&gt;encode2(avctx,<br>avpkt, frame, got_packet_ptr);</p><p>5、释放</p><p>avcodec_close</p><p>avctx-&gt;codec-&gt;close(avctx);</p><p><strong>初始化视频编码器：</strong></p><p>ff_mpv_encode_init包括：</p><p>ff_mpv_idct_init          //idct函数指针初始化</p><p>ff_dct_encode_init       //dct函数指针初始化</p><p>ff_h263_encode_init     //loopfilter函数指针初始化</p><p><strong>视频编码：</strong></p><p>ff_mpv_encode_picture包括：</p><p>ff_alloc_picture             // 分配一帧图像</p><p>ff_alloc_packet2            // 分配一帧码流数据</p><p>encode_picture            // 编码一帧图像</p><p>estimate_motion_thread             //</p><p><strong>运动估计</strong></p><p>ff_h263_encode_picture_header  // 编码图像头</p><p>encode_thread::ff_h263_encode_gob_header         //编码GOB头</p><p>encode_mb_hq:: encode_mb:: encode_mb_internal //编码一个宏块</p><p>ff_h263_encode_mb    // 残差编码</p><p>h263_encode_block</p><p><strong>关闭视频编码器：</strong></p><p>ff_mpv_encode_end包括：</p><p>ff_rate_control_uninit</p><p>ff_mpv_common_end</p><h3 id="8-3-H-263解码流程"><a href="#8-3-H-263解码流程" class="headerlink" title="8.3. H.263解码流程"></a>8.3. H.263解码流程</h3><p><img src="https://img-blog.csdnimg.cn/20200527092630699.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NvYXJpbmdMZWVfZmlnaHRpbmc=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="9-总结"><a href="#9-总结" class="headerlink" title="9.   总结"></a>9.   总结</h2><p>H.263标准主要是面向低延时的视频通信应用场景，除了采用基于运动补偿的帧间预测和变换编码的混合框架外，还引入了4种可选的编码选项来提高编码效率；H.263+增加了12个可选的编码选项，H.263++增加了3个可选的编码选项，通过这些高级模式在扩大实际应用范围，进一步降低比特率、改善图像主观质量和增强抗误码能力等方面做出很多改进。</p><h2 id="10-参考文献"><a href="#10-参考文献" class="headerlink" title="10.       参考文献"></a>10.       参考文献</h2><p>[1] Rate Control in DCT Video Coding for Low-Delay Communications，IEEE TCSVT， 1999.</p><p>[2] T-REC-H.263-199603-S!!PDF-E.pdf</p><p>[3] H.263标准文档(中文版).pdf</p><p>[4] H.263+_Video Coding at Low Bit Rates, IEEE TCSVT, 1998.</p><p>[5] T-REC-H.263-200011-S!AnnU!PDF-E.pdf</p><p>[6] T-REC-H.263-200011-S!AnnV!PDF-E.pdf</p><p>[7] T-REC-H.263-200011-S!AnnW!PDF-E.pdf</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 编解码 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Codecs </tag>
            
            <tag> H263 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>全平台编译模板MakefileSample</title>
      <link href="/2020/06/22/%E3%80%90%E5%B7%A5%E7%A8%8B%E5%8C%96%E7%B3%BB%E5%88%97%E3%80%91%E5%85%A8%E5%B9%B3%E5%8F%B0%E7%BC%96%E8%AF%91%E6%A8%A1%E6%9D%BFMakefileSample/"/>
      <url>/2020/06/22/%E3%80%90%E5%B7%A5%E7%A8%8B%E5%8C%96%E7%B3%BB%E5%88%97%E3%80%91%E5%85%A8%E5%B9%B3%E5%8F%B0%E7%BC%96%E8%AF%91%E6%A8%A1%E6%9D%BFMakefileSample/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="1、参考"><a href="#1、参考" class="headerlink" title="1、参考"></a>1、参考</h2><p><a href="https://blog.csdn.net/SoaringLee_fighting/article/details/82594605" target="_blank" rel="noopener">【makefile】makefile工程编译模板</a><br><a href="https://blog.csdn.net/SoaringLee_fighting/article/details/82903592" target="_blank" rel="noopener">【makefile系列】多平台编译脚本以及makefile自动化编译总结</a><br><a href="https://blog.csdn.net/SoaringLee_fighting/article/details/80677087" target="_blank" rel="noopener">【PE&amp;Tools】GnuWin32使用以及windows下gnu makefile编写</a></p><h2 id="2、全平台编译脚本"><a href="#2、全平台编译脚本" class="headerlink" title="2、全平台编译脚本"></a>2、全平台编译脚本</h2><p>MakefileSample: 本编译脚本模板旨在建立全平台（Windows,Linux,ARM,Mac,IOS和Android）的编译方法，通过makefile的方式实现全平台编译脚本化和一键编译，从而更方便的实现库和demo的编译。<br>本模板是一个简单的sample，适用于（可移植到）任何项目中。</p><p>注：</p><ul><li>(1) Linux平台、Windows平台和Mac平台支持x86汇编编译，需要借助yasm汇编器；</li><li>(2) ARM平台和IOS平台支持neon汇编编译。</li></ul><h2 id="3、README"><a href="#3、README" class="headerlink" title="3、README"></a>3、README</h2><pre><code>MakefileSampleThis is a sample project for demonstrating how to use makefile simply.一、支持平台Linux(ARM), Windows, Android, Mac, IOS二、各平台编译说明1、Linux平台(1) Linux64位： make -f Makefile_lib platform=x86_64 PUREC=1make -f Makefile_demo platform=x86_64 PUREC=1(2) linux32位： make -f Makefile_lib platform=x86_32 PUREC=1make -f Makefile_demo platform=x86_32 PUREC=12、Mac平台(1) Mac64位：make -f Makefile_lib target_plat=mac platform=x86_64 PUREC=1make -f Makefile_demo target_plat=mac platform=x86_64 PUREC=1(2) Mac32位：make -f Makefile_lib target_plat=mac platform=x86_32 PUREC=1make -f Makefile_demo target_plat=mac platform=x86_32 PUREC=13、IOS平台(1) IOS32位：make -f Makefile_lib target_plat=ios platform=ios32 PUREC=1make -f Makefile_demo target_plat=ios platform=ios32 PUREC=1(2) IOS64位：make -f Makefile_lib target_plat=ios platform=ios64 PUREC=1make -f Makefile_demo target_plat=ios platform=ios64 PUREC=14、Android平台4.1、单独命令方式在android-ndk-r10e中执行如下命令：（1）带优化编译：./ndk-build -B -C ~/MakefileSample\build\android PUREC=0（2）纯C编译： ./ndk-build -B -C ~/MakefileSample\build\android PUREC=1说明：android-ndk-r10e下载链接：https://blog.csdn.net/SoaringLee_fighting/article/details/1068734544.2、脚本方式（Python）（1）带优化编译： python build_andorid.py /home/myshare/android-ndk-r10e pure_c=0（2）纯C编译：    python build_andorid.py /home/myshare/android-ndk-r10e pure_c=14.3、脚本方式（shell）./build_android.sh /home/myshare/android-ndk-r10e</code></pre><h2 id="4、模板开源地址"><a href="#4、模板开源地址" class="headerlink" title="4、模板开源地址"></a>4、模板开源地址</h2><p><a href="https://github.com/soaringleefighting/MakefileSample" target="_blank" rel="noopener">https://github.com/soaringleefighting/MakefileSample</a></p><p><font color="red">THE END!</font></p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 开源项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> makefile </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>X86ASM汇编优化demo</title>
      <link href="/2020/06/13/%E3%80%90%E4%BC%98%E5%8C%96%E7%B3%BB%E5%88%97%E3%80%91x86asm%E6%B1%87%E7%BC%96%E4%BC%98%E5%8C%96demo/"/>
      <url>/2020/06/13/%E3%80%90%E4%BC%98%E5%8C%96%E7%B3%BB%E5%88%97%E3%80%91x86asm%E6%B1%87%E7%BC%96%E4%BC%98%E5%8C%96demo/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="1、参考"><a href="#1、参考" class="headerlink" title="1、参考"></a>1、参考</h2><p><a href="https://blog.csdn.net/SoaringLee_fighting/article/details/104350244" target="_blank" rel="noopener">【优化系列】X86优化之纯汇编优化方法</a></p><h2 id="2、x86-assembly-demo"><a href="#2、x86-assembly-demo" class="headerlink" title="2、x86 assembly demo"></a>2、x86 assembly demo</h2><p>x86纯汇编：SSE2指令集</p><h3 id="2-1-demo-c"><a href="#2-1-demo-c" class="headerlink" title="2.1 demo.c"></a>2.1 demo.c</h3><p><strong>demo.c如下：</strong></p><pre><code class="c">#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;time.h&gt;#include &quot;os_time_sdk.h&quot;#define CLIP(x) (x&gt;255? 255: x&lt;0? 0:x)void x264_pred_dc_8x8_x86_sse2(unsigned char *_src, const unsigned char *_top,    const unsigned char *_left,    int stride, int log2_size);static void GenerateMatrix(unsigned char *src, unsigned char *top,unsigned char *left, int stride, int height){    int i = 0;    srand((int)time(0)); // 设置rand()产生随机数的随机数种子    for (i = 0; i &lt; height*stride; i++)    {        src[i] = CLIP(1.0*rand()/RAND_MAX * 255);    }    for (i = 0; i &lt; height*stride; i++)    {        top[i] = CLIP(1.0*rand()/RAND_MAX * 255);    }    for (i = 0; i &lt; height*stride; i++)    {        left[i] = CLIP(1.0*rand()/RAND_MAX * 255);    }}static void ff_pred_dc(unsigned char *_src, const unsigned char *_top,                          const unsigned char *_left,                          int stride, int log2_size){    int i = 0, j = 0;    int size          = (1 &lt;&lt; log2_size);    unsigned char *src        = (unsigned char *)_src;    const unsigned char *top  = (const unsigned char *)_top;    const unsigned char *left = (const unsigned char *)_left;    int dc            = size;    //pixel4 a;    for (i = 0; i &lt; size; i++)        dc += left[i] + top[i];    dc &gt;&gt;= log2_size + 1;    for (i = 0; i &lt; size; i++)    {        for (j = 0; j &lt; size; j++)        {                src[j + i * stride] = dc;        }    }}int main(int argc, char* argv[]){    int ret = 0;    int i = 0, j = 0;    unsigned char src[255];    unsigned char top[255];    unsigned char left[255];    os_timer pTimer = {0};    double time_c = 0.0, time_opt = 0.0;    GenerateMatrix(src, top, left, 8, 8);    os_sdk_inittimer(&amp;pTimer);    printf(&quot;src: \t\n&quot;);    for (i = 0; i &lt; 8 ; i++)    {        for (j = 0; j &lt; 8; j++)        {            printf(&quot;%d\t&quot;, src[j+i*8]);        }        printf(&quot;\n&quot;);    }    printf(&quot;top: \t\n&quot;);    for (i = 0; i &lt; 8 ; i++)    {        for (j = 0; j &lt; 8; j++)        {            printf(&quot;%d\t&quot;, top[j+i*8]);        }        printf(&quot;\n&quot;);    }    printf(&quot;left: \t\n&quot;);    for (i = 0; i &lt; 8 ; i++)    {        for (j = 0; j &lt; 8; j++)        {            printf(&quot;%d\t&quot;, left[j+i*8]);        }        printf(&quot;\n&quot;);    }    os_sdk_starttimer(&amp;pTimer);    for (i = 0; i&lt; 500000; i++)    {        // C实现        ff_pred_dc(src, top, left, 8, 3);    }    time_c = os_sdk_stoptimer(&amp;pTimer);    printf(&quot;src_pred_dc_C: \t\n&quot;);    for (i = 0; i &lt; 8 ; i++)    {        for (j = 0; j &lt; 8; j++)        {            printf(&quot;%d\t&quot;, src[j+i*8]);        }        printf(&quot;\n&quot;);    }    os_sdk_starttimer(&amp;pTimer);    for (i = 0; i&lt; 500000; i++)    {        // x86纯汇编优化        x264_pred_dc_8x8_x86_sse2(src, top, left, 8, 3);    }    time_opt = os_sdk_stoptimer(&amp;pTimer);    printf(&quot;src_pred_dc_X86ASM: \t\n&quot;);    for (i = 0; i &lt; 8 ; i++)    {        for (j = 0; j &lt; 8; j++)        {            printf(&quot;%d\t&quot;, src[j+i*8]);        }        printf(&quot;\n&quot;);    }    printf(&quot;time_c: %f ms\t time_opt: %f ms \n&quot;, time_c, time_opt);    return 0;}</code></pre><h3 id="2-2-pred-dc-x86-asm"><a href="#2-2-pred-dc-x86-asm" class="headerlink" title="2.2 pred_dc_x86.asm"></a>2.2 pred_dc_x86.asm</h3><p><strong>pred_dc_x86.asm如下：</strong><br>采用x86inc.asm汇编头的方式编写：</p><pre><code class="asm">%include &quot;x86inc.asm&quot;SECTION .datadata_8:    times 8 dw 8SECTION .textINIT_XMM sse2ALIGN 16;====================================================================;static void ff_pred_dc(unsigned char *_src, const unsigned char *_top,;                          const unsigned char *_left,;                          int stride, int log2_size);====================================================================cglobal pred_dc_8x8_x86, 5, 5, 5, src, top, left, stride, size    mov sizeq, 8            ; size    ; 获取left和top的像素值    movq m0, [topq]    movq m1, [leftq]    pxor m2, m2    punpcklbw m0, m2    punpcklbw m1, m2    paddw m0, m1    phaddw m0, m0    phaddw m0, m0    phaddw m0, m0    movdqu m4, [data_8]    paddw m0, m4    ; dc &gt;&gt;= log2_size + 1;    psraw m0, 4    movdqa m4, m0      ;暂存m0    ; 存dc值    packuswb m0, m0 ; packuswb word--&gt;byteloop_8:    movq [srcq],m0    lea srcq, [srcq+strideq]    dec sizeq    jg loop_8loop_end:    REP_RET</code></pre><h3 id="2-3-pred-dc-x86-org-asm"><a href="#2-3-pred-dc-x86-org-asm" class="headerlink" title="2.3 pred_dc_x86_org.asm"></a>2.3 pred_dc_x86_org.asm</h3><p>不使用x86汇编头的原始汇编代码：</p><pre><code class="asm">bits 32section .dataalign 16data_8    dw  8, 8, 8, 8, 8, 8, 8, 8section .textalign 16global  _ff_pred_dc_8x8_x86_sse2_ff_pred_dc_8x8_x86_sse2:    push ebp    mov  ebp ,esp    push  esi    push  edi    mov esi, [ebp+8]    ; src    mov edi, [ebp+12]    ; top    mov eax, [ebp+16]    ; left    mov edx, [ebp+20]    ; stride    mov ecx,  8            ; size    ; 获取left和top的像素点    movq xmm0, [edi]    ; 获取top的8个像素点    movq xmm1, [eax]    ; 获取left的8个像素点    pxor xmm2, xmm2        ; xmm2清零    punpcklbw xmm0, xmm2 ; 将8bit扩展为16bit    punpcklbw xmm1, xmm2 ; 将8bit扩展为16bit    ; dc += left[i] + top[i];    paddw xmm0, xmm1      ; top[i]+left[i] 按字相加    phaddw xmm0, xmm0    ; 按字水平相加    phaddw xmm0, xmm0        phaddw xmm0, xmm0     ; xmm0中8个字存放top[i]+left[i]    movdqu xmm4, [data_8] ; 8    paddw  xmm0, xmm4    ; dc &gt;&gt;= log2_size + 1;    psraw  xmm0, 4         ; xmm0存放8个16位的dc值    movdqa xmm4, xmm0     ; 保存xmm0    ; 存dc值    packuswb  xmm0, xmm0 ; 将16bit转换成8bitloop_8:    movq [esi], xmm0    lea  esi, [esi+edx]    dec ecx    jg  loop_8loop_end:    pop  edi    pop  esi    mov  esp, ebp         ; 收回局部变量的空间    pop  ebp    ret</code></pre><h2 id="THE-END"><a href="#THE-END" class="headerlink" title=" THE END! "></a><font color="red"> THE END! </font></h2>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 优化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> X86 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>查找算法及其实现</title>
      <link href="/2020/04/28/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%B3%BB%E5%88%97%E3%80%91%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95%E5%8F%8A%E5%85%B6%E5%AE%9E%E7%8E%B0/"/>
      <url>/2020/04/28/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%B3%BB%E5%88%97%E3%80%91%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95%E5%8F%8A%E5%85%B6%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="1、查找的基本概念"><a href="#1、查找的基本概念" class="headerlink" title="1、查找的基本概念"></a>1、查找的基本概念</h2><p><strong>查找表：</strong> 是由同一类型的数据元素（或记录）构成的集合。<br><strong>关键字</strong>：是数据元素中某个数据项的值，又称为键值。主关键字、次关键字<br><strong>查找</strong>：就是根据给定的某个值，在查找表中确定一个其关键字等于给定值的数据元素。<br><strong>静态查找表</strong>：只作查找操作的查找表。<br><strong>动态查找表</strong>：在查找过程中同时插入查找表中不存在的数据元素，或者从查找表中删除已经存在的某个数据元素。</p><h2 id="2、查找算法"><a href="#2、查找算法" class="headerlink" title="2、查找算法"></a>2、查找算法</h2><h3 id="2-1-顺序表查找"><a href="#2-1-顺序表查找" class="headerlink" title="2.1 顺序表查找"></a>2.1 顺序表查找</h3><p>线性查找，逐个比较查找，是最基本的查找技术。时间复杂度： O(n)</p><h3 id="2-2-有序表查找"><a href="#2-2-有序表查找" class="headerlink" title="2.2 有序表查找"></a>2.2 有序表查找</h3><p>(1) 折半查找：二分查找，时间复杂度：O(logn)<br>(2) 插值查找：时间复杂度：O(logn),适用于表长较长，并且关键字分布均匀的查找表。<br>(3) 斐波那契查找：时间复杂度：O(logn)</p><h3 id="2-3-动态查找表"><a href="#2-3-动态查找表" class="headerlink" title="2.3 动态查找表"></a>2.3 动态查找表</h3><p>二叉排序树、平衡二叉树（AVL树）、B树</p><h3 id="2-4-哈希表查找"><a href="#2-4-哈希表查找" class="headerlink" title="2.4 哈希表查找"></a>2.4 哈希表查找</h3><p>散列（哈希）hash技术是在记录的存储位置和它的关键字之间建立一个确定的对应关系f，使得每个关键字key对应一个存储位置f(key)。</p><p>哈希函数：对应关系f<br>哈希表: 采用哈希函数记录关键字的这一段连续的存储空间</p><p>哈希函数的构造方法：直接定址法、数字分析法、平方取中法、折叠法、除留取余法、随机数法</p><p>处理散列冲突的方法：开放定址法、再散列函数法、链地址法。</p><h2 id="3、各种查找算法的C实现"><a href="#3、各种查找算法的C实现" class="headerlink" title="3、各种查找算法的C实现"></a>3、各种查找算法的C实现</h2><pre><code class="c">#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;// 1.顺序查找// 顺序查找,a为数组，n为查找的数组长度，key为要查找的关键字// 查找成功，返回数组索引；查找不成功，返回-1。int Sequential_Search(int *a, int n, int key){    int i;    for (i = 0; i &lt; n; i++)    {        if (key == a[i])        {            return i;        }    }    return -1;}// 2.带哨兵的顺序查找int Sequential_Search2(int *a, int n, int key){    int i;    a[0] = key; // 在数组末尾设置哨兵    i = n;    while (a[i] != key)    {        i--;    }    return i; // 返回0说明查找失败}//  3.折半查找(二分查找)int Binary_Search(int *a, int n, int key){    int low, high, mid;    low = 1;    high = n;    while (low &lt;= high)    {        mid = (low+high)/2;        // mid = low + (high-low)*(key-a[low])/(a[high] - a[low]); //插值查找法        if (key &lt; a[mid])        {            high = mid-1;        }        else if (key &gt; a[mid])        {            low = mid+1;        }        else            return mid;    }    return 0;}const int F[13] = {0,1,1,2,3,5,8,13,21,34,55,89,144};/* 4.斐波那契查找 */int Fibonacci_Search(int *a, int n, int key){    int low, high, mid, i, k;    low = 1;    high =n;    k = 0;    while(n &gt; F[k]-1)        k++;    for (i=n; i &lt; F[k]-1;i++)    {        a[i] = a[n];    }    while (low &lt;= high)    {        mid = low+F[k-1]-1;        if (key &lt; a[mid])        {            high = mid - 1;            k = k-1;        }        else if (key &gt; a[mid])        {            low = mid + 1;            k= k-2;        }        else        {            if (mid&lt;=n)            {                return mid;            }            else            {                return n;            }        }    }    return 0;}// 5.二叉排序树typedef struct BiTNode{    int data;    struct BiTNode *lchild, *rchild;} BiTNode, *BiTree;//递归查找二叉排序树中是否存在Key//若查找成功，则指针p指向该数据元素结点，并返回TRUE，否则指针p指向查找路径上//访问的最后一个结点并返回FALSEint SearchBST(BiTree T, int key, BiTree f, BiTree *p){    if (!T)    {        *p = T;        return -1;    }    else if (key == T-&gt;data)    {        *p = T;        return 0;    }    else if (key &lt; T-&gt;data)    {        return SearchBST(T-&gt;lchild, key, T, p);    }    else        return SearchBST(T-&gt;rchild, key, T, p);}// 二叉排序树的插入操作int InsertBST(BiTree *T, int key){    BiTree p, s;    if (!SearchBST(*T, key, NULL, &amp;p)) // 查找不成功才插入    {        s = (BiTree) malloc(sizeof(BiTNode));        s-&gt;data = key;        s-&gt;lchild = s-&gt;rchild = NULL;        if (!p)        {            *T = s; // 插入s为新的根结点        }        else if (key &lt; p-&gt;data)        {            p-&gt;lchild = s; // 插入s为左孩子        }        else        {            p-&gt;rchild = s;// 插入s为右孩子        }        return 0;    }    else        return -1;}int Delete(BiTree *p){    BiTree q, s;    if ((*p)-&gt;rchild == NULL)    {        q = *p;        *p = (*p)-&gt;lchild;        free(q);    }    else if ((*p)-&gt;lchild == NULL)    {        q = *p;        *p = (*p)-&gt;rchild;        free(q);    }    else    {        q = *p;        s = (*p)-&gt;lchild;        while (s-&gt;rchild)        {            q = s;            s = s-&gt;rchild;        }        (*p)-&gt;data = s-&gt;data;        if (q!=*p)        {            q-&gt;rchild = s-&gt;lchild;        }        else            q-&gt;lchild = s-&gt;lchild;        free(s);    }    return 0;}//二叉排序树的删除操作int DeleteBST(BiTree *T, int key){    if (!*T) //空树    {        return -1;    }    else    {        if (key == (*T)-&gt;data) // 找到关键字为key的数据元素        {            return Delete(T);        }        else if (key &lt; (*T)-&gt;data)        {            return DeleteBST(&amp;(*T)-&gt;lchild, key);        }        else            return DeleteBST(&amp;(*T)-&gt;rchild, key);    }}// 6.散列表查找#define  SUCCESS    (1)#define     UNSUCCESS    (0)#define  HASHSIZE    (12)#define  NULLKEY    (-32768)typedef struct{    int *elem;    int count;} HashTable;int m = 0; // 散列表表长，全局变量int InitHashTable(HashTable *H){    int i;    m = HASHSIZE;    H-&gt;count = m;    H-&gt;elem = (int*) malloc(m*sizeof(int));    for (i = 0; i &lt; m; i++)    {        H-&gt;elem[i] = NULLKEY;    }    return 0;}int Hash(int key){    return key % m; // 除留取余法}void InsertHash(HashTable *H, int key){    int addr = Hash(key);    while (H-&gt;elem[addr] != NULLKEY)    {        addr = (addr+1) % m;    }    H-&gt;elem[addr] = key;}// 散列表查找关键字int SearchHash(HashTable H, int key, int *addr){    *addr = Hash(key);    while (H.elem[*addr] != key)    {        *addr = (*addr +1) % m;        if (H.elem[*addr] == NULLKEY || *addr == Hash(key))        {            return UNSUCCESS;        }    }    return SUCCESS;}int main(int argc, char* argv[]){    int index = 0;    int i = 0;    int addr = 0;    int array[10] = {5, 4, 8, 10, 30, 40, 50, 60, 70, 80};    int a[10] = {62,88,85,47,35,73,51,99,37,93};    BiTree T = NULL;    HashTable H = {0};    index = Sequential_Search(array, 10, 10);    printf(&quot;Sequential_search index: %d\n&quot;, index);    index = Sequential_Search2(array, 10, 10);    printf(&quot;Sequential_search2 index: %d\n&quot;, index);    index = Binary_Search(array, 10, 10);    printf(&quot;Binary_Search index: %d\n&quot;, index);    index = Fibonacci_Search(array, 10, 10);    printf(&quot;Fibonacci_Search index: %d\n&quot;, index);    for (i=0;i&lt;10;i++)    {        InsertBST(&amp;T, a[i]);    }    InitHashTable(&amp;H);    InsertHash(&amp;H, 12);    InsertHash(&amp;H, 67);    InsertHash(&amp;H, 56);    InsertHash(&amp;H, 16);    InsertHash(&amp;H, 25);    InsertHash(&amp;H, 37);    InsertHash(&amp;H, 22);    InsertHash(&amp;H, 29);    InsertHash(&amp;H, 15);    InsertHash(&amp;H, 47);    InsertHash(&amp;H, 48);    InsertHash(&amp;H, 34);    for (i = 0; i &lt; H.count; i++)    {        printf(&quot;addr: %d ,key: %d \n&quot;, i, H.elem[i]);    }    SearchHash(H, 47, &amp;addr);    printf(&quot;SearchHash addr: %d\n&quot;, addr);    return 0;}</code></pre><p><img src="https://img-blog.csdnimg.cn/20200428200709715.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NvYXJpbmdMZWVfZmlnaHRpbmc=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><hr><h3 id="THE-END"><a href="#THE-END" class="headerlink" title=" THE END! "></a><font color="red"> THE END! </font></h3>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Data Structure </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>队列的基本操作及实现</title>
      <link href="/2020/04/21/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%B3%BB%E5%88%97%E3%80%91%E9%98%9F%E5%88%97%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%E5%8F%8A%E5%AE%9E%E7%8E%B0/"/>
      <url>/2020/04/21/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%B3%BB%E5%88%97%E3%80%91%E9%98%9F%E5%88%97%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%E5%8F%8A%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="1、队列的定义"><a href="#1、队列的定义" class="headerlink" title="1、队列的定义"></a>1、队列的定义</h2><p>队列是一种特殊的线性表，特殊在于队列限定在一端进行插入，在另一端进行删除。<br>队列有两种物理存储结构：<br>1、顺序队列：循环队列是为了解决队列的“假溢出”现象。<br>2、链队列：队列的链式存储</p><h2 id="2、队列的基本操作（创建、入队、出队、遍历）"><a href="#2、队列的基本操作（创建、入队、出队、遍历）" class="headerlink" title="2、队列的基本操作（创建、入队、出队、遍历）"></a>2、队列的基本操作（创建、入队、出队、遍历）</h2><pre><code class="c">#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define MAX_DATA_SIZE (20)typedef int QElemType;// 1、循环队列的顺序存储结构typedef struct SqQueue{    QElemType data[MAX_DATA_SIZE];    int front;  // 头指针    int rear;   // 尾指针，若队列不空，则指向队列尾元素的下一个位置} SqQueue;// 1.1、初始化一个空队列Qint InitQueue(SqQueue *Q){    Q-&gt;front = 0;    Q-&gt;rear = 0;    return 0;}// 1.2、返回队列Q中的元素个数int GetLengthQueue(SqQueue *Q){    return ((Q-&gt;rear - Q-&gt;front +  MAX_DATA_SIZE) % MAX_DATA_SIZE);}// 1.3、入队列:若队列未满，则插入元素e为Q新的队尾元素int EnterQueue(SqQueue *Q, QElemType e){    if ((Q-&gt;rear + 1) % MAX_DATA_SIZE == Q-&gt;front)    {        printf(&quot;队列满了，无法插入新元素!\n&quot;);        return -1;    }    Q-&gt;data[Q-&gt;rear] = e;    Q-&gt;rear = (Q-&gt;rear + 1) % MAX_DATA_SIZE;    return 0;}// 1.4、出队列:若队列不空，则删除队头元素，并用e返回其值int DeQueue(SqQueue *Q, int *e){    if (Q-&gt;rear == Q-&gt;front)    {        printf(&quot;空栈!\n&quot;);        return -1;    }    *e = Q-&gt;data[Q-&gt;front];    Q-&gt;front =  (Q-&gt;front+1) % MAX_DATA_SIZE;    return 0;}// 2、队列链式存储结构typedef struct Node{    QElemType data;    struct Node *next;} Node, *LinkListPtr;typedef struct LinkQueue{    LinkListPtr front, rear;} LinkQueue;// 2.1 队列初始化为空队列int InitLinkQueue(LinkQueue *LQ){    LinkListPtr QueueHead;    QueueHead = (LinkListPtr) malloc(sizeof(Node));    if (NULL == QueueHead)    {        printf(&quot;QueueHead malloc error!\n&quot;);        return -1;    }    QueueHead-&gt;next = NULL;    LQ-&gt;front = QueueHead;    LQ-&gt;rear = QueueHead;    return 0;}// 2.2 返回队列长度：遍历整个链表int GetLengthLinkQueue(LinkQueue *LQ){    LinkListPtr front = NULL;    int length = 0;    front = LQ-&gt;front;    while (front != LQ-&gt;rear)    {        front = front-&gt;next;        length++;    }    return length;}// 2.3 入队操作：在链表尾部插入结点,对于链队列不存在满的情况int EnterLinkQueue(LinkQueue *LQ, int ele){    LinkListPtr newNode = (LinkListPtr) malloc(sizeof(Node));    if (NULL == newNode)    {        printf(&quot;newNode malloc error!\n&quot;);        return -1;    }    newNode-&gt;data = ele;    newNode-&gt;next = NULL;            LQ-&gt;rear-&gt;next = newNode;    LQ-&gt;rear = newNode;            // 类似链表的尾插法    return 0;}// 2.4 出队操作：若队列非空，则将链表中第一个结点删除，并返回其值给eleint DeleteLinkQueue(LinkQueue *LQ, int *ele){    LinkListPtr Linkfront;    if (LQ-&gt;front == LQ-&gt;rear)    {        printf(&quot;空队列!\n&quot;);        return -1;    }    Linkfront = LQ-&gt;front-&gt;next;    *ele = Linkfront-&gt;data;    LQ-&gt;front-&gt;next = Linkfront-&gt;next;    if (LQ-&gt;rear == Linkfront)    {        LQ-&gt;rear = LQ-&gt;front;    }    free(Linkfront);    Linkfront = NULL;    return 0;}// 2.5 遍历输出队列元素:从队头到队尾int TraverseLinkQueue(LinkQueue *LQ){    LinkListPtr traversePtr = NULL;    if (LQ-&gt;front == LQ-&gt;rear)    {        printf(&quot;空队列!\n&quot;);        return -1;    }    traversePtr = LQ-&gt;front-&gt;next; //指向头结点的下一个结点    while (traversePtr)    {        printf(&quot;%d\t &quot;, traversePtr-&gt;data);        traversePtr = traversePtr-&gt;next;    }    printf(&quot;\n&quot;);    return 0;}// 2.6 返回队头结点元素int GetQueueHead(LinkQueue *LQ, int *e){    LinkListPtr head;    if (LQ-&gt;front == LQ-&gt;rear)    {        return -1;    }    head = LQ-&gt;front-&gt;next;    *e = head-&gt;data;    return -1;}// test demoint main(int argc, char * argv[]){    int ele = 0, length = 0;    LinkQueue LQ;    // 1. 队列初始化    InitLinkQueue(&amp;LQ);    // 2. 入队列    EnterLinkQueue(&amp;LQ, 1);    TraverseLinkQueue(&amp;LQ);    EnterLinkQueue(&amp;LQ, 2);    TraverseLinkQueue(&amp;LQ);    EnterLinkQueue(&amp;LQ, 3);    TraverseLinkQueue(&amp;LQ);    EnterLinkQueue(&amp;LQ, 4);    TraverseLinkQueue(&amp;LQ);    EnterLinkQueue(&amp;LQ, 5);    TraverseLinkQueue(&amp;LQ);    // 3. 返回队列长度    length =  GetLengthLinkQueue(&amp;LQ);    printf(&quot;length: %d\n&quot;, length);    // 4. 出队列    DeleteLinkQueue(&amp;LQ, &amp;ele);    printf(&quot;出队元素: %d \n&quot;, ele);    TraverseLinkQueue(&amp;LQ);    GetQueueHead(&amp;LQ, &amp;ele);    printf(&quot;队头元素: %d \n&quot;, ele);    DeleteLinkQueue(&amp;LQ, &amp;ele);    printf(&quot;出队元素: %d \n&quot;, ele);    TraverseLinkQueue(&amp;LQ);    // 5. 队头元素    GetQueueHead(&amp;LQ, &amp;ele);    printf(&quot;队头元素: %d \n&quot;, ele);    DeleteLinkQueue(&amp;LQ, &amp;ele);    printf(&quot;出队元素: %d \n&quot;, ele);    TraverseLinkQueue(&amp;LQ);    return 0;}</code></pre><hr><h2 id="THE-END"><a href="#THE-END" class="headerlink" title=" THE END! "></a><font color="red"> <strong>THE END!</strong> </font></h2>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Data Structure </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>栈的基本操作及实现</title>
      <link href="/2020/04/21/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%B3%BB%E5%88%97%E3%80%91%E6%A0%88%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%E5%8F%8A%E5%AE%9E%E7%8E%B0/"/>
      <url>/2020/04/21/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%B3%BB%E5%88%97%E3%80%91%E6%A0%88%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%E5%8F%8A%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="1、栈的定义"><a href="#1、栈的定义" class="headerlink" title="1、栈的定义"></a>1、栈的定义</h2><p>栈的定义：<br>限定仅在表尾（指栈顶）进行插入和删除操作的线性表。<br>栈的插入操作称为 入栈；<br>栈的删除操作称为 出栈。</p><p>栈是一种特殊的线性表，特殊之处在于其插入和删除只能在栈顶进行。</p><h2 id="2、栈的两种存储结构及实现"><a href="#2、栈的两种存储结构及实现" class="headerlink" title="2、栈的两种存储结构及实现"></a>2、栈的两种存储结构及实现</h2><p>栈是一种线性表，因此也有两种实现：<br>1、顺序存储结构：顺序栈<br>2、链式存储结构：链栈</p><pre><code class="c">#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define  MAX_DATA_SIZE  (100)typedef int SElemType;// 1.栈的顺序存储结构：顺序栈typedef struct SqStack{    SElemType data[MAX_DATA_SIZE];    int   top; // 表示栈顶指针} SqStack;// 1.1 入栈操作：将元素e插入到栈顶，栈长度加1int Stack_push(SqStack *S, SElemType e){    if (S-&gt;top == MAX_DATA_SIZE-1) //表示栈满    {        printf(&quot;栈满, 无法入栈！\n&quot;);        return -1;    }    S-&gt;top++;    S-&gt;data[S-&gt;top] = e;    return 0;}// 1.2 出栈操作：将栈顶元素出栈，出栈元素值赋给eint Stack_pop(SqStack *S, int *e){    if (S-&gt;top == -1) //空栈    {        printf(&quot;空栈, 无法出栈!\n&quot;);    }    *e = S-&gt;data[S-&gt;top];    S-&gt;top--;    return 0;}//  1.3 顺序栈的遍历输出：从栈顶到栈底int Stack_traverse(SqStack *S){    int top_count = 0;    if(S-&gt;top == -1)    {        printf(&quot;空栈！\n&quot;);        return -1;    }    top_count = S-&gt;top;    while (top_count != -1)    {        printf(&quot;%d\t&quot;, S-&gt;data[top_count]);        top_count--;    }    printf(&quot;\n&quot;);}// 1.4 顺序栈的遍历输出：从栈底到栈顶int Stack_traverse_sequence(SqStack *S){    int i = 0;    if(S-&gt;top == -1)    {        printf(&quot;空栈！\n&quot;);        return -1;    }    while (i &lt;= S-&gt;top)    {        printf(&quot;%d\t&quot;, S-&gt;data[i++]);    }    printf(&quot;\n&quot;);    return 0;}/* 1.5 返回S的元素个数，即栈的长度 */int Stack_length(SqStack *S){    return S-&gt;top+1;}// 1.6 顺序栈获取栈顶元素int Stack_getTop(SqStack *S, int *e){    if (S-&gt;top == -1)    {        printf(&quot;空栈!\n&quot;);    }    *e = S-&gt;data[S-&gt;top];    return 0;}/*  1.7 构造一个空栈S */int InitStack(SqStack *S){    /* S.data=(SElemType *)malloc(MAXSIZE*sizeof(SElemType)); */    S-&gt;top=-1;    return 0;}/*  1.8 把S置为空栈 */int ClearStack(SqStack *S){    S-&gt;top=-1;    return 0;}// 2. 栈的链式存储结构：链栈typedef struct StackNode{    SElemType data;    struct StackNode *next;} StackNode, *LinkStackPtr;typedef struct LinkStack{    LinkStackPtr top;    int count;} LinkStack;// 2.1 链栈的入栈操作int LinkStack_push(LinkStack *LS, SElemType e){    LinkStackPtr s = (LinkStackPtr)malloc(sizeof(StackNode));    if (NULL == s)    {        printf(&quot;malloc failed!\n&quot;);        return -1;    }    s-&gt;data = e;    s-&gt;next = LS-&gt;top;    LS-&gt;top = s;    LS-&gt;count++;    return 0;}// 2.2 链栈的出栈操作int LinkStack_pop(LinkStack *LS, SElemType *e){    LinkStackPtr p;    if (LS-&gt;top == -1)    {        printf(&quot;空栈!\n&quot;);        return -1;    }    *e = LS-&gt;top-&gt;data;  // 先取出出栈元素值    p = LS-&gt;top;         // 将栈顶结点赋值给p    LS-&gt;top = LS-&gt;top-&gt;next;    free(p);    LS-&gt;count--;    return 0;}// 栈的应用：Fibonacci数列int Fbi(int i){    if (i &lt; 2)    {        return i == 0 ? 0 : 1;    }    return Fbi(i-1) + Fbi(i-2);}int main(int argc, char *argv[]){    int e = 0;    // 1、初始化空栈    SqStack SS;    //SS.top = -1;      InitStack(&amp;SS);    Stack_traverse_sequence(&amp;SS);    // 2、入栈操作    Stack_push(&amp;SS, 1);    Stack_traverse_sequence(&amp;SS);    Stack_push(&amp;SS, 2);    Stack_traverse_sequence(&amp;SS);    Stack_push(&amp;SS, 3);    Stack_traverse_sequence(&amp;SS);    // 3、获取栈顶元素    Stack_getTop(&amp;SS, &amp;e);    printf(&quot;栈顶元素: %d\n&quot;, e);    // 4、出栈操作    Stack_pop(&amp;SS, &amp;e);    printf(&quot;出栈元素: %d\n&quot;, e);    Stack_traverse_sequence(&amp;SS);    Stack_pop(&amp;SS, &amp;e);    printf(&quot;出栈元素: %d\n&quot;, e);    Stack_traverse_sequence(&amp;SS);    Stack_pop(&amp;SS, &amp;e);    printf(&quot;出栈元素: %d\n&quot;, e);    Stack_traverse_sequence(&amp;SS);    // 5、栈的应用：递归实现    printf(&quot;%d&quot;, Fbi(5));    return 0;}</code></pre><h2 id="3、栈的应用"><a href="#3、栈的应用" class="headerlink" title="3、栈的应用"></a>3、栈的应用</h2><h3 id="3-1、-递归"><a href="#3-1、-递归" class="headerlink" title="3.1、 递归"></a>3.1、 递归</h3><pre><code class="c">// 栈的应用：Fibonacci数列int Fbi(int i){    if (i &lt; 2)    {        return i == 0 ? 0 : 1;    }    return Fbi(i-1) + Fbi(i-2);}</code></pre><h3 id="3-2、-四则运算表达式求值"><a href="#3-2、-四则运算表达式求值" class="headerlink" title="3.2、 四则运算表达式求值"></a>3.2、 四则运算表达式求值</h3><p>1、后缀表达式求值<br>2、中缀表示式转后缀表达式</p><hr><h2 id="THE-END"><a href="#THE-END" class="headerlink" title=" THE END! "></a><font color="red"> <strong>THE END!</strong> </font></h2>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Data Structure </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线性表的顺序存储结构的基本操作</title>
      <link href="/2020/04/18/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%B3%BB%E5%88%97%E3%80%91%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/"/>
      <url>/2020/04/18/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%B3%BB%E5%88%97%E3%80%91%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="1、线性表的概念"><a href="#1、线性表的概念" class="headerlink" title="1、线性表的概念"></a>1、线性表的概念</h2><p>线性表是零个或多个数据元素的有限序列。<br>线性表的顺序存储结构，指的是用一段地址连续的存储单元依次存储线性表的数据元素。在C语言中可以采用一维数组来实现。</p><h2 id="2、线性表的顺序存储结构的操作（创建、遍历、查找、插入和删除）"><a href="#2、线性表的顺序存储结构的操作（创建、遍历、查找、插入和删除）" class="headerlink" title="2、线性表的顺序存储结构的操作（创建、遍历、查找、插入和删除）"></a>2、线性表的顺序存储结构的操作（创建、遍历、查找、插入和删除）</h2><pre><code class="c">#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define MAX_DATA_SIZE (100)typedef int ElemType;typedef struct SquareList_S{    ElemType data[MAX_DATA_SIZE];    // 数组存储线性表的数据元素    int length;                        // 线性表的当前长度} SqList;// 1. 创建线性表（初始化线性表）int InitSquareList(SqList* SL, int n){    int i = 0;    int x = 0;    printf(&quot;请输入元素：\n&quot;);    SL-&gt;length = n;    for (i = 0; i &lt; n; i++)    {        scanf(&quot;%d&quot;, &amp;x);        SL-&gt;data[i] = x;    }    return 0;}// 2.查找：获取线性表中的第i个位置的元素 时间复杂度 O(1)int GetElemInSquareList(SqList* SL, int i, ElemType *e){    if (SL-&gt;length == 0 || i &lt; 1 || i &gt; SL-&gt;length)    {        return -1;    }    *e = SL-&gt;data[i-1];    printf(&quot;查找的元素是：%d\n&quot;, *e);    return 0;}// 3.顺序遍历输出线性表中的元素int TravesalSquareList(SqList* SL){    int i = 0;    for (i = 0; i &lt; SL-&gt;length; i++)    {        printf(&quot;%d\t&quot;, SL-&gt;data[i]);    }    printf(&quot;\n&quot;);    return 0;}// 4.插入元素 时间复杂度 O(n)int InsertElemSquareList(SqList* SL, int i, int e){    int k = 0;    if (SL-&gt;length == MAX_DATA_SIZE) //线性表已经满了    {        return -1;    }    if (i&lt;1 || i &gt; SL-&gt;length+1) //插入位置不在合理范围内    {        return -1;    }    if (i &lt;= SL-&gt;length) // 若插入位置不在表尾    {        for (k = SL-&gt;length-1; k &gt;=i-1; k--)        {            SL-&gt;data[k+1] = SL-&gt;data[k]; // 后移一个位置        }    }    SL-&gt;data[i-1] = e;    SL-&gt;length++;    return 0;}// 5.删除元素 时间复杂度 O(n)  平均时间复杂度O(n)int DeleteElemSquareList(SqList*SL, int i, int *e){    int k = 0;    if (SL-&gt;length == 0)    {        printf(&quot;空线性表！\n&quot;);        return -1;    }    if (i&lt;1 || i &gt; SL-&gt;length)    {        printf(&quot;请输入合理的删除位置！i=%d\n&quot;, i);    }    *e = SL-&gt;data[i-1];    if (i &lt; SL-&gt;length) //如果删除不是最后位置    {        for (k = i; k &lt;= SL-&gt;length-1; k++) //前移一个位置        {            SL-&gt;data[k-1] = SL-&gt;data[k];        }    }    SL-&gt;length--;    return 0;}int main(int argc, char *argv[]){    SqList L = {0}; //数组创建在栈上    ElemType ele = 0;    // 1.初始化线性表    InitSquareList(&amp;L, 5);    // 2.顺序输出线性表    TravesalSquareList(&amp;L);    // 3.查找元素    GetElemInSquareList(&amp;L, 2, &amp;ele);    // 4.插入元素    InsertElemSquareList(&amp;L, 2, 50);    TravesalSquareList(&amp;L);    // 5.删除元素    DeleteElemSquareList(&amp;L, 2, &amp;ele);    printf(&quot;删除的元素是: %d\n&quot;, ele);    TravesalSquareList(&amp;L);    return 0;}</code></pre><h2 id="THE-END"><a href="#THE-END" class="headerlink" title=" THE END! "></a><font color="red"> <strong>THE END!</strong> </font></h2>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Data Structure </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>编程之美：求子数组的最大和</title>
      <link href="/2020/04/18/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%B3%BB%E5%88%97%E3%80%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E7%BE%8E%EF%BC%9A%E6%B1%82%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%92%8C/"/>
      <url>/2020/04/18/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%B3%BB%E5%88%97%E3%80%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E7%BE%8E%EF%BC%9A%E6%B1%82%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%92%8C/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="1、算法描述"><a href="#1、算法描述" class="headerlink" title="1、算法描述"></a>1、算法描述</h2><p>输入一个整形数组，数组里有正数也有负数。<br>数组中连续的一个或多个整数组成一个子数组，每个子数组都有一个和。<br>求所有子数组的和的最大值。要求时间复杂度为O(n)。<br>例如:<br>输入的数组为1,-2,3,10,-4,7,2,-5<br>和最大的子数组为3,10,-4,7,2<br>因此输出为该子数组的和18。</p><h2 id="2、C编程实现"><a href="#2、C编程实现" class="headerlink" title="2、C编程实现"></a>2、C编程实现</h2><p>针对该问题，采用了暴力穷举解法、分治算法、动态规划算法求解。</p><pre><code class="c">// 方法一：暴力解法 时间复杂度O(N^3)int maxSubarray_org(int a[], int size){    int iMaxSum = INT_MIN;    int sum = 0;    int i = 0, j = 0, k = 0;    for (i = 0; i &lt; size; i++)    {        for (j = i; j &lt; size; j++)        {            sum = 0;            for (k = i; k &lt;= j; k++)            {                sum += a[k];            }            if (sum &gt; iMaxSum)                iMaxSum = sum;        }    }    return iMaxSum;}// 方法一：暴力解法 优化版本 时间复杂度O(N^2)int maxSubarray_org_opt(int a[], int size){    int iMaxSum = INT_MIN;    int sum = 0;    int i = 0, j = 0, k = 0;    for (i = 0; i &lt; size; i++) // 从第i个位置开始寻找连续数据的最大值    {        sum = 0;        for (j = i; j &lt;= size; j++)        {                    sum += a[j];            if (sum &gt; iMaxSum)                iMaxSum = sum;        }    }    return iMaxSum;}// 方法二：采用分治的思想 时间复杂度 O(2*N)int maxSubarray(int a[], int size){    int iMaxSum = 0;    int iLocalSum = 0;    int i = 0;    for(i = 0; i &lt; size; i++)    {        iLocalSum += a[i];        if(iLocalSum &lt; 0)        {            iLocalSum = 0;  // 局部和出现小于0的情况，则设置为0        }        if(iLocalSum &gt; iMaxSum)        {            iMaxSum = iLocalSum; // 更新局部最大和        }    }    if(iMaxSum == 0)    // 子数组最大和出现负数情况下，取数组中的最大值。    {        iMaxSum = a[0];        for(i = 1; i &lt; size; i++)        {            if(iMaxSum &lt; a[i])                iMaxSum = a[i];        }    }    return iMaxSum;}int max(int x, int y){    return (x&gt;y) ? x : y;}// 方法三：动态规划  时间复杂度O(N) 空间复杂度O(2*N)int maxSubarray_DP(int a[], int size){    int Start[50];    int All[50];    int i = 0;    Start[size-1] = a[size-1];    All[size-1] = a[size-1];    for (i = size -2; i &gt;= 0; i--)    {        Start[i] = max(a[i], a[i]+Start[i+1]);        All[i] = max(Start[i], All[i+1]);    }    return All[0];}// 方法四： 动态规划 优化版本 时间复杂度 O(N) 空间复杂度O(1)int maxSubarray_DP_opt(int a[], int size){    int nStart = 0;    int nAll = 0;    int i = 0;    nStart = a[size-1];    nAll = a[size-1];    for(i = size-2; i &gt;=0; i--)    {        nStart = max(a[i], nStart + a[i]);        nAll = max(nStart, nAll);    }    return nAll;}// 方法四：动态规划 另一种简便写法，这种写法体现了数学之美和编程之美！int maxSubarray_DP_opt_v2(int a[], int size){    int nStart = 0;    int nAll = 0;    int i = 0;    nStart = a[size-1];    nAll = a[size-1];    for(i = size-2; i &gt;=0; i--)    {        if (nStart &lt; 0)        {            nStart = 0;        }        nStart += a[i];        if (nStart &gt; nAll)        {            nAll = nStart;        }    }    return nAll;}//test demoint main(int argc, char *argv[]){#if 0    int array[8] = {1,-2,3,10,-4,7,2,-5};    //int array[8] = {-2, 5, 3, -6, 4, -8, 6};#else    int array[8] = {-1,-2,-3,-10,-4,-7,-2,-5};#endif    int max_sum = 0;    max_sum = maxSubarray_DP_opt_v2(array, 8);    printf(&quot;max_sum_subarray: %d    \n&quot;, max_sum);    return 0;}</code></pre><h2 id="THE-END"><a href="#THE-END" class="headerlink" title=" THE END! "></a><font color="red"> <strong>THE END!</strong> </font></h2>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Data Structure </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>单链表的基本操作</title>
      <link href="/2020/04/14/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%B3%BB%E5%88%97%E3%80%91%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/"/>
      <url>/2020/04/14/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%B3%BB%E5%88%97%E3%80%91%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="1、参考"><a href="#1、参考" class="headerlink" title="1、参考"></a>1、参考</h2><p><a href="https://www.cnblogs.com/maluning/p/7966875.html#_label5" target="_blank" rel="noopener">C语言描述链表的实现及操作</a><br><a href="https://blog.csdn.net/qq_44473695/article/details/89282652" target="_blank" rel="noopener">线性表的基本操作及应用（单链表的创建、插入、删除、查找、显示）</a><br>《大话数据结构–程杰》</p><h2 id="2、单链表的基本操作（创建、查找、插入、删除、遍历）"><a href="#2、单链表的基本操作（创建、查找、插入、删除、遍历）" class="headerlink" title="2、单链表的基本操作（创建、查找、插入、删除、遍历）"></a>2、单链表的基本操作（创建、查找、插入、删除、遍历）</h2><p>线性表是一种重要的数据结构。<br>线性表的链式存储结构就是单链表。<br>线性表的顺序存储结构就是数组。</p><p>下面是C语言实现的单链表的代码。</p><pre><code class="c">#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;typedef int ElemType;// 单链表的声明typedef struct _Node_S{    ElemType data;            // 数据域    struct  _Node_S *next;    // 指针域} Node, *LinkList;// 1、创建：从尾部开始创建链表（尾插法）LinkList CreateLinkListTail(int n){    int i = 0;    int x = 0;    Node *L, *pTail;    L = (Node*) malloc(sizeof(Node)); // 整个链表    pTail = L;  //尾结点    pTail-&gt;next = NULL;    printf(&quot;顺序输入元素: \n&quot;);    for (i = 0; i &lt; n; ++i)    {        Node* p; //the node to inserted        p = (Node*) malloc(sizeof(Node));        scanf(&quot;%d&quot;, &amp;x);        // 新加入的结点都作为尾结点放到最后        p-&gt;data = x;     // 数据域赋值        pTail-&gt;next = p; // 尾结点指针指向新结点        p-&gt;next = NULL;  // 新结点指针指向空        pTail = p;         // 将新结点赋值给尾结点    }    //pTail-&gt;next = NULL;    return L;}// 2、创建：从头部开始创建链表（头插法）LinkList CreateLinkListHead(int n){    int i;    int x;    Node* L, *pTail;    L = (Node*) malloc(sizeof(Node)); // 头结点    L-&gt;next = NULL;    printf(&quot;逆序输入元素: \n&quot;);    for (i = 0; i &lt; n; ++i)    {        Node* p; //the node to inserted        p = (Node*) malloc(sizeof(Node));        scanf(&quot;%d&quot;, &amp;x);        // 将新加入的结点插入到头结点的后面        p-&gt;data = x;     // 数据域赋值        p-&gt;next = L-&gt;next; // 将新节点的指针指向头结点的指针        L-&gt;next = p;       // 将头结点的指针指向新结点    }    return L;}//  3、查找：查找链表中的第i个元素int GetEleInLinkList(LinkList l, int i, ElemType* e){    int j;    LinkList p;    p = l-&gt;next;    j = 1;    // 从链表头部开始遍历    while(p &amp;&amp; j&lt;i)    {        p = p-&gt;next;        j++;    }    if (!p || j&gt;i)    {        printf(&quot;没有查找到\n&quot;);        return -1;    }    *e = p-&gt;data;    printf(&quot;The %dth element: %d \n&quot;,i, *e);    return 0;}// 4、插入：在链表中第i个数据插入结点int InsertNodeInLinkList(LinkList ll, int i, ElemType* m){    int j = 1;    LinkList p;    Node* newNode;    p = ll-&gt;next;    while (p &amp;&amp; j&lt;i)    {        p = p-&gt;next;        j++;    }    if (!p || j&lt;i)    {        printf(&quot;没有查找到第%d个数据\n&quot;, i);        return -1;    }    // 查找成功，创建空节点    newNode = (Node*) malloc(sizeof(Node));    if (NULL == newNode)    {        printf(&quot;malloc error!\n&quot;);        return -1;    }    newNode-&gt;data = *m;    newNode-&gt;next = p-&gt;next;    p-&gt;next = newNode;    return 0;}// 5、遍历输出：遍历链表中的每个元素并输出int TranvesalLinkList(LinkList ll){    LinkList p;    p = ll-&gt;next;    if (!p)    {        printf(&quot;空链表！\n&quot;);        return -1;    }    while (p)    {        printf(&quot;%d\t&quot;, p-&gt;data);        p = p-&gt;next;    }    printf(&quot;\n&quot;);    return 0;}// 6、删除：删除链表中的第i个结点，并取出该结点的值int DeleteNodeInLinkList(LinkList ll, int i, ElemType *e){    int j = 1;    LinkList p, q;    p = ll-&gt;next;    while (p &amp;&amp; j &lt; i)    {        j++;        p = p-&gt;next;    }    if (!p || j&gt;i)    {        printf(&quot;没有找到第%d个结点！\n&quot;, i);    }    q = p-&gt;next;    p-&gt;next = q-&gt;next;    *e = q-&gt;data;    printf(&quot;The deleted node data: %d\n&quot;, *e);    free(q);    return 0;}// 7、整表删除int DeletedAllNodeInLinkList(LinkList ll){    LinkList p = ll-&gt;next;    LinkList q;    while (p)    {        q = p-&gt;next;  // 将下一个结点赋值给q        free(p);      // 释放该结点p        p = q;             }    ll-&gt;next = NULL;    return 0;}int main(int argc, int argv[]){    LinkList ll;    int elem = 0;    int value = 50;    // 创建单链表    ll = CreateLinkListTail(5);    // 遍历输出单链表    TranvesalLinkList(ll);    // 查找单链表中结点    GetEleInLinkList(ll, 4, &amp;elem);    // 插入结点    InsertNodeInLinkList(ll, 1, &amp;value);    // 遍历输出单链表    TranvesalLinkList(ll);    // 删除结点    DeleteNodeInLinkList(ll, 1, &amp;elem);    // 遍历输出单链表    TranvesalLinkList(ll);    // 删除整个链表    DeletedAllNodeInLinkList (ll);    // 遍历输出单链表    TranvesalLinkList(ll);    return 0;}</code></pre><h2 id="THE-END"><a href="#THE-END" class="headerlink" title=" THE END! "></a><font color="red"> <strong>THE END!</strong> </font></h2>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Data Structure </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一个int变量引起的随机数异常问题</title>
      <link href="/2020/03/14/%E3%80%90Bugfix%E7%B3%BB%E5%88%97%E3%80%91%E4%B8%80%E4%B8%AAint%E5%8F%98%E9%87%8F%E5%BC%95%E8%B5%B7%E7%9A%84%E9%9A%8F%E6%9C%BA%E6%95%B0%E5%BC%82%E5%B8%B8%E9%97%AE%E9%A2%98/"/>
      <url>/2020/03/14/%E3%80%90Bugfix%E7%B3%BB%E5%88%97%E3%80%91%E4%B8%80%E4%B8%AAint%E5%8F%98%E9%87%8F%E5%BC%95%E8%B5%B7%E7%9A%84%E9%9A%8F%E6%9C%BA%E6%95%B0%E5%BC%82%E5%B8%B8%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="1、问题描述"><a href="#1、问题描述" class="headerlink" title="1、问题描述"></a>1、问题描述</h2><p>在调试一个程序时，在linux64位系统下出现返回较大负数随机数返回值的现象。</p><h2 id="2、问题复现"><a href="#2、问题复现" class="headerlink" title="2、问题复现"></a>2、问题复现</h2><pre><code class="c">#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;typedef struct _handle_s{    unsigned char* srcbuf;    unsigned char* dstbuf;    int        index;    int        iWidth;    int     iHeight;}handle_s;int mem_alloc_check_function(handle_s* h, int width, int height){    h-&gt;srcbuf = (unsigned char*)malloc(width*height*3/2*sizeof(unsigned char));    if (h-&gt;srcbuf==NULL)    {        return -1;    }    h-&gt;dstbuf = (unsigned char*)malloc(width*height*3/2*sizeof(unsigned char));    if (h-&gt;dstbuf==NULL)    {        return -1;    }}int mem_release_function(handle_s* h){    if (h-&gt;srcbuf !=NULL)    {        free(h-&gt;srcbuf);    }    if (h-&gt;dstbuf !=NULL)    {        free(h-&gt;dstbuf);    }}int main(int argc, char* argv[]){    int ret;                    //测试：变量定义之后没有初始化    int i = 0;    handle_s video_handle = {0};    int width = 1280;    int height = 720;    //while(i++ &lt; 1000)    {        ret = mem_alloc_check_function(&amp;video_handle, width, height);        printf(&quot;[int_ret_test] ret: %d\n&quot;, ret);        mem_release_function(&amp;video_handle);    }    return  ret;}</code></pre><p>在windows平台下：<br><img src="https://img-blog.csdnimg.cn/20200314194904495.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NvYXJpbmdMZWVfZmlnaHRpbmc=,size_16,color_FFFFFF,t_70" alt></p><p>在Linux64位平台下：<br><img src="https://img-blog.csdnimg.cn/20200314195051727.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NvYXJpbmdMZWVfZmlnaHRpbmc=,size_16,color_FFFFFF,t_70" alt><br>测试发现，在windows平台下返回值都是很大的正数随机值；在linux平台下返回值会出现较大的负数随机值值或正数随机值。</p><h2 id="3、问题修复"><a href="#3、问题修复" class="headerlink" title="3、问题修复"></a>3、问题修复</h2><p>1、main中ret定义时立即初始化，</p><pre><code class="c">int ret = 0;</code></pre><p>2、mem_alloc_check_function函数在最后添加：</p><pre><code class="c">return 0;</code></pre><h2 id="4、经验总结"><a href="#4、经验总结" class="headerlink" title="4、经验总结"></a>4、经验总结</h2><p>(1). 变量定义时需要立即初始化，否则该变量会成为一个随机数；<br>例如：<br>int变量初始化为0；<br>指针变量初始化为NULL。<br>(2). 在需要返回值的函数中需要给出一个返回值，否则该函数可能会返回一个随机值。<br>(3). 在不同系统平台下，相同的程序代码可能返回不同的运行结果或现象，需要注意不同系统平台的差异。</p><hr><h3 id="THE-END"><a href="#THE-END" class="headerlink" title=" THE END! "></a><font color="red"> THE END! </font></h3>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> Bugfix </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Bugs </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>X86优化之纯汇编优化方法</title>
      <link href="/2020/02/17/%E3%80%90%E4%BC%98%E5%8C%96%E7%B3%BB%E5%88%97%E3%80%91X86%E4%BC%98%E5%8C%96%E4%B9%8B%E7%BA%AF%E6%B1%87%E7%BC%96%E4%BC%98%E5%8C%96%E6%96%B9%E6%B3%95/"/>
      <url>/2020/02/17/%E3%80%90%E4%BC%98%E5%8C%96%E7%B3%BB%E5%88%97%E3%80%91X86%E4%BC%98%E5%8C%96%E4%B9%8B%E7%BA%AF%E6%B1%87%E7%BC%96%E4%BC%98%E5%8C%96%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文属于优化—-CPU优化系列中的X86架构优化的内容，X86架构汇编优化的知识点包含较多，本文主要重点讲述x86架构汇编优化最核心的部分（寄存器使用、数据表示、函数调用规则、指令集使用方法以及demo的编写和调试方法等）。通过阅读本文，可以快速入门X86汇编优化方法。</p><p>本文重点讲述了X86纯汇编优化方法。</p><h2 id="1、参考"><a href="#1、参考" class="headerlink" title="1、参考"></a>1、参考</h2><p><a href="https://blog.csdn.net/listener51/article/details/104098634" target="_blank" rel="noopener">x86汇编优化</a><br><a href="http://www.sohu.com/a/250457235_505888" target="_blank" rel="noopener">X86指令集发展简史和不足 </a><br><a href="https://www.cnblogs.com/TaigaCon/p/7835340.html" target="_blank" rel="noopener">PC平台主要SIMD扩展发展简史</a><br><a href="75144414">[x86]SIMD指令集发展历程表（MMX、SSE、AVX等）</a><br><a href="https://www.agner.org/optimize/optimizing_assembly.pdf" target="_blank" rel="noopener">Optimizing subroutines in assembly language</a><br><a href="https://blog.csdn.net/listener51/article/details/98655248" target="_blank" rel="noopener">【汇编优化】之X86汇编优化</a><br><a href="https://blog.csdn.net/jiangwei0512/article/details/50857185" target="_blank" rel="noopener">asm基础——堆栈框架、调用惯例</a></p><h2 id="2、快速入门知识"><a href="#2、快速入门知识" class="headerlink" title="2、快速入门知识"></a>2、快速入门知识</h2><p><a href="http://www.cs.virginia.edu/~evans/cs216/guides/x86.html" target="_blank" rel="noopener">x86 Assembly Guide</a><br><a href="https://www.cnblogs.com/jiftle/p/8453106.html" target="_blank" rel="noopener">X86汇编快速入门</a></p><h2 id="3、x86架构指令集的寄存器"><a href="#3、x86架构指令集的寄存器" class="headerlink" title="3、x86架构指令集的寄存器"></a>3、x86架构指令集的寄存器</h2><h3 id="3-1-x86架构-32位模式寄存器"><a href="#3-1-x86架构-32位模式寄存器" class="headerlink" title="3.1 x86架构 32位模式寄存器"></a>3.1 x86架构 32位模式寄存器</h3><ul><li>8个32位通用寄存器：<br>EAX/EBX/ECX/EDX/ESI/EDI/EBP/ESP<br>使用说明：可以使用这些通用寄存器存放8位或16位的操作数。比如一个函数可以使用AL、BL、CL以及DL来访问EAX、EBX、ECX和EDX的最低字节（8位），可以使用AX、BX、CX以及DX来访问低16位字节。</li></ul><ul><li>8个64位AVX/SSE寄存器：<br>ST(0)<del>ST(7): 浮点寄存器<br>MM0</del>MM7: MMX（MultiMedia eXtension）整型寄存器（64bit）<br>XMM0~XMM7:SSE（Streaming SIMD Extension）整型寄存器（128bit）</li></ul><p><img src="https://img-blog.csdnimg.cn/20200218094119314.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NvYXJpbmdMZWVfZmlnaHRpbmc=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong>MMX寄存器与ST寄存器的关系：</strong><br>MMX指令主要使用的寄存器为 MM0 ~ MM7，大小为64-bit，这些寄存器是浮点寄存器ST0~ST7（80-bit）的一部分（如下图所示），因此MMX与浮点运算不能同时进行。</p><p><img src="https://img-blog.csdnimg.cn/20200218093844487.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NvYXJpbmdMZWVfZmlnaHRpbmc=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="3-2-x86架构-64位模式寄存器"><a href="#3-2-x86架构-64位模式寄存器" class="headerlink" title="3.2 x86架构 64位模式寄存器"></a>3.2 x86架构 64位模式寄存器</h3><ul><li><p>16个64位通用寄存器：<br>RAX/RBX/RCX/RDX/RSI/RDI/RBP/RSP/R8~R15</p></li><li><p>8个64位MMX寄存器：MM0~MM7</p></li><li><p>16个128位XMM寄存器：XMM0~XMM15</p></li><li><p>16个256位YMM寄存器：YMM0~YMM15（仅AVX指令集使用）</p></li><li><p>32个512位ZMM寄存器 : ZMM0~ZMM31（仅AVX512指令集使用）</p></li></ul><p><strong>使用说明：</strong></p><ul><li>MMX~SSSE3指令集都可以使用MMX寄存器；</li><li>SSE~AVX指令集可以使用XMM寄存器；</li><li>AVX指令集对XMM寄存器作了扩展，从原来的128-bit扩展到了256-bit，256-bit的寄存器命名为 YMM 。<font color="red">YMM的低128-bit是与XMM混用的（即XMM寄存器是YMM寄存器的低128位）。</font>如下图所示：<br><img src="https://img-blog.csdnimg.cn/20200218104211382.png" alt="在这里插入图片描述"><br>注意：AVX只支持256-bit的SIMD浮点数据的并行处理。到AVX2指令集，才支持256-bit的SIMD整型数据的并行处理。</li><li>AVX512指令集把 YMM 扩展到了512-bit的 ZMM ，<font color="red">ZMM的低256-bit与YMM混用（即YMM寄存器是ZMM寄存器的低256位）。</font>如下图所示：<br><img src="https://img-blog.csdnimg.cn/20200218104346267.png" alt="在这里插入图片描述"></li></ul><h2 id="4、x86架构指令集的调用规则"><a href="#4、x86架构指令集的调用规则" class="headerlink" title="4、x86架构指令集的调用规则"></a>4、x86架构指令集的调用规则</h2><h3 id="4-1-x86架构32位模式的函数调用规则"><a href="#4-1-x86架构32位模式的函数调用规则" class="headerlink" title="4.1 x86架构32位模式的函数调用规则"></a>4.1 x86架构32位模式的函数调用规则</h3><p>参考资料：<a href="https://aaronbloomfield.github.io/pdr/book/x86-32bit-ccc-chapter.pdf" target="_blank" rel="noopener">https://aaronbloomfield.github.io/pdr/book/x86-32bit-ccc-chapter.pdf</a></p><p>适用于windows32位系统和linux32位系统下的函数调用。</p><p>C调用规范（The C Calling Convention）<br>调用规则如下：<br><strong>- The Caller’s rules:</strong><br><img src="https://img-blog.csdnimg.cn/20200217163033875.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NvYXJpbmdMZWVfZmlnaHRpbmc=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><strong>-  The Callee’s rules:</strong><br><img src="https://img-blog.csdnimg.cn/2020021716340477.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/202002171634484.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NvYXJpbmdMZWVfZmlnaHRpbmc=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200217163538959.png" alt="在这里插入图片描述"></p><p><strong>- 子函数（callee  function）调用过程中栈内存分布：</strong><br><img src="https://img-blog.csdnimg.cn/20200217162546965.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NvYXJpbmdMZWVfZmlnaHRpbmc=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><font color="red"> 这里特别注意：子函数中第一个参数入栈是存放在[ebp+8]，而不是[ebp+4]，这是因为在ebp的上面还存放了返回地址的内容，占用了4个字节，即[ebp+4]。<br>子函数形参传递：通过栈传递，比如<br>|入栈参数i|栈内存起始地址|备注|<br>—|—|—-|—|<br>stack arg #i|    ESP(4+i*4)|    i从1起|</font></p><p>其中i从0起，譬如 int fuc(int arg0); arg0就放在[rsp + 4 + 4*0]。</p><h3 id="4-2-x86架构64位模式（linux64）调用规范"><a href="#4-2-x86架构64位模式（linux64）调用规范" class="headerlink" title="4.2 x86架构64位模式（linux64）调用规范"></a>4.2 x86架构64位模式（linux64）调用规范</h3><p>参考资料：<a href="https://aaronbloomfield.github.io/pdr/book/x86-64bit-ccc-chapter.pdf" target="_blank" rel="noopener">https://aaronbloomfield.github.io/pdr/book/x86-64bit-ccc-chapter.pdf</a></p><p>C调用规范（The C Calling Convention）<br>调用规则如下：</p><p><strong>- The Caller’s rules:</strong><br><img src="https://img-blog.csdnimg.cn/202002171710454.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NvYXJpbmdMZWVfZmlnaHRpbmc=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><strong>- The Callee’s rules:</strong><br><img src="https://img-blog.csdnimg.cn/20200217171120531.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NvYXJpbmdMZWVfZmlnaHRpbmc=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><strong>- 子函数（callee  function）调用过程中栈内存分布：</strong><br><img src="https://img-blog.csdnimg.cn/20200217171005789.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NvYXJpbmdMZWVfZmlnaHRpbmc=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><font color="red"> 特别注意：<br>关于子函数形参传递：<br>1、前6个参数通过寄存器传送（按照顺序：rdi, rsi,rdx, rcx, r8, r9），多余6个时，其它参数通过栈传递，具体如下：<br>入栈参数i|栈起始地址|备注|<br>—|—|—|<br>stack arg #i|    RSP(8+i*8)|    i从1起<br>其中，i从1开始。==（此处存疑，需要确认！！）==</font></p><p>2、如果参数是浮点型，存放浮点参数的寄存器为XMM0~XMM7。<br>注意：整型参数（6个）从左到右通过寄存器rdi,rsi,rdx,rcx, r8, r9传递，浮点参数（8个）从左到右通过xmm0-xmm7传递，因此形参最大可以通过14个寄存器传递，多余的参数通过栈传递。</p><h3 id="4-3-x86架构64位模式（windows64）调用规范"><a href="#4-3-x86架构64位模式（windows64）调用规范" class="headerlink" title="4.3 x86架构64位模式（windows64）调用规范"></a>4.3 x86架构64位模式（windows64）调用规范</h3><p>参考资料：<a href="https://software.intel.com/en-us/articles/introduction-to-x64-assembly" target="_blank" rel="noopener">https://software.intel.com/en-us/articles/introduction-to-x64-assembly</a></p><p>C调用规范（The C Calling Convention）<br>调用规则如下：<br><img src="https://img-blog.csdnimg.cn/20200217194544154.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NvYXJpbmdMZWVfZmlnaHRpbmc=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><font color="red"> 特别注意：<br>关于子函数形参传递：<br>（1）前4个参数(整数)通过寄存器传送（RCX,RDX,R8,R9），多余4个时，其它参数通过栈传递，具体如下：<br>入栈参数i|存放栈起始地址|备注|<br>—|—|—|<br>stack arg #i|    RSP(40+i*8)    |i从1起</font></p><p>其中，i从0开始。为什么从40开始？==此处存疑，有待确认==</p><p>参考网址：<br><a href="https://eli.thegreenplace.net/2011/09/06/stack-frame-layout-on-x86-64/" target="_blank" rel="noopener">https://eli.thegreenplace.net/2011/09/06/stack-frame-layout-on-x86-64/</a><br><a href="http://www.360doc.com/content/14/1221/21/3242454_434681142.shtml" target="_blank" rel="noopener">http://www.360doc.com/content/14/1221/21/3242454_434681142.shtml</a><br><font color="red"></font></p><font color="red">（2）如果参数是浮点型，存放浮点参数的寄存器为XMM0， XMM1， XMM2， XMM3。<p>注意：第一个参数如果是整型就存放在RCX中，如果是浮点型就存放在XMM0中；第二个参数如果是整型就存放在RDX中，如果是浮点型就存放在XMM1中；以此类推。</p><h3 id="4-4-调用规则实例"><a href="#4-4-调用规则实例" class="headerlink" title="4.4 调用规则实例"></a>4.4 调用规则实例</h3><p>实例参考：<a href="https://aaronbloomfield.github.io/pdr/book/x86-32bit-ccc-chapter.pdf" target="_blank" rel="noopener">https://aaronbloomfield.github.io/pdr/book/x86-32bit-ccc-chapter.pdf</a></p><p>以x86架构32位模式为例，此汇编程序调用一个具有三个参数的函数_myFunc，其中第一个参数为eax，第二个参数为常数216，第三个参数为var指示的内存中的值。</p><p>调用者Caller：</p><pre><code class="asm">push [var] ; Push last parameter firstpush 216   ; Push the second parameterpush eax   ; Push first parameter lastcall _myFunc ; Call the function (assume C naming)add esp, 12</code></pre><p>被调用者Callee:</p><pre><code class="asm">.486.MODEL FLAT.CODEPUBLIC _myFunc_myFunc PROC  ; Subroutine Prologue  push ebp     ; Save the old base pointer value.  mov ebp, esp ; Set the new base pointer value.  sub esp, 4   ; Make room for one 4-byte local variable.  push edi     ; Save the values of registers that the function  push esi     ; will modify. This function uses EDI and ESI.  ; (no need to save EBX, EBP, or ESP)  ; Subroutine Body  mov eax, [ebp+8]   ; Move value of parameter 1 into EAX  mov esi, [ebp+12]  ; Move value of parameter 2 into ESI  mov edi, [ebp+16]  ; Move value of parameter 3 into EDI  mov [ebp-4], edi   ; Move EDI into the local variable  add [ebp-4], esi   ; Add ESI into the local variable  add eax, [ebp-4]   ; Add the contents of the local variable                     ; into EAX (final result)  ; Subroutine Epilogue  pop esi      ; Recover register values  pop  edi  mov esp, ebp ; Deallocate local variables  pop ebp ; Restore the caller&#39;s base pointer value  ret_myFunc ENDPEND</code></pre><p>x86架构指令集32位在windows系统和Linux/Unix系统下函数调用规范是一样的，但是64位下windows系统和Linux/Unix系统下函数调用规范不同，需要保存的寄存器也是不一样。在不同系统平台下具体的寄存器使用规则如下图所示：<br><img src="https://img-blog.csdnimg.cn/20200217201708226.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NvYXJpbmdMZWVfZmlnaHRpbmc=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="5、x86架构指令集使用方法"><a href="#5、x86架构指令集使用方法" class="headerlink" title="5、x86架构指令集使用方法"></a>5、x86架构指令集使用方法</h2><p>在介绍x86架构指令集的使用方法之前，我们先了解一下x86架构和SIMD的基本知识。</p><ul><li><p>x86架构：CISC(Complex Instruction Set Computer) 复杂指令集，特点：<br>CISC 在微指令集的每个小指令可以执行一些较低阶的硬件操作，指令数目多而且复杂，每条指令的长度并不相同。因为指令执行较为复杂所以每条指令花费的时间较长，但每条指令可以处理的工作较为丰富。常见的 CISC 微指令 CPU 主要有 AMD、Intel、VIA等的 x86架构的 CPU。<br>对比v.s.：另一大类CPU架构：精简指令集 RISC(Reduced Instruction Set Computer)，RISC中典型的CPU架构就是ARM架构。</p><p>参考网址：<a href="http://mini.eastday.com/bdmip/190522180221360.html#" target="_blank" rel="noopener">1分钟弄懂ARM架构和x86架构的区别</a><br><a href="https://blog.csdn.net/jiangwei0512/article/details/87895814" target="_blank" rel="noopener">x86架构——架构基础</a></p></li><li><p>SIMD简介：Single Instruction Multiple Data，简称SIMD。SIMD描述的是微处理器中单条指令能完成对数据的并行处理。SIMD所使用的是特殊的寄存器，一个寄存器上存储有多个数据，在进行SIMD运算时，这些数据会被分别进行处理，以此实现了数据的并行处理。<br>TIPS：对比ARM架构的SIMD：ARM NEON 。x86架构中的SIMD寄存器有MMX寄存器、XMM寄存器、YMM寄存器、ZMM寄存器以及ST(x)寄存器。ARM架构中的SIMD寄存器有NEON寄存器（s/d/v）。</p></li></ul><p><strong>指令集参考官方手册(重要)：</strong><br><a href="https://software.intel.com/en-us/download/intel-64-and-ia-32-architectures-sdm-combined-volumes-2a-2b-2c-and-2d-instruction-set-reference-a-z" target="_blank" rel="noopener">Intel® 64 and IA-32 Architectures Software Developer’s Manual Combined Volumes 2A, 2B, 2C, and 2D: Instruction Set Reference, A-Z</a></p><h3 id="5-1-数据表示和寻址方式"><a href="#5-1-数据表示和寻址方式" class="headerlink" title="5.1 数据表示和寻址方式"></a>5.1 数据表示和寻址方式</h3><p><strong>声明静态数据区：</strong><br>可以在X86汇编语言中用汇编指令.DATA声明静态数据区（类似于全局变量），数据以单字节、双字节、或双字（4字节）的方式存放，分别用DB,DW, DD指令表示声明内存的长度。在汇编语言中，相邻定义的标签在内存中是连续存放的。</p><pre><code class="asm">.DATA               var    DB 64           ;声明一个字节，并将数值64放入此字节中var2    DB ?        ; 声明一个为初始化的字节.DB 10                ; 声明一个没有label的字节，其值为10.X    DW ?            ; 声明一个双字节，未初始化.Y    DD 30000        ; 声明一个4字节，其值为30000.</code></pre><p><strong>寻址方式：</strong><br>现代X86处理器32位模式具有2^32字节的寻址空间。支持立即寻址、直接寻址、寄存器间接寻址、寄存器相对寻址等寻址方式。</p><p>例如：</p><pre><code>mov eax, [ebx]        ;寄存器间接寻址mov eax, [esi-4]mov [esi+eax], clmov edx, [esi+4*ebx]  </code></pre><h3 id="5-2-指令格式和通用指令"><a href="#5-2-指令格式和通用指令" class="headerlink" title="5.2 指令格式和通用指令"></a>5.2 指令格式和通用指令</h3><p><strong>指令格式</strong>：<br>详见：<strong>2.1 INSTRUCTION FORMAT FOR PROTECTED MODE, REAL-ADDRESS MODE,AND VIRTUAL-8086 MODE</strong><br><img src="https://img-blog.csdnimg.cn/20200218173632538.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NvYXJpbmdMZWVfZmlnaHRpbmc=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><strong>通用指令：</strong><br>1、数据传送指令：<br><strong>mov（移动指令）</strong><br>mov: 将第二个操作数（寄存器内容或者内存中的值）复制到第一个操作数（寄存器或内存）。<br>特别注意：mov不能实现直接从内存到内存的复制。</p><pre><code class="asm">mov &lt;reg&gt;,&lt;reg&gt;mov &lt;reg&gt;,&lt;mem&gt;mov &lt;mem&gt;,&lt;reg&gt;mov &lt;reg&gt;,&lt;const&gt;mov &lt;mem&gt;,&lt;const&gt;</code></pre><p>Examples:</p><pre><code class="asm">mov eax, ebx              ; 将ebx的值拷贝到eaxmov byte ptr [var], 5   ; 将5保存找var指示内存中的一个字节中</code></pre><p><strong>push（入栈指令）</strong><br>push指令将操作数压入内存的栈中，栈是程序设计中一种非常重要的数据结构，其主要用于函数调用过程中，其中ESP只是栈顶。在压栈前，首先将ESP值减4（X86栈增长方向与内存地址编号增长方向相反），然后将操作数内容压入ESP指示的位置。其语法如下所示：</p><pre><code class="asm">push &lt;reg32&gt;push &lt;mem&gt;push &lt;con32&gt;</code></pre><p>Examples：</p><pre><code class="asm">push eax — 将eax内容压栈push [var] — 将var指示的4直接内容压栈</code></pre><p><strong>pop（出栈指令）</strong><br>pop指令与push指令相反，它执行的是出栈的工作。它首先将ESP指示的地址中的内容出栈，然后将ESP值加4. 其语法如下所示：</p><pre><code class="asm">pop &lt;reg32&gt;pop &lt;mem&gt;</code></pre><p>Examples：</p><pre><code class="asm">pop edi — pop the top element of the stack into EDI.pop [ebx] — pop the top element of the stack into memory at the four bytes starting at location EBX.</code></pre><p><strong>lea— Load effective address</strong><br> lea实际上是一个载入有效地址指令，将第二个操作数表示的地址载入到第一个操作数（寄存器）中。其语法如下所示：</p><p>Syntax</p><pre><code>lea &lt;reg32&gt;,&lt;mem&gt;</code></pre><p>Examples：</p><pre><code class="asm">lea eax, [var] — var指示的地址载入eax中.lea edi, [ebx+4*esi] — ebx+4*esi表示的地址载入到edi中，这实际是上面所说的寻址模式的一种表示</code></pre><p>2、算术和逻辑指令<br>add，sub，inc，dec,imul，idiv<br>and，or，xor，not，neg，shl，shr</p><p>3、控制转移指令<br>jmp<br>jcondition<br>cmp<br>call <label><br>ret</label></p><h3 id="5-3-MMX指令"><a href="#5-3-MMX指令" class="headerlink" title="5.3 MMX指令"></a>5.3 MMX指令</h3><p>MMX instructions perform SIMD operations on <font color="red"><strong>packed</strong></font> byte, word, or doubleword <font color="red"><strong>integers</strong></font> located in <strong>MMX registers</strong>.</p><h4 id="5-3-1-MMX指令简介"><a href="#5-3-1-MMX指令简介" class="headerlink" title="5.3.1 MMX指令简介"></a>5.3.1 MMX指令简介</h4><p>多媒体扩展指令（MultiMedia eXtention），该指令由Intel在1996年为Pentium处理器开发，包括了<strong>57条多媒体指令</strong>，可以i一次处理多个数据。但是<strong>MMX指令不能与X86浮点运算指令同时执行</strong>，在某些场合使用受到一定限制。</p><p>MMX指令主要使用的寄存器为 MM0 ~ MM7，大小为64-bit，这些寄存器是浮点寄存器ST0~ST7（80-bit）的一部分，因此MMX指令运算与浮点运算不能同时进行。</p><p>MMX指令能一次性地操作1个64-bit的数据、或者两个32-bit的数据、或者4个16-bit的数据、或者8个8-bit的数据。</p><p>MMX的指令除了 emms , movd 以及 movq 之外，其余都以字母p开头，字母p代表packed，即表示同时操作多个数据。<font color="red"><strong>MMX指令处理的数据皆为整型，不能处理浮点数据。</strong></font></p><p><font color="red"><strong>因此，MMX处理的数据类型为：</strong></font><br>1个64位、两个打包的32位、4个16位或者8个8位整型数据。</p><h4 id="5-3-2-MMX指令使用"><a href="#5-3-2-MMX指令使用" class="headerlink" title="5.3.2 MMX指令使用"></a>5.3.2 MMX指令使用</h4><p>参考：<a href="https://blog.csdn.net/shaqoneal/article/details/45951649" target="_blank" rel="noopener">使用MMX/SSE汇编指令集优化视频开发</a><br>MMX指令集从功能上可以分为8大类：数据传送指令、算术运算指令、比较运算指令、类型转换指令、扩展压缩数据指令、逻辑运算指令、移位运算指令、状态清除指令。指令列表如下：<br><img src="https://img-blog.csdnimg.cn/20200219110129369.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NvYXJpbmdMZWVfZmlnaHRpbmc=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200219110140387.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NvYXJpbmdMZWVfZmlnaHRpbmc=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>下面对上面这8大类MMX/SSE/SSE2/AVX/AVX2/AVX512指令进行简单介绍：<br><strong>（1）数据传送指令：</strong><br>数据传送指令实现MMX寄存器同内存之间以及MMX寄存器与通用寄存器之间的双向数据传送功能。</p><p>MOVD：实现32位（4字节）的数据传送；</p><pre><code class="asm">movd eax, mm0    ;只取mm0的低32位数据movd mm1, ecxmovd [eax], mm0</code></pre><p>MOVQ：实现64位（8字节）的数据传送；</p><pre><code class="asm">movq rax, mm0movq mm0, raxmovq [eax], mm0</code></pre><p>特别注意：源操作数和目的操作数可以是通用寄存器、MMX寄存器、XMM寄存器或者内存位置，但是movd/movq指令不能用于MMX寄存器之间、XMM寄存器之间，通用寄存器之间，或者内存位置之间传送数据。</p><p><strong>（2）算术运算指令</strong><br>算数运算指令对打包的数据类型实现加法、减法、乘法和乘加操作。</p><ul><li>PADDB/PADDW/PADDD和PSUBB/PSUBW/PSUBD指令分别在环绕模式下对源和目标操作数进行有符号或无符号的相加和相减操作。每一组的三个指令分别对应字节型、字形和双字型数据。</li><li>PADDSB/PADDSW和PSUBSB/PSUBSW指令分别在有符号饱和模式下进行相加和相减操作。两个指令分别处理字节型和字型数据。</li><li>PADDUSB/PADDUSW和PSUBUSB/PSUBUSW指令分别在无符号饱和模式下进行相加和相减操作。两个指令分别处理字节型和字型数据。</li><li>PMULHW和PMULLW指令执行源和目标操作数的乘法操作，并分别将乘积的高字和低字保存到目标操作数中。</li><li>PMADDWD指令计算源和目标操作数有符号部分的乘积，并将产生的4个32位双字的中间结果成对相加，获得两个32位双字。</li><li>VPADDB/VPADDW/VPADDQ指令和VPSUBB/VPSUBW/VPSUBW用于AVX~AVX512指令集，支持三个操作数，实现加法和减法操作。</li></ul><pre><code class="asm">paddw [rax], mm0</code></pre><p><strong>（3）比较指令</strong><br>PCMPEQB/PCMPEQW/PCMPEQD— Compare Packed Data for Equal</p><p>PCMPEQB/PCMPEQW/PCMPEQD和PCMPGTB/PCMPGTW/PCMPGTD指令按照有符号类型数据比较源和目标操作数进行相等比较（EQ）或大于比较（GT）。</p><p>对于相等比较，如果一对数据元素相等，则目标操作数中的相应数据元素设置为全 1；否则设置为全 0。对于大于比较，如果目标操作数中的数据元素大于源操作数中相应的数据元素，则目标操作数中的相应数据元素设置为全 1；否则设置为全 0。</p><p><strong>（4）类型转换指令</strong><br>PACKSSWB/PACKSSDW—Pack with Signed Saturation</p><p>PACKSSWB指令将有符号字转换成为有符号的字节；PACKSSDW将有符号的双字转换成为有符号的字；转换过程都按照有符号饱和模式进行。</p><p>PACKUSWB指令将有符号的字转换为无符号的字节，转换过程按照无符号饱和模式进行。</p><pre><code class="asm">PACKSSWB mm1, mm2PACKUSWB mm1, mm2</code></pre><p><strong>（5）扩展压缩数据指令</strong><br>PUNPCKHBW/PUNPCKHWD/PUNPCKHDQ/PUNPCKHQDQ— Unpack High Data<br>PUNPCKLBW/PUNPCKLWD/PUNPCKLDQ/PUNPCKLQDQ—Unpack Low</p><p>PUNPCKHBW/PUNPCKHWD/PUNPCKHDQ指令和PUNPCKLBW/PUNPCKLWD/PUNPCKLDQ分别将源于目标操作数的高位数据和低位数据取出并交错排入目标操作数中。PUNPCKHBW和PUNPCKLBW的示意图如下：<br><img src="https://img-blog.csdnimg.cn/20200219155541421.png" alt="在这里插入图片描述"><br>PUNPCKHBW操作示意图</p><p><img src="https://img-blog.csdnimg.cn/20200219155548706.png" alt="在这里插入图片描述"><br>PUNPCKLBW操作示意图</p><pre><code class="asm">PUNPCKHBW  mm0, mm1       ; MMXPUNPCKHBW xmm0, xmm1     ; SSE2PUNPCKHBW xmm0, xmm1, xmm2    ; AVXPUNPCKHBW ymm1, ymm2, ymm3     ; AVX2PUNPCKHBW zmm1, zmm2, zmm3     ; AVX512</code></pre><p><strong>（6）逻辑运算指令：</strong></p><p>PAND——逻辑按位与；<br>PANDN——逻辑按位与非；<br>POR——逻辑按位或；<br>PXOR——逻辑按位或非；</p><pre><code class="asm">PAND mm0, mm1          ; MMXPAND xmm1, xmm2     ; SSE2VPAND xmm1, xmm2, xmm3    ; AVXVPAND ymm1, ymm2, ymm3    ; AVX2VPANDD zmm1, zmm2, zmm3    ; AVX512</code></pre><p><strong>（7）位移指令：</strong><br>位移指令有逻辑左移、逻辑右移和算数右移三种。<br>PSLLW/PSLLD/PSLLQ—Shift Packed Data Left Logical</p><p>PSLLW/PSLLD/PSLLQ和PSRLW/PSRLD/PSRLQ实现逻辑左移和右移操作，并用0填充空出来的高位或低位。支持字型、双字型和四字型数据；PSRAW/PSRAD实现算数右移操作，并将符号位拷贝到右移所空出的比特位上。</p><pre><code class="asm">PSLLW mm0, mm1        ; MMXPSLLW xmm1, xmm2    ; SSE2PSLLW mm0, imm8        ; MMXPSLLW xmm1, imm8    ; SSE2VPSLLW xmm1, xmm2, xmm3 ; AVXVPSLLW xmm1, xmm2, imm8    ; AVXVPSLLW ymm1, ymm2, ymm3    ; AVX2VPSLLW ymm1, ymm2, imm8    ; AVX2</code></pre><p><strong>（8）状态清除指令</strong><br>EMMS–Empty MMX Technology State<br>作用：设置x87 FPU标签字中的所有标签都为空（全是1）。<br>使用场景：EMMS指令用于将MMX状态清空。该指令在一个MMX程序结束时执行。(The EMMS instruction must be used to clear the MMX technology state at the end of all MMX technology procedures or subroutines and before calling other procedures or subroutines that may execute x87 floating-point instructions.)</p><pre><code class="asm">emms</code></pre><h3 id="5-4-SSE指令"><a href="#5-4-SSE指令" class="headerlink" title="5.4 SSE指令"></a>5.4 SSE指令</h3><p>SSE instructions operate on <strong>packed singleprecision floating-point</strong> values contained in <strong>XMM registers</strong> and on <strong>packed integers</strong> contained in <strong>MMX registers</strong>.</p><p>Intel于1999年在Pentium III时对SIMD做了扩展，名为Streaming SIMD eXtensions（SSE），AMD则是在2001年发布的Athlon XP开始支持SSE。与MMX不同，SSE采用了独立的寄存器组 XMM0 ~ XMM7，64位模式下为 XMM0 ~ XMM15 ，并且这些寄存器的长度也增加到了128-bit。</p><p>SSE对MMX处理整型数据的指令做了扩展，添加了几条用于处理整型数据的指令，同样以字母p开头。不过SSE新增指令大多是对浮点数据并行处理的指令，这类指令以两个字母ss或者ps为结尾。ss代表了scalar single-precision，ps代表了packed single-precision。</p><p>SSE指令使用方法同5.3.2小节。</p><p><font color="red"><strong>SSE指令操作的数据类型为：</strong></font><br>打包的单精度浮点数（同时操作4个32位的单精度浮点数）</p><p><font color="red"><strong>SSE2指令操作的数据类型为：</strong></font></p><ul><li>128位打包双精度浮点数：包括2个双精度浮点数；</li><li>128位打包整数：可以包括16个字节、8个字、4个双字或者2个四字的整数。</li></ul><h3 id="5-5-AVX-AVX2指令"><a href="#5-5-AVX-AVX2指令" class="headerlink" title="5.5 AVX/AVX2指令"></a>5.5 AVX/AVX2指令</h3><p>AVX/AVX2指令使用方法同5.3.2小节。</p><p>Advanced Vector eXtentions（AVX）在2008年由Intel与AMD提出，并于2011年分别在Sandy Bridge以及Bulldozer架构上提供支持。AVX的主要改进在于对寄存器长度的扩展以及提供了更灵活的指令集。</p><p>AVX对 XMM 寄存器做了扩展，从原来的128-bit扩展到了256-bit，256-bit的寄存器命名为 YMM 。YMM的低128-bit是与XMM混用的。</p><p>AVX对SSE指令集做了扩展，对SSE指令添加了前缀v（VEX）。</p><p><font color="red"><strong>AVX指令操作的数据类型：</strong></font></p><ul><li>128位打包整数：可以包括16个字节、8个字、4个双字或者2个四字的整数。</li><li>256位打包双精度浮点数：包括4个双精度浮点数。</li></ul><p><font color="red"><strong>AVX2指令操作的数据类型为：</strong></font></p><ul><li>256位打包整数：可以包括32个字节，16个字，8个双字或者4个四字的整数。</li><li>256位打包双精度浮点数：包括4个双精度浮点数。</li></ul><h3 id="5-6-AVX512指令"><a href="#5-6-AVX512指令" class="headerlink" title="5.6 AVX512指令"></a>5.6 AVX512指令</h3><p>AVX-512由Intel在2013年提出，并在2016年推出首次支持了AVX-512的处理器Xeon Phi x200 (Knights Landing)。</p><p>如扩展名所示，AVX-512主要改进是把SIMD寄存器扩展到了512-bit。其主要新增的特性可以归纳如下：</p><ul><li>把 YMM 扩展到了512-bit的 ZMM ，ZMM的低256-bit与YMM混用。YMM / ZMM 寄存器的数量增加到了32个，其中 YMM8 ~ YMM31 / ZMM8 ~ ZMM31 只有CPU工作在64位模式下才能使用。</li><li>支持opmask。SIMD指令一般都是操作寄存器上的多组数据，此处增加的opmask就是用于控制其中的各组数据是否需要执行，格式如<code>VADDPS zmm1 {k1}{z}, zmm2, zmm3</code>，当中的k1就是opmask寄存器，z表示对不进行操作的那组数据，往目标寄存器写0。一共有7个opmask register（k0 ~ k7）。</li><li>操作512-bit的ZMM时使用的前缀为EVEX，实际上一些汇编器用的都是v作为指令前缀。</li></ul><h3 id="5-7-小结"><a href="#5-7-小结" class="headerlink" title="5.7 小结"></a>5.7 小结</h3><p>下图说明了不同SIMD扩展（MMX、SSE、SSE2、SSE3、SSSE3、SSE4）以及它们操作的数据类型和这些数据类型如何打包成XMM寄存器和MMX寄存器。<br><img src="https://img-blog.csdnimg.cn/20200218154141335.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NvYXJpbmdMZWVfZmlnaHRpbmc=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="6、x86架构指令集纯汇编优化demo编写"><a href="#6、x86架构指令集纯汇编优化demo编写" class="headerlink" title="6、x86架构指令集纯汇编优化demo编写"></a>6、x86架构指令集纯汇编优化demo编写</h2><p>x86纯汇编优化demo：</p><pre><code class="c">## C代码</code></pre><pre><code class="asm">## X86 纯汇编代码</code></pre><h2 id="7、x86架构汇编环境搭建以及调试方法"><a href="#7、x86架构汇编环境搭建以及调试方法" class="headerlink" title="7、x86架构汇编环境搭建以及调试方法"></a>7、x86架构汇编环境搭建以及调试方法</h2><h3 id="7-1-windows平台下环境搭建"><a href="#7-1-windows平台下环境搭建" class="headerlink" title="7.1 windows平台下环境搭建"></a>7.1 windows平台下环境搭建</h3><p>参考：<br><a href="http://www.cs.virginia.edu/~evans/cs216/guides/vsasm.html" target="_blank" rel="noopener">Guide to Using Assembly in Visual Studio .NET</a></p><h3 id="7-2-x86架构汇编调试方法"><a href="#7-2-x86架构汇编调试方法" class="headerlink" title="7.2 x86架构汇编调试方法"></a>7.2 x86架构汇编调试方法</h3><h2 id="8、x86架构指令集使用注意事项"><a href="#8、x86架构指令集使用注意事项" class="headerlink" title="8、x86架构指令集使用注意事项"></a>8、x86架构指令集使用注意事项</h2><h3 id="8-1-x86汇编优化公共头解析"><a href="#8-1-x86汇编优化公共头解析" class="headerlink" title="8.1 x86汇编优化公共头解析"></a>8.1 x86汇编优化公共头解析</h3><p>为什么要使用公共头？<br>统一不同系统平台的调用规则！！</p><p>由于win32和linux32是同一套函数调用规则，而win64和linux64的函数调用规则不同，为了方便编写和移植代码，需要通过%define关键字来统一这些区别，因此推荐使用开源代码：<a href="https://github.com/FFmpeg/FFmpeg/tree/master/libavutil/x86" target="_blank" rel="noopener">https://github.com/FFmpeg/FFmpeg/tree/master/libavutil/x86</a> 中的x86inc.asm以及x86util.asm头，FFmpeg中的这两个头实际上是采用x264代码中的。</p><p>详细可参考：<br><a href="https://blog.csdn.net/listener51/article/details/86516187" target="_blank" rel="noopener">【汇编优化】之X86架构优化公用头讲解</a><br><a href="https://blog.csdn.net/shakingwaves/article/details/70426894" target="_blank" rel="noopener">FFmpeg x86汇编优化一–x86inc.asm分析</a></p><hr><h2 id="THE-END"><a href="#THE-END" class="headerlink" title=" THE END! "></a><font color="red"> THE END! </font></h2></font>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 优化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> X86 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一个人最好的生活状态</title>
      <link href="/2020/02/17/%E3%80%90Life%E7%B3%BB%E5%88%97%E3%80%91%E4%B8%80%E4%B8%AA%E4%BA%BA%E6%9C%80%E5%A5%BD%E7%9A%84%E7%94%9F%E6%B4%BB%E7%8A%B6%E6%80%81/"/>
      <url>/2020/02/17/%E3%80%90Life%E7%B3%BB%E5%88%97%E3%80%91%E4%B8%80%E4%B8%AA%E4%BA%BA%E6%9C%80%E5%A5%BD%E7%9A%84%E7%94%9F%E6%B4%BB%E7%8A%B6%E6%80%81/</url>
      
        <content type="html"><![CDATA[<p>[TOC]﻿</p><h2 id="一个人最好的状态是，有事做，有人爱，有所期待。"><a href="#一个人最好的状态是，有事做，有人爱，有所期待。" class="headerlink" title="一个人最好的状态是，有事做，有人爱，有所期待。"></a>一个人最好的状态是，有事做，有人爱，有所期待。</h2><p>看到一篇文章，对一个人最好的生活状态解释的非常到位，转载在这里感悟学习。</p><p>转载自：<a href="https://blog.csdn.net/dyq1995/article/details/86597057" target="_blank" rel="noopener">https://blog.csdn.net/dyq1995/article/details/86597057</a></p><p>有人说，一千个人，有一千种活法，但每个人终其一生，追求的不过是一个自己所认为的最好的生活状态。这就涉及到价值观和人生观的不同了，但我认为大部分人应该会赞成：最好的生活状态无非就是——有事做，有人爱，有所期待。</p><h3 id="1、有事做"><a href="#1、有事做" class="headerlink" title="1、有事做"></a>1、有事做</h3><p>我曾问我的好朋友：你最想做的事情是什么？她说：我最想做的事情，就是可以什么也不用做。</p><p>一个多月前，她辞职回了老家，上个周末给我发消息：“太无聊了，在家没有什么事情可以做。”当真的没事儿做的时候，她才发现，原来有事可做是一件多么幸福的事。</p><p>我们都听说过一个词“闲愁”，这个词，我是这样理解的，人一闲下来，就容易胡思乱想，生出各种愁绪，反过来，人一忙起来，哪还有那么多的心思去忧愁呢？人总需要做些什么，才不会觉得心里荒芜，而能把一件事做好，那种幸福感是无可比拟的。</p><p>在电影《实习生》里，70岁的退休老人本，为了排解自己孤独的老年生活，重返职场，成为了一名高龄实习生，他交新朋友，学习新技能。凭着自己丰富的人生经历，甚至成了老板的人生导师，将老年生活过得有声有色，重新找到了自己人生的意义。人总需要做些什么，才能体现出自己的价值，虽然做事情有时候会痛苦，但没事可做却让人更痛苦。能够有事可做，而且能够把它做好，能够体现自己的价值，就是一种难得的幸福。</p><h3 id="2、有人爱"><a href="#2、有人爱" class="headerlink" title="2、有人爱"></a>2、有人爱</h3><p>作家雨果说过这样一句话：人生至福，就是确信有人爱你。</p><p>爱的确是一个人对抗世界的良药，也是一个人获得幸福和快乐的源泉。</p><p>周末坐一辆摩的回家，载我的是一位四五十来岁的大叔，皮肤晒得黑里透红，笑起来一口白牙，我一上车，他就很开心的和我攀谈起来。我心里奇怪，他每天做这风里来雨里去的工作，那么辛苦，怎么还能那么开心？于是我问他，他笑着回答：</p><p>今天我生日，一早我儿子和女儿就给我发来生日快乐的祝福和生日红包，我老婆说等她晚上下班给我做一顿好吃的，被那么多人惦记着，能不开心吗？虽然工作辛苦点儿，但是儿女孝顺，家庭和睦，彼此关爱，就是一种幸福。的确，当一个人被人爱着，他的心就好像在发光，即使是做着辛苦的工作，也会觉得很幸福。</p><h3 id="3、有所期待"><a href="#3、有所期待" class="headerlink" title="3、有所期待"></a>3、有所期待</h3><p>这世界上最美好的事情，就是心里有所期待。当心里有了期待，平常的日子也有了色彩。</p><p>人最幸福的时候，不是获得幸福的那一刻，而是期待幸福降临的时候。</p><p>就像《小王子》里狐狸对小王子说的一段话：你每天下午四点钟来，我从三点钟起就开始觉得幸福，到四点钟的时候，我会坐立不安。生活中总是难免有痛苦和缺憾，但因为心里有了对未来的期待，就多了分走出目前面临的困境和泥潭的力量和勇气。</p><p>就像在电影《肖申克的救赎》中的安迪一样，他被冤入狱几十年，在监狱中遭受各种欺辱，但他从来没有放弃心中对美好生活的期待。他说心里有些东西，是这些围墙所阻挡不了的，那就是对美好生活的期待。凭着心中的那份期待，他熬过了监狱里的各种磨难，也将自己从监狱中成功的救赎出来。</p><p>生活有时候，就像是一座牢笼，让我们失去自由，失去尊严，遭受各种折磨，但一旦有了期待，心里就有了热情和火苗，就不会对生活彻底的绝望，就有了走出困境的力量。</p><p>有事做，凭自己的能力生存于世，体现自己的人生价值。</p><p>有人爱，让自己的灵魂有一个归属，感受人性的温暖。</p><p>有所期待，让自己对生活保持热情和希望，充满向上的力量。</p><p>我认为这就是一个人最好的生活状态，与大家共勉！！！</p>]]></content>
      
      
      <categories>
          
          <category> 生活 </category>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Life </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>makefile中_-_符号和_@_符号的使用</title>
      <link href="/2020/02/08/%E3%80%90Scripts%E7%B3%BB%E5%88%97%E3%80%91makefile%E4%B8%AD_-_%E7%AC%A6%E5%8F%B7%E5%92%8C_@_%E7%AC%A6%E5%8F%B7%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>/2020/02/08/%E3%80%90Scripts%E7%B3%BB%E5%88%97%E3%80%91makefile%E4%B8%AD_-_%E7%AC%A6%E5%8F%B7%E5%92%8C_@_%E7%AC%A6%E5%8F%B7%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="1、参考"><a href="#1、参考" class="headerlink" title="1、参考"></a>1、参考</h2><p><a href="https://www.cnblogs.com/MyEyes/archive/2012/01/12/2320505.html" target="_blank" rel="noopener">Makefile中命令前的@和-符号</a><br><a href="https://blog.csdn.net/stpeace/article/details/53048649" target="_blank" rel="noopener">makefile中”-“符号的使用</a></p><h2 id="2、makefile中“-”符号的使用"><a href="#2、makefile中“-”符号的使用" class="headerlink" title="2、makefile中“-”符号的使用"></a>2、makefile中“-”符号的使用</h2><p><strong>用法说明：</strong><br>在makefile中，  -用于告诉make命令忽略当前错误， 继续执行。<br>通常rm命令和mkdir命令前面要加-号，因为rm要删除的文件可能不存在，mkdir要创建的目录可能已存在，这两个命令都有可能出错，但这种错误是应该忽略的。</p><p><strong>实例：</strong><br><img src="/img/20200208184912200.png" alt="makefile"><br>执行命令：make clean 出现如下报错，因为当前目录下面没有main文件，因此报错停止编译，下面两条命令也不会执行的。<br><img src="/img/20200208184937551.png" alt="make clean执行结果"><br>但是若rm命令前面加上“-”符号，会继续执行命令，不会报错，如下所示。<br><img src="/img/20200208185145391.png" alt="makefile"><br>执行make clean的结果：<br><img src="/img/20200208185357988.png" alt="make clean执行结果"><br>从执行结果可以看出，在rm命令前面加上“-”符号之后，命令执行报错后会被make忽略，继续执行后面的命令（这里是ls命令）。</p><h2 id="3、makefile中“-”符号的使用"><a href="#3、makefile中“-”符号的使用" class="headerlink" title="3、makefile中“@”符号的使用"></a>3、makefile中“@”符号的使用</h2><p><strong>用法说明：</strong><br>如果make执行的命令前面加了@字符，则不显示命令本身而只显示它的结果。</p><p><strong>实例：</strong><br><img src="/img/20200208185357988.png" alt="makefile"><br>在前面运行结果基础上，在rm和ls命令前面加上“@”符号，运行结果如下：<br><img src="/img/20200208190610688.png" alt="make clean执行结果"><br>对比可以发现：<br>在运行结果中，只显示运行出来的结果，不显示命令本身。</p><p>通过上面的实例分析，我们就清楚了makefile中命令前面“-”符号和“@”符号的作用和使用方法，这也是makefile脚本编写的一个知识点了。</p><hr><h2 id="THE-END"><a href="#THE-END" class="headerlink" title=" THE END ! "></a><font color="red"> THE END ! </font></h2>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
          <category> 自动化脚本 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> makefile </tag>
            
            <tag> Tools </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2020年阅读书单</title>
      <link href="/2020/01/28/%E3%80%90Books%E7%B3%BB%E5%88%97%E3%80%912020%E5%B9%B4%E9%98%85%E8%AF%BB%E4%B9%A6%E5%8D%95/"/>
      <url>/2020/01/28/%E3%80%90Books%E7%B3%BB%E5%88%97%E3%80%912020%E5%B9%B4%E9%98%85%E8%AF%BB%E4%B9%A6%E5%8D%95/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="2020年阅读书单"><a href="#2020年阅读书单" class="headerlink" title="2020年阅读书单"></a>2020年阅读书单</h2><p>1、坚持阅读，10本书，读书笔记(纸质版和博客电子版)，多去图书馆读书</p><h3 id="1、文学"><a href="#1、文学" class="headerlink" title="1、文学"></a>1、文学</h3><table><thead><tr><th>书籍</th><th>状态</th></tr></thead><tbody><tr><td>《月童度河》</td><td>已读</td></tr><tr><td>《亲爱的安德烈》</td><td>已读</td></tr><tr><td>《异类》</td><td>已读</td></tr><tr><td>《窄门》</td><td>已读</td></tr><tr><td>《围城》</td><td><font color="red">未读</font></td></tr><tr><td>《黄金时代》</td><td><font color="red">未读</font></td></tr><tr><td>《白夜行》</td><td><font color="red">未读</font></td></tr><tr><td>《摆渡人》</td><td><font color="red">未读</font></td></tr></tbody></table><h3 id="2、心理学"><a href="#2、心理学" class="headerlink" title="2、心理学"></a>2、心理学</h3><table><thead><tr><th>书籍</th><th>状态</th></tr></thead><tbody><tr><td>《读心术》</td><td><font color="red">未读</font></td></tr></tbody></table><h3 id="3、历史"><a href="#3、历史" class="headerlink" title="3、历史"></a>3、历史</h3><table><thead><tr><th>书籍</th><th>状态</th></tr></thead><tbody><tr><td>《人类简史》</td><td><font color="red">未读</font></td></tr><tr><td>《万历十五年》</td><td><font color="red">未读</font></td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 读书 </category>
          
          <category> 书单 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Books </tag>
            
            <tag> ReadingList </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《月童度河》摘抄及读书笔记</title>
      <link href="/2020/01/28/%E3%80%90Books%E7%B3%BB%E5%88%97%E3%80%91%E3%80%8A%E6%9C%88%E7%AB%A5%E5%BA%A6%E6%B2%B3%E3%80%8B%E6%91%98%E6%8A%84%E5%8F%8A%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
      <url>/2020/01/28/%E3%80%90Books%E7%B3%BB%E5%88%97%E3%80%91%E3%80%8A%E6%9C%88%E7%AB%A5%E5%BA%A6%E6%B2%B3%E3%80%8B%E6%91%98%E6%8A%84%E5%8F%8A%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>&ensp; &ensp;2020年庚子鼠年，在输水中度过，感冒使得整个人萎靡了许多。恰逢武汉新型肺炎扩散，一时全国人心惶惶，本就渐淡的年味也就消失殆尽了。像这样的时间，静下心来看看书也是极好的一件事。月童度河就在这样的时节里看完了。</p><p><img src="/img/yuetongduhe.jpg" alt="《月童度河》"></p><h2 id="1、读书笔记"><a href="#1、读书笔记" class="headerlink" title="1、读书笔记"></a>1、读书笔记</h2><p>&lt;1&gt;.一个人因为前世是金匠，眼中只能见到美丽精巧的事物，不愿意看到任何丑陋污脏。佛陀为了让他修不净观，让他从池塘中摘一朵莲花带回家，他目睹莲花的盛开和凋谢，得以领悟。<br>&lt;2&gt;.我们对事物，人生的感受及理解，并非相同。这是由自己的阅历、角度、偏好和思考所决定，不存在高下是非对错之分。<br>&lt;3&gt;.很多人都是由于不用力以及过于现实和理性，半途而废。冒险的心需要一种沉沦的动力。有时想，人的生活不是在于活多久，而是在于活的足够。活的足够，即是一段充分拆解和粉碎自己的过程。<br>&lt;4&gt;.人的困惑若拘泥于世俗层面，逃脱不出婚姻、家庭、爱、孩子、工作、经济…..诸如此类的主题。这些要素构成现世的安身之所，也是坚不可摧的牢狱。<br>&lt;5&gt;.什么是重要的？健康而平静地活着。<br>&lt;6&gt;.如果你是一个蚌，你愿意受尽一生痛苦而凝结一粒珍珠，还是不要珍珠，宁愿舒舒服服地活着？<br>&lt;7&gt;.一个社会，如果没有服务于比较广大的目标，没有信仰，人与人之间，只有自我满足，一律为自己的方便做打算，就会弱肉强食。对他人尊重，为他人着想，对事物认真对待，需要一代代无限真诚地传承、耕耘。<br>&lt;8&gt;.我遇见你，如同遇见戴着花的鹿一样不易。<br>&lt;9&gt;.女子大美为心净，中美为修寂，小美为体貌。<br>&lt;10&gt;.我们活得有时像卑微的沙子，有时像一座须弥山。<br>&lt;11&gt;.深爱的本质是悲悯。或许，克制而有节的感情才能长远，并具有深意。需要对彼此的质地产生真正的理解与爱慕。<br>&lt;12&gt;.好的关系，应该共同趋向解脱，而不是使彼此陷入更深的轮回。初级的爱是一种深深的束缚和缠绕，并让人沉沦苦海。高级的爱求得解脱。<br>&lt;13&gt;.被爱的总是有恃无恐。不过他们迟早会知道，能给予他们这样的感情的人，一生只有少数的几个。<br>&lt;14&gt;.没有什么是比存在本身更重要更强烈的教诲。对孩子来说，不必故意要说什么明显的道理。语言不重要。我们如何对待周围和彼此很重要，这代表着自己。<br>&lt;15&gt;.孩子们的世界只有当下，没有过去的负担，没有对未来的期望，每一刻都是新的，彻底的。没有成人世界的敷衍和虚弱。<br>&lt;16&gt;.在关系中，最好能够提供和给予对方无法找到与替代的内容，哪怕只有百分之十。这个十十分重要，是属于你的珍贵而独特的品性。<br>&lt;17&gt;.若没有从心底生发的联结和对彼此的善良和慈悲，再炽热的欲望，再反复的誓言，都如同蛛网般脆弱。<br>&lt;18&gt;.生命需要做减法。真正的相爱，而不是期待和恐惧。<br>&lt;19&gt;.已彼此等待许久。我在这里，看见我，靠近我，与我相遇，与我融汇，如同春光寻觅到山峦，如同明月感应到净湖。<br>&lt;20&gt;.年轻的女孩，不应该一味把时间花在追逐热门电视剧网剧，精心打扮修饰自己的皮囊，渴望华贵奢侈的物品，以及幻想有男子平白无故的热爱自己一生一世。这些都是泡沫。多读书，多旅行，勤恳工作，善待他人，热爱天地自然，珍惜一事一物。自然有人感受和尊重你的价值。</p><h2 id="2、感悟"><a href="#2、感悟" class="headerlink" title="2、感悟"></a>2、感悟</h2><p>读书过程中，总是被作者的一些文字所感触，若有所悟，若有所思， 这种感觉是极好的。这也许就是读书的意义吧。在这本书中，作者关于生活、人生、感情的理解有自己独特的视角。我们为什么活着，该怎么去活着，是该简简单单地活着还是轰轰烈烈的活着，像这样的问题似乎很少有人去思考和体悟。关于人生的思考，一直是一个永恒的话题，我们在思考中前进，在前进中思考，或许到生命结束，我们都在思考这个问题。</p><pre><code>                                                                            记于庚子年正月初四  山东济南  家</code></pre><hr><h2 id="THE-END"><a href="#THE-END" class="headerlink" title=" THE  END! "></a><font color="red"> <strong>THE  END!</strong> </font></h2>]]></content>
      
      
      <categories>
          
          <category> 读书 </category>
          
          <category> 读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Books </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>济南 VS. 合肥 综合调研报告</title>
      <link href="/2019/11/20/%E3%80%90Life%E7%B3%BB%E5%88%97%E3%80%91%E6%B5%8E%E5%8D%97%20VS.%20%E5%90%88%E8%82%A5%20%E7%BB%BC%E5%90%88%E8%B0%83%E7%A0%94%E6%8A%A5%E5%91%8A/"/>
      <url>/2019/11/20/%E3%80%90Life%E7%B3%BB%E5%88%97%E3%80%91%E6%B5%8E%E5%8D%97%20VS.%20%E5%90%88%E8%82%A5%20%E7%BB%BC%E5%90%88%E8%B0%83%E7%A0%94%E6%8A%A5%E5%91%8A/</url>
      
        <content type="html"><![CDATA[<p>﻿[TOC]</p><h2 id="1、地理位置"><a href="#1、地理位置" class="headerlink" title="1、地理位置"></a>1、地理位置</h2><p><strong>（1）济南</strong><br>济南，简称“济”，别称泉城，是山东省省会、副省级市、济南都市圈核心城市，国务院批复确定的环渤海地区南翼的中心城市 [1]  。截至2018年，全市下辖10个区、2个县，总面积10244平方千米，建成区面积561平方千米，常住人口746.04万人，城镇人口537.89万人，城镇化率72.1%。<br>济南地处中国华东地区、山东中西部、华北平原东部边缘，是中国人民解放军北部战区陆军机关驻地  ，山东半岛城市群核心城市，北连首都经济圈、南接长三角经济圈，东西连山东半岛，是环渤海经济区和京沪经济轴上的重要交汇点，环渤海地区和黄河中下游地区中心城市之一。<br>济南位于山东省中西部，南依泰山，北跨黄河，背山面水，分别与西南部的聊城、北部的德州和滨州、东部的淄博、南部的泰安交界。<br>济南市位于北纬36°40′，东经117°00′，地处鲁中南低山丘陵与鲁西北冲积平原的交接带上，地势南高北低。</p><p><strong>（2）合肥</strong><br>合肥，简称庐或合，古称庐州、庐阳、合淝 ，是安徽省省会，长三角城市群副中心，综合性国家科学中心，“一带一路”和长江经济带战略双节点城市 [3]  ，具有国际影响力的创新之都，国家重要的科研教育基地，现代制造业基地和综合交通枢纽[2]  ，合肥都市圈中心城市 [4]  ，皖江城市带核心城市 [5]  ，G60科创走廊中心城市。<br>合肥市地处中国华东地区、江淮之间，环抱巢湖， [6]  总面积11445.1平方公里（含巢湖水面770平方公里），截至2016年末，下辖4个市辖区、4个县，代管1个县级市，设有4个开发区 [7]  ，城市建成区面积428平方公里 [8]  。合肥境内有丘陵岗地、低山残丘、低洼平原三种地貌，以丘陵岗地为主；属于亚热带季风气候，四季分明，气候温和。</p><h2 id="2、经济发展水平"><a href="#2、经济发展水平" class="headerlink" title="2、经济发展水平"></a>2、经济发展水平</h2><p><strong>（1）济南</strong><br>12月被国务院列为第三批国家新型城镇化综合试点地区 [6]  ；2017年中国百强城市排行榜排19位 ，并举办第五届世界摄影大会 ；2018年1月，国务院正式批复《山东新旧动能转换综合试验区建设总体方案》，支持济南建设国家新旧动能转换先行区 ；2019年1月，进入“亚洲城市50强”，跻身“全球二线城市”<br>2018年，全市地区生产总值7856.56亿元，同比增长7.4%。其中,第一产业增加值272.42亿元，增长2.5%；第二产业增加值2829.31亿元，增长7.8%；第三产业增加值4754.83亿元，增长7.5%。三次产业构成为3.5：36.0：60.5。人均地区生产总值106302元，增长5.7%，按年均汇率折算为16064美元。（不含莱芜区钢城区）。<br>济南具有良好的农业资源，悠久的蔬菜种植传统，享有“中国精品菜篮”的美誉，<br> 培育出“章丘大葱、鲍芹”、“商河大蒜、彩椒”、“平阴玫瑰、阿胶”、“仁风西瓜、曲堤黄瓜”、“张而草莓”、“张夏玉杏”、“马山栝楼”“香玲核桃”等一批国家地理标志产品，在国际市场亦具有较高知名度。<br>济南市要打造全国重要的区域性经济中心、金融中心、物流中心、科技创新中心，建设与山东经济文化强省相适应的现代泉城。</p><table><thead><tr><th>济南市重要的经济金融中心</th><th>–</th><th>—</th></tr></thead><tbody><tr><td>济南中央商务区</td><td>济南绿地中心</td><td>绿城济南中心</td></tr><tr><td>绿地山东国际金融中心</td><td>济南中弘广场</td><td>恒大国际金融中心</td></tr><tr><td>汉峪金谷</td><td>中国人寿（山东）大厦    历下总部商务中心</td><td>山东黄金时代广场</td></tr><tr><td>山东黄金国际广场</td><td>历下金融商务服务中心</td><td>济南奥体金融中心</td></tr><tr><td>齐鲁之门</td><td>华润万象天地</td><td>山东高速广场</td></tr><tr><td>济南华润中心</td><td>复星山东金融总部</td><td></td></tr></tbody></table><p><strong>（2）合肥</strong></p><p>合肥是世界科技城市联盟会员城市 [13]  、中国最爱阅读城市 [14]  、中国集成电路产业中心城市、国家科技创新型试点城市[15-16]  。有“江淮首郡、吴楚要冲”，“江南之首”、“中原之喉”的美誉。2017年中国百强城市排行榜排29位。  2018年9月，被授牌成为“海峡两岸集成电路产业合作试验区”。 2018中国内地城市综合排名17名。 [21]  2019年6月，未来网络试验设施开通运行。</p><p>2018年，合肥市全年生产总值（GDP） <strong>7822.91</strong> 亿元。</p><h2 id="3、文化"><a href="#3、文化" class="headerlink" title="3、文化"></a>3、文化</h2><p><strong>（1）    济南</strong><br><font color="red"> 【1】人文地理 </font><br>济南因境内泉水众多，拥有“七十二名泉”，被称为“泉城”，素有“四面荷花三面柳，一城山色半城湖”的美誉，济南八景闻名于世，是拥有“山、泉、湖、河、城”独特风貌的旅游城市，是国家历史文化名城、首批中国优秀旅游城市，史前文化——龙山文化的发祥地之一。<br>济南已成功举办亚洲杯、全运会、中国国际园林花卉博览会、中国艺术节等多项国际和国家级盛会，2015年举办第22届国际历史科学大会；2016年4月举办中国绿公司年会 [5]  ，</p><p>济南历史悠久，是史前文化“龙山文化”的发祥地，区域内新石器时代的遗址城子崖，有先于秦长城的齐长城，有被誉为“海内第一名塑”的灵岩寺宋代彩塑罗汉、隋代大佛（位于历城区大佛村，凿山而成，建于隋代，为山东第一大佛）。中国首部诗歌总集《诗经》中有谭人所作讽刺诗《大东》，是现存最早的有关济南的文献。1986年12月被国务院公布为国家历史文化名城。</p><p>泉城济南，泉群众多、水量丰沛，被称为的天然岩溶泉水博物馆。<br> 济南城内百泉争涌，分布着久负盛名的趵突泉泉群、黑虎泉泉群、五龙潭泉群、珍珠泉泉群、白泉泉群、百脉泉泉群、玉河泉泉群、涌泉泉群、袈裟泉泉群以及平阴的洪范池泉群十大泉群。以上十大泉群均属“济南泉群”。济南城内百泉争涌，向有名泉七十二之说，流传甚广。<br>济南老城的泉水分布最为密集，十大泉群中，仅有老城就占有4个， 基本上是现今游船环城一圈的区域：从黑虎泉出发，经泉城广场—西门—五龙潭—大明湖公园北侧—老东门—青龙桥，密布着大大小小100多处天然甘泉，汇流成的护城河流淌到大明湖，与周围的千佛山、鹊山、华山等构成了独特的风光，也成为少有的集“山、泉、湖、河、城”于一体的城市，自古就有“家家泉水，户户垂柳”、“四面荷花三面柳，一城山色半城湖”的美誉。<br>济南市吉祥物：金牛<br><font color="red"> 【2】饮食文化 </font><br>济南是八大菜系的鲁菜发祥地，历来传承有序。<br>泉城大包：选料精细，做工考究，配料丰富有特色，而且味道醇厚，花色品种多。泉城大包97年起就获”中华名小吃”奖。<br>名士多烤全羊：泉城“十大名吃之一”，清朝末期即名声大起。选梁山1岁青山羊，以祖传秘方烤制，保持原汁原味，色香味俱佳。<br>黄家烤肉：济南名吃黄家烤肉起源于章丘，以猪肉为主料，秘方配料，用水果树枝熏烤制成，口味略咸。黄家烤肉有两种，瘦肉和五花肉（带猪皮），五花肉肥而不腻，猪皮香脆可口。<br>天天炸鸡：泉城“十大名吃之一”。工艺精良、风味独特。<br>奶汤蒲菜：以济南大明湖出产的一种质地鲜嫩、味道清鲜的蒲菜为主料，加奶汤烹制而成，历来被人们誉为济南第一汤菜。<br>油旋：济南传统精细风味小吃。清道光年间，济南城里就有油旋经营。油旋葱香浓郁，外酥内嫩。<br>烧烤：回民小区、纸箱厂烧烤、啊里吧吧烧烤、一九烧烤、馕食烤吧、好旺角、良田烧烤、新疆食府、草春堂、紫罗兰烧烤、王舍人、鑫鹏羊倌。<br>糖醋黄河鲤鱼：糖醋黄河鲤鱼历来被尊为山东名菜之首。<br>济南甜沫：甜沫也叫五香甜沫，其实是咸的，是选用新鲜上好小米浸泡后磨成小米糊，熬煮时加入花生米、豇豆、红小豆、粉条、豆腐皮和菠菜等辅料，以姜葱末“倒炝锅”，加胡椒粉或“五香面”提味儿，并点入少许香油溢其香气。<br>特色小吃有甜煎饼、田螺、包子、锅贴、羊汤、烤地瓜、烧烤、买卖茶等。<br>地方特产有：章丘大葱、龙山小米、明水香稻、黄河大米、平阴玫瑰、鲁绣等。<br><font color="red"> 【3】历史人物 </font><br>李清照、辛弃疾、张养浩、边贡、李攀龙、邹衍<br>另外李白、杜甫、苏轼、苏辙、曾巩、元好问、赵孟頫、王士祯、蒲松龄、老舍、季羡林、任继愈、欧阳中石、曹操等古今杰出的作家和学者，都先后在济南生活游历或求学为官，故有“济南名士多”之佳誉。</p><p><strong>（2）合肥</strong><br><font color="red"> 【1】人文地理 </font><br>合肥位于中国华东地区、长江三角洲西端，江淮之间，安徽省中部，西接六安市，北连淮南市，东北靠滁州市，东南靠马鞍山市、芜湖市，西南邻安庆市、铜陵市；全市版图总面积11445.1平方公里，介于北纬 30°57′-32°32′、东经116°41′-117°58′之间。<br>合肥市境内有丘陵岗地、低山残丘、低洼平原三种地貌，以丘陵岗地为主，江淮分水岭自西向东横贯全境。全市海拔多在15～80米之间，平均海拔20～40米。主城区地势由西北向东南倾斜，岗冲起伏；西南部属大别山余脉，层峦叠嶂；海拔最高为境西的牛王寨595米。<br>合肥是中国优秀旅游城市，三河古镇为国家AAAAA级旅游景区。截至2015年，合肥有6处全国重点文物保护单位，安徽省文物保护单位36处，市级文物保护单位54处。 2015年，全市共有A级景区157家，其中4A级以上景区23家。</p><p><font color="red"> 【2】饮食文化 </font><br>合肥的菜系以庐州菜、江淮菜最为有名。合肥菜又称庐州菜，是徽菜的五大代表菜之一，合肥菜代表菜品有臭干炒千张、庐州烤鸭、包公鱼、逍遥鸡、三河米饺、肥西老母鸡汤、吴山贡鹅等。</p><p><font color="red">【3】历史人物 </font><br>古代    包拯、李鸿章、刘铭传、周瑜、文翁、杨行密、张德胜<br>近代    冯玉祥、段祺瑞、卫立煌、王亚樵、孙立人、杨宝森、董寅初、唐德刚 丁汝昌 聂士成<br>现代    杨振宁、应祚智、吴邦国、郑永飞、李克强、杨元庆</p><h2 id="4、人口"><a href="#4、人口" class="headerlink" title="4、人口"></a>4、人口</h2><p><strong>（1）济南</strong><br>2018年末常住人口746.04万人，比上年末增长1.90%。户籍人口<strong>655.90</strong>万人，增长1.91%。</p><p><strong>（2）合肥</strong><br>2018年末，合肥市户籍人口 <strong>757.96</strong> 万人，比上年增加 15.2 万人，其中市区户籍人口 281.27 万人，增加 11.16 万人。全市常住人口 808.7 万人，比上年增加 12.2 万人。常住人口城镇化率74.97%，比上年提高 1.22 个百分点。</p><h2 id="5、交通"><a href="#5、交通" class="headerlink" title="5、交通"></a>5、交通</h2><p><strong>（1）济南</strong><br>济南是连接华东与华北的门户，是连接华东、华北和中西部地区的重要交通枢纽之一，济南地理位置优越，交通发达，是全省公路网络中心和高速公路中心枢纽。截至2012年，年末公路通车里程12297千米。<br>济南市城市轨道交通建设近期规划由1号线、2号线和3号线三条线路组成，总长约98km。<br>济南地铁1号线（南北纵向）北起济南非物质文化遗产博览园（济南西站北附近），南至长清大学园区，为南北向市域快线。<br>济南地铁2号线西起王府庄站，东至郭店，利用既有铁路走廊，为东西向市域快线，连接西站片区、济南站、东部新城。<br>济南地铁3号线南起龙洞，沿龙鼎大道、奥体西路、工业北路、机场路，经过济南临港经济开发区，北至遥墙国际机场，全长35km，远期通济阳，为南北向市域快线。<br>截至2019年6月，济南轨道交通1号线开通运营，济南轨道交通2号线、济南轨道交通3号线在建。</p><p><strong>（2）    合肥</strong><br>合肥对外交通便捷，境内铁路、公路、航空、水运交通发达，形成纵横交错、四通八达的立体化交通网络，是国家规划建设中的全国性综合交通枢纽。东有合宁线连接南京、上海，西有合武线通往武汉、成都，北有合蚌高铁直通北京，南向将通过京福高铁连通江西、福建。合肥港为二类水运开放口岸，综合码头二期工程开工建设中，建成后年吞吐能力将达到50万标箱。总投资43亿元、设计年旅客吞吐量为1100万人次的4E级合肥新桥国际机场开通有国内航线51条，国际及地区航线13条。合肥城区道路骨架实现了“十”字型向“井”字型格局的转变，形成了“三环多放射”的城市动脉交通网。</p><p>合肥地铁是合肥城市公共交通系统的重要组成部分。合肥轨道交通规划建设15条线路，总长322.5公里，其中市区线路7条，全长215.3公里；市域线5条（含1条机场专用线），全长107.2公里。远期中心城区城市轨道交通远期规划方案由6条城市轨道交通线路组成，共设置了15个轨道交通枢纽，全长181.1公里。截至2017年12月，合肥地铁1号线、合肥地铁2号线已通车，另有1号线三期、3号线、4号线和5号线在建。</p><h2 id="6、教育资源水平"><a href="#6、教育资源水平" class="headerlink" title="6、教育资源水平"></a>6、教育资源水平</h2><p><strong>（1）    济南</strong><br>济南是山东省的文化、教育中心，有国家教育部985工程、211工程的重点大学山东大学、山东师范大学、济南大学等一系列重点高等院校，每年为国家和地方输送了大量人才。<br>截至2013年，济南总共有45所高校，在校大学生近60万人。随着高校扩招趋势的展开，济南市区高校规模已经远远不能容纳众多的来济学子，自2000年左右，各高校开始扩建校区，截至2013年已兴建了长清大学城和济南东部大学城（即章丘大学城）。</p><p><strong>（2）    合肥</strong><br>合肥历朝历代都重视书院建设，历史上 有庐阳书院、包公书院、景贤书院、秋浦书院、正学书院等众多书院。宋嘉定时，书院有房屋三百余间。明弘治间，有殿、庑、门、堂、桥、斋、居、号室。清代起，通过科举考试，合肥中进士人数48人，有李鸿章、龚鼎孳等代表人物。</p><h2 id="7、医疗资源水平"><a href="#7、医疗资源水平" class="headerlink" title="7、医疗资源水平"></a>7、医疗资源水平</h2><p><strong>（1）济南</strong><br>2012年末济南市拥有卫生机构5239个，增长1.6%。其中医院、卫生院243个，增长21.5%。卫生机构床位3.9万张，增长11.4%。各类卫生技术人员4.4万人，增长5.1%；执业（助理）医师1.9万人，增长6.1%。按常住人口计算，每千人拥有病床6.4张，增长10.9%；每千人拥有医生3.2人，增长5.6%。<br>山东省人民政府决定在济南市槐荫区建设济南国际医学科学中心，将其建设成为集医疗、教学、科研和预防保健、健康旅游、康复医养为一体的具有国内先进水平的综合医学服务中心。国家卫生健康委与山东省政府、济南市政府签订《关于共建国家健康医疗大数据北方中心合作框架协议》，标志着国家健康医疗大数据北方中心正式落户济南。<br><strong>（2）合肥</strong><br>2018年，合肥市有医疗卫生机构（含村卫生室）2293 个，其中医院 171 个、卫生院 98 个、妇幼保健院（所、站）12 个、疾控中心和专科疾病防治机构 18 个、社区卫生服务机构 201个。卫生机构床位数 5.59 万张，其中医院、卫生院床位 5.22万张。卫生技术人员 6.10 万人，其中执业（助理）医师 2.23万人，注册护士 2.96 万人。每千人常住人口拥有床位数 6.91张，拥有医院卫生院床位数 6.46 张；每千人常住人口拥有卫生技术人员 7.54 人，拥有医生 2.76 人，拥有注册护士 3.66人。婴儿死亡率 3.4‰，孕产妇死亡率 9.51/10 万。城市社区卫生机构覆盖率达 98%以上</p><h2 id="8、科技水平"><a href="#8、科技水平" class="headerlink" title="8、科技水平"></a>8、科技水平</h2><p><strong>（1）    济南</strong><br>济南在电子信息、交通装备、机械制造、生物制药、食品纺织等主导产业在中国有着举足轻重的地位。济南高新技术、信息产业发达，并被国家批准成为“中国软件名城”。拥有占地20公顷、亚洲最大的环形建筑——国家级软件基地“齐鲁软件园”，“国家信息通信国际创新园（CIIIC）”、“国家软件出口（创新）基地”、“国家服务外包基地城市”示范区等三个“国字号”招牌也先后落户齐鲁软件园，及“国家超级计算济南中心”、“济南量子技术研究院”等一批电子信息研发机构，现已有1200余家国内外IT研发企业入园发展。</p><p><strong>（2）    合肥</strong><br>合肥是中国国家科技创新型试点城市和国家创新型试点城市，也是世界科技城市联盟会员城市。<br>2018年，合肥市有院士工作站 47 个；省部级以上重点实验室和工程实验室 210 个，其中国家重点（工程）实验室 17 个；省级以上工程技术研究中心 139 个，其中国家级（含分中心）7 个；省级以上工程研究中心 66 个，其中国家级 15 个；省级以上企业技术中心 322 个，其中国家级 46 个。省级以上创新型（试点）企业 218 个，其中国家级 14 个。市级以上科技企业孵化器 59 个，其中国家级 12 个。市级以上众创空间 75 个，其中国家级 18 个。<br>2018年，合肥市全年有 9 项科技成果获国家科技奖，其中国家自然科学二等奖 2 项，科技进步二等奖 6 项。全年受理专利申请 65814件，其中发明专利 32831 件；授权专利 28438 件，其中发明专利 5597 件，比上年增长 13.8%。全年签订输出技术合同17077 项，成交金额 191.85 亿元，增长 34.4%；签订吸纳技术合同 9590 项，成交金额 165.57 亿元，增长 14.8%。</p><h2 id="9、整体结论"><a href="#9、整体结论" class="headerlink" title="9、整体结论"></a>9、整体结论</h2><p>本文从地理、经济、文化、人口、交通、教育、医疗、科技等方面对济南和合肥这两座省会级城市进行了对比分析，整体上两座城市发展水平相当，但就地理位置、文化和教育方面，济南要优于合肥，并且在成为国家中心城市的角度来讲，济南的优势是很明显的，相信未来济南的发展潜力会非常大！</p><p>在地理位置上，济南位于环渤海经济区和京沪经济轴上的重要交汇点，会受到京津地区经济带的周边辐射作用，并且是重要的南北交通枢纽；合肥位于长江经济带，会受到南京的经济辐射，但辐射强度不大。<br>在文化方面，济南自古就是文化之城，作为孔孟之乡，在文化底蕴和教育方面都是投入非常大，比较好的大学比如山东大学、山东师范大学和山东财经大学等。合肥在近代教育水平一般，不过也有不错的大学，比如中科大、合肥工业大学和安徽大学等。</p><h2 id="10、参考"><a href="#10、参考" class="headerlink" title="10、参考"></a>10、参考</h2><p><a href="https://baike.baidu.com/item/%E6%B5%8E%E5%8D%97/135066?fr=aladdin" target="_blank" rel="noopener">济南—百度百科</a><br><a href="https://baike.baidu.com/item/%E5%90%88%E8%82%A5/210419?fr=aladdin" target="_blank" rel="noopener">合肥—百度百科</a><br><a href="https://www.anhui365.net/PostCenter/ThreadDetail/id/2633293.html" target="_blank" rel="noopener">济南合肥经济指标对比</a><br><a href="https://know.baidu.com/question/b6313149a7b48287e881f802fc76466fbafab4b" target="_blank" rel="noopener">合肥与济南相比哪个好点？</a><br><a href="http://dy.163.com/v2/article/detail/E1HVJ9MK0524S3FA.html" target="_blank" rel="noopener">同为省会，济南VS合肥，全方位对比谁能更胜一筹？</a></p>]]></content>
      
      
      <categories>
          
          <category> 生活 </category>
          
          <category> 规划 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Life </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>通过OpenCV读取并显示YUV视频文件</title>
      <link href="/2019/11/06/%E3%80%90OpenCV%E7%B3%BB%E5%88%97%E3%80%91%E9%80%9A%E8%BF%87OpenCV%E8%AF%BB%E5%8F%96%E5%B9%B6%E6%98%BE%E7%A4%BAYUV%E8%A7%86%E9%A2%91%E6%96%87%E4%BB%B6/"/>
      <url>/2019/11/06/%E3%80%90OpenCV%E7%B3%BB%E5%88%97%E3%80%91%E9%80%9A%E8%BF%87OpenCV%E8%AF%BB%E5%8F%96%E5%B9%B6%E6%98%BE%E7%A4%BAYUV%E8%A7%86%E9%A2%91%E6%96%87%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>&ensp; &ensp; &ensp;    Opencv中通常是读取 avi 格式的视频文件，下面程序是直接读取 YUV格式的视频文件并显示出来。 这里需要将YUV读取出来，使用Mat格式保存再使用 cv::cvtColor() 将每帧的 yuv 数据转化为 RGB格式 ，然后显示或者在RGB空间进行算法处理，并且可以再利用cv::cvtColor()将RGB数据转换成yuv数据并写到文件中保存。</p><h2 id="1、参考"><a href="#1、参考" class="headerlink" title="1、参考"></a>1、参考</h2><p><a href="https://blog.csdn.net/SoaringLee_fighting/article/details/90144211" target="_blank" rel="noopener">【Matlab系列】读取并显示YUV视频文件</a><br><a href="https://blog.csdn.net/edmond999/article/details/78748489" target="_blank" rel="noopener">读取yuv并转化为RGB数据在Opencv中打开显示</a><br><a href="https://blog.csdn.net/qq_24193303/article/details/80512134" target="_blank" rel="noopener">opencv 读取 普通视频、以YUV数据格式保存的视频 以及 图片序列的方法</a></p><h2 id="2、OpenCV读取并显示YUV视频文件"><a href="#2、OpenCV读取并显示YUV视频文件" class="headerlink" title="2、OpenCV读取并显示YUV视频文件"></a>2、OpenCV读取并显示YUV视频文件</h2><pre><code class="cpp">int main(int argc, char* argv[]){   Mat yuvImage, rgbImage, yuvSave;   int filelength = 0;   int framenum = 0;   if(argc &lt; 6)   {     printf(&quot;usage: demo.exe yuvname yuvSavename width height procnum \n&quot;);     return -1;   }   const char* yuvname = argv[1];   const char* yuvSavename = argv[2];   int width = atoi(argv[3]);   int height = atoi(argv[4]);   int procnum = atoi(argv[5]);   FILE* file_in = fopen(yuvname, &quot;rb&quot;);   if(NULL == file_in)   {     printf(&quot;ERROR: open %s failed!!!\n&quot;, yuvname);     return -1;    }   FILE* file_out = fopen(yuvSavename, &quot;rb&quot;);   if(NULL == file_out)   {     printf(&quot;ERROR: open %s failed!!!\n&quot;, yuvSavename);     return -1;    }    fseek(file_in, 0 ,SEEK_END);    filelength = ftell(file_in);    framenum = filelength/(width*height*3/2);      printf(&quot;total framenum: %d\n&quot;, framenum);    fseek(file_in, 0， SEEK_SET);    unsigned char *pYUVBuf = (unsigned char*)malloc(width*height*3/2*sizeof(unsigned char));    if(NULL == pYUVBuf)    {      printf(&quot;ERROR: malloc pYUVBuf failed,0x%x!!!\n&quot;, pYUVBuf);      return -1;     }     yuvImage.create(height*3/2, width, CV_8UC1);     yuvSave.create(height*3/2, width, CV_8UC1);     namedWindow(&quot;src Image&quot;, CV_WINDOW_NOARMAL);     namedWindow(&quot;dst Image&quot;, CV_WINDOW_NOARMAL);     for(int i=0;i&lt;procnum;i++)     {       fread(pYUVBuf,1,width*height*3/2, file_in);       memcpy(yuvImage.data, pYUVBuf, width*height*3/2);       cvtColor(yuvImage, rgbImage, CV_YUV2BGR_I420);       imshow(&quot;src Image&quot;, rgbImage);    // 算法处理       Mat finalImage;       imshow(&quot;dst Image&quot;, finalImage);       cvtColor(finalImage, yuvSave, CV_BRG2YUV_I420);       fwrite(yuvSave.data, 1, width*height*3/2, file_out);    }    destroyWindow(&quot;src Image&quot;);        destroyWindow(&quot;dst Image&quot;);        fclose(file_in);        fclose(file_out);}</code></pre><hr><h2 id="THE-END"><a href="#THE-END" class="headerlink" title=" THE END! "></a><font color="red"> <strong>THE END!</strong> </font></h2>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 图像处理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CV </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AMBA CV22芯片知识总结系列</title>
      <link href="/2019/10/20/%E3%80%90Codecs%E7%B3%BB%E5%88%97%E3%80%91AMBA%20CV22%E8%8A%AF%E7%89%87%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93%E7%B3%BB%E5%88%97/"/>
      <url>/2019/10/20/%E3%80%90Codecs%E7%B3%BB%E5%88%97%E3%80%91AMBA%20CV22%E8%8A%AF%E7%89%87%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93%E7%B3%BB%E5%88%97/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="1、芯片简介"><a href="#1、芯片简介" class="headerlink" title="1、芯片简介"></a>1、芯片简介</h2><p><a href="https://blog.csdn.net/SoaringLee_fighting/article/details/87638647" target="_blank" rel="noopener">【Amba系列】之安霸新推出的计算机视觉芯片CV22简介</a></p><p>Ambarella, a developer of low-power, HD and Ultra HD video processing semiconductors, introduced the CV22 camera SoC, combining image processing, 4Kp60 video encoding and CVflow computer vision processing in a single, low power design.</p><p>The CV22’s CVflow architecture provides the DNN (Deep Neural Network) processing required for the next generation of intelligent home monitoring, automotive, drone and wearable cameras. Fabricated in advanced 10nm process technology, it achieves an industry-leading combination of low-power and high-performance in both human vision and computer vision applications.</p><p>“CV22 enables customers to deploy cameras with high-performance deep-learning capabilities,” said Fermi Wang, CEO of Ambarella. Compared with inefficient CPU and GPU solutions, CV22 provides powerful computer vision performance combined with high-quality image processing, efficient video encoding and the low-power operation required to be deployed in mass production. “It will enable a new level of intelligence in cameras, ranging from person recognition in home monitoring cameras to advanced ADAS capabilities in automobiles,” Wang said.</p><p>The CV22’s CVflow architecture provides computer vision processing at full 4K or 8-Megapixel resolution at 30 frames per second, to enable image recognition over long distances and with high accuracy. It includes efficient 4K encoding in both AVC and HEVC video formats, delivering high-resolution video streaming with very low bitrates to minimize cloud storage costs.</p><p>The CV22’s next-generation ISP (Image Signal Processor) provides outstanding imaging in low light conditions while HDR (High Dynamic Range) processing extracts maximum image detail in high contrast scenes, further enhancing the computer vision capabilities of the chip. It includes a suite of advanced security features to prevent hacking, including secure boot, TrustZone and I/O virtualization.</p><p>A complete set of tools is provided to help customers to easily port their own neural networks onto the CV22 SoC. This includes compiler, debugger and support for industry standard training tools including Caffe and TensorFlow, with extensive guidelines for CNN (Convolutional Neural Network) performance optimizations.</p><p> <img src="/img/20181219032900719.jpg" alt="AMBA CV22芯片"></p><p>安霸半导体公司(Ambarella)推出了一款新型汽车摄像头芯片，安霸CV22AQ，可为汽车高级驾驶员辅助(ADAS)系统中的深度神经网络(DNN)提供计算机视觉。<br>该芯片使用安霸CVflow计算机视觉架构，目标应用包括前置ADAS摄像头、带有盲点检测(BSD)功能的电子镜、车内驾驶员和驾驶舱监控摄像头以及具停车辅助功能的全景式监控系统(AVM)。该新型片上系统在车道保持、自动紧急制动(AEB)、智能大灯控制和速度辅助功能方面的应用，超出了欧洲新车评测系统(NCAP)的性能要求。此外，其采用先进的10纳米工艺技术打造，功耗低，支持挡风玻璃前置ADAS摄像头在尺寸和散热方面的要求。</p><p>安霸半导体首席执行官Fermi Wang表示：“到目前为止，因外形尺寸造成的功耗限制，导致前置ADAS摄像头的性能受到限制。CV22AQ提供业界领先的卓越神经网络，而且功耗低于2.5瓦，且具备一流的图像处理能力，可让一级供应商和OEM 客户大大提高ADAS算法的性能和准确性。”</p><p>CV22AQ的CVflow架构以每秒30帧的速度提供800万像素分辨率的计算机视觉处理能力，可精确识别远距离物体。此外，CV22AQ支持多视场摄像头的多个图像传感器输入，还可使用单个高分辨率图像传感器创建多个数字视场，以降低系统成本;其支持DNNs用于物体检测、分类(即行人、车辆、交通标志、交通信号灯)、跟踪以及自由空间检测等应用。</p><p>CV22AQ的高性能图像信号处理器(ISP)在低光条件下，可以提供出色的成像。而高动态范围成像(HDR)处理可从高对比度环境中最大限度地提取图像的细节，从而进一步提高了该芯片的计算机视觉能力。此外，该芯片包含AVC和HEVC视频格式的800万像素编码，允许客户为其汽车摄像头添加视频录制和流媒体功能。</p><h2 id="2、系统框架（软件架构和硬件架构）"><a href="#2、系统框架（软件架构和硬件架构）" class="headerlink" title="2、系统框架（软件架构和硬件架构）"></a>2、系统框架（软件架构和硬件架构）</h2><p><a href="https://blog.csdn.net/SoaringLee_fighting/article/details/102481030" target="_blank" rel="noopener">【Codecs系列】AMBA CV22芯片硬件和软件架构</a></p><p><strong>软件架构：</strong><br><img src="/img/20191013212138398.png" alt="AMBA CV22芯片软件架构"></p><p><strong>硬件架构：</strong><br><img src="/img/20191013213228734.png" alt="AMBA CV22芯片硬件架构"><br><img src="/img/20191013212425573.png" alt="AMBA CV22芯片硬件架构"></p><h2 id="3、芯片编码流程"><a href="#3、芯片编码流程" class="headerlink" title="3、芯片编码流程"></a>3、芯片编码流程</h2><p><a href="https://blog.csdn.net/SoaringLee_fighting/article/details/100548231" target="_blank" rel="noopener">【Codecs系列】AMBA CV22芯片编码流程</a></p><p><strong>AMBA CV22编码流程：</strong></p><p>1、建立netlink通信：目的是开启idsp,vdsp及其与arm之间的通信；<br>2、打开IAV和ucode设备；<br>3、系统初始化：IAV进入IDLE状态，进行Buffer，canvas和stream配置，IAV进入Preview状态。<br>4、设置编码参数：在启动编码配置静态编码参数（编码器类型设置，码率控制参数初始化，GOP初始化），编码启动之后设置动态参数（实时更改参数）。<br>5、启动编码：调用API即可（IAV_IOC_START_ENCODE）；<br>6、启动获取码流线程：具体参考test_stream.c（单独调用情况下）<br>7、开始EFM送帧：采用EFM方式将YUV按帧送入vDSP中进行编码（为YUV/QP Matrix/码流BSB获取内存）<br>7.1. 为YUV获取内存，创建ME1/ME0文件<br>7.2. 获取一帧EFM帧，用于填YUV(IAV_IOC_EFM_REQUEST_FRAME)<br>7.3. 启动一帧EFM帧的编码（IAV_IOC_EFM_HANDSHAKE_FRAME）,作用是设置一帧YUV内存到DSP中<br>7.4. ROI配置，采用stream sync。<br>8、写码流：调用IAV_IOC_QUERY_DESC, 将码流缓冲区BSB中的编码帧码流写到文件中。注意事项：码流获取可以采用阻塞获取，或者非阻塞获取。采用非阻塞获取情况下，存在最后几帧码流要刷新flushout的问题。<br>9、停止编码 :调用API即可（IAV_IOC_STOP_ENCODE）。<br>10、关闭IAV设备。</p><p>关于码流获取的注意事项：</p><p>码流获取默认是阻塞方式；<br>默认HEVC一帧分为3个slice,然后分为3个中断，dsp上报给arm，所以需要调用ioctl3次才能获取一帧。设置选项–slice-per-info 1或255 –slice-num 1后，3个slice上报一次，这样调用一次iotrl即可获取一帧码流数据。</p><h2 id="4、芯片编码器特性"><a href="#4、芯片编码器特性" class="headerlink" title="4、芯片编码器特性"></a>4、芯片编码器特性</h2><p><a href="https://blog.csdn.net/SoaringLee_fighting/article/details/102636418" target="_blank" rel="noopener">【Codecs系列】硬件编码器主要特性参数汇总</a></p><h3 id="4-1、主流硬件芯片-平台"><a href="#4-1、主流硬件芯片-平台" class="headerlink" title="4.1、主流硬件芯片/平台"></a>4.1、主流硬件芯片/平台</h3><ul><li>海思</li><li>安霸</li><li>浩瀚</li></ul><h3 id="4-2、基本编码参数"><a href="#4-2、基本编码参数" class="headerlink" title="4.2、基本编码参数"></a>4.2、基本编码参数</h3><h4 id="4-2-1-基本必备参数"><a href="#4-2-1-基本必备参数" class="headerlink" title="4.2.1 基本必备参数"></a>4.2.1 基本必备参数</h4><ul><li>编码通道号</li><li>编码协议：H.264/H.265/JPEG/MJPEG/Prores/MPEG4</li><li>编码图像宽度</li><li>编码图像高度</li><li>编码档次级别Profile</li></ul><h4 id="4-2-2-码率控制参数"><a href="#4-2-2-码率控制参数" class="headerlink" title="4.2.2  码率控制参数"></a>4.2.2  码率控制参数</h4><ul><li>GOP大小：即I帧间隔</li><li>码率控制模式：CBR,VBR,FIXQP,QPMAP等</li><li>码率统计时间</li><li>编码器输入/输出帧率</li><li>最大目标码率（平均码率）/QP/Qfactor</li><li>码率波动登记</li><li>各个类型帧之间的QPdelta</li></ul><h4 id="4-2-3-参考帧关系参数"><a href="#4-2-3-参考帧关系参数" class="headerlink" title="4.2.3 参考帧关系参数"></a>4.2.3 参考帧关系参数</h4><ul><li>参考帧类型（GOP类型）</li><li>长期参考帧间隔</li><li>虚拟I帧间隔</li><li>IDR帧间隔</li><li>参考帧数目</li><li>双帧参考</li></ul><h3 id="4-3、高级编码参数"><a href="#4-3、高级编码参数" class="headerlink" title="4.3、高级编码参数"></a>4.3、高级编码参数</h3><h4 id="4-3-1、宏块级编码配置"><a href="#4-3-1、宏块级编码配置" class="headerlink" title="4.3.1、宏块级编码配置"></a>4.3.1、宏块级编码配置</h4><ul><li>预测编码</li><li>变换、量化</li><li>熵编码类型</li><li>Vui</li></ul><h4 id="4-3-2、环路滤波"><a href="#4-3-2、环路滤波" class="headerlink" title="4.3.2、环路滤波"></a>4.3.2、环路滤波</h4><ul><li>去块滤波参数</li><li>SAO使能开关</li></ul><h4 id="4-3-3、码率控制高级参数"><a href="#4-3-3、码率控制高级参数" class="headerlink" title="4.3.3、码率控制高级参数"></a>4.3.3、码率控制高级参数</h4><ul><li>分层QP</li><li>高级码率控制参数（QPMAP、QP limit）</li><li>ROI</li><li>Skip倾向性</li><li>Intra倾向性</li></ul><h4 id="4-3-4、参考帧关系高级特性"><a href="#4-3-4、参考帧关系高级特性" class="headerlink" title="4.3.4、参考帧关系高级特性"></a>4.3.4、参考帧关系高级特性</h4><ul><li>高级跳帧参考</li><li>强制IDR帧</li><li>强制虚拟I帧/Fast seek帧</li><li>随机丢帧</li></ul><h4 id="4-3-5、并行化特性"><a href="#4-3-5、并行化特性" class="headerlink" title="4.3.5、并行化特性"></a>4.3.5、并行化特性</h4><ul><li>Slice</li><li>Tile</li></ul><h4 id="4-3-6、编码器输出参数"><a href="#4-3-6、编码器输出参数" class="headerlink" title="4.3.6、编码器输出参数"></a>4.3.6、编码器输出参数</h4><ul><li>SSE</li><li>PSNR,纹理复杂度信息</li></ul><h4 id="4-3-7、其他特性"><a href="#4-3-7、其他特性" class="headerlink" title="4.3.7、其他特性"></a>4.3.7、其他特性</h4><ul><li>帧内刷新</li><li>超大帧处理</li><li>去除呼吸效应</li><li>前景保护</li><li>智能编码库（低码率库）</li></ul><hr><h2 id="THE-END！"><a href="#THE-END！" class="headerlink" title="THE END！ "></a><font color="red"><strong>THE END！</strong> </font></h2>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 编解码 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Codecs </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图像去雾技术研究</title>
      <link href="/2019/10/20/%E3%80%90CV%E7%B3%BB%E5%88%97%E3%80%91%E5%9B%BE%E5%83%8F%E5%8E%BB%E9%9B%BE%E6%8A%80%E6%9C%AF%E7%A0%94%E7%A9%B6/"/>
      <url>/2019/10/20/%E3%80%90CV%E7%B3%BB%E5%88%97%E3%80%91%E5%9B%BE%E5%83%8F%E5%8E%BB%E9%9B%BE%E6%8A%80%E6%9C%AF%E7%A0%94%E7%A9%B6/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>&ensp; &ensp; &ensp; 在雾霾等天气条件下，大气粒子的散射作用以及大气粒子本身会导致成像传感器采集的图像严重降质。因此图像去雾算法就成为了图像处理和计算机视觉领域中一个非常重要的研究方向，主要应用在视频监控、地形勘测和自动驾驶等领域。图像去雾技术的主要任务就是去除天气因素对图像质量的影响，从而增强图像的可见度。本文主要对当前最新的去雾技术进行调研，分析各种去雾算法的优缺点，并实现目前主流的去雾算法。</p><h2 id="1、参考"><a href="#1、参考" class="headerlink" title="1、参考"></a>1、参考</h2><p><a href="https://www.cnblogs.com/Imageshop/p/3281703.html" target="_blank" rel="noopener">《Single Image Haze Removal Using Dark Channel Prior》一文中图像去雾算法的原理、实现、效果（速度可实时）</a><br><a href="https://zhuanlan.zhihu.com/p/40844375" target="_blank" rel="noopener">技术前沿：图像去雨滴算法</a><br><a href="https://blog.csdn.net/qq_35608277/article/details/81512583" target="_blank" rel="noopener">去雾去雨</a><br><a href="https://blog.csdn.net/s12244315/article/details/50292049" target="_blank" rel="noopener">图像去雾之何凯明暗通道先验去雾算法原理及c++代码实现</a><br><a href="https://www.cnblogs.com/Imageshop/p/3410279.html" target="_blank" rel="noopener">一种可实时处理 O(1)复杂度图像去雾算法的实现。</a><br><a href="http://www.cs.columbia.edu/CAVE/software/" target="_blank" rel="noopener">哥伦比亚大学WILD数据库</a></p><h2 id="2、文献跟踪"><a href="#2、文献跟踪" class="headerlink" title="2、文献跟踪"></a>2、文献跟踪</h2><h3 id="2-1-英文文献"><a href="#2-1-英文文献" class="headerlink" title="2.1 英文文献"></a>2.1 英文文献</h3><p><a href="https://sci-hub.tw/10.1109/cvpr.2008.4587643" target="_blank" rel="noopener">2008_CVPR_Tan_Visibility in bad weather from a single image</a></p><p><a href="https://www.cse.huji.ac.il/~raananf/papers/defog.pdf" target="_blank" rel="noopener">2008_ACM_Fattal_single image dehazing</a></p><p><a href="https://sci-hub.tw/https://ieeexplore.ieee.org/document/7752955/" target="_blank" rel="noopener">Lee, Y., Hirakawa, K., &amp; Nguyen, T. Q. (2017). Joint Defogging and Demosaicking. IEEE Transactions on Image Processing, 26(6), 3051–3063. doi:10.1109/tip.2016.2631880 </a></p><p><a href="https://dacemirror.sci-hub.tw/journal-article/207985df0f295083a5b9c1de09adc9e5/kaiminghe2011.pdf?rand=5db162457d04f#view=FitH" target="_blank" rel="noopener">2011_TPAMI_HeKaiming_Single Image Haze Removal Using Dark Channel Prior</a></p><p><a href="https://twin.sci-hub.tw/5867/395b729002f69c48399199812255f89f/cai2016.pdf#view=FitH" target="_blank" rel="noopener">2016_cai_TIP_DehazeNet An End-to-End System for Single Image Haze Removal</a></p><p><a href="https://twin.sci-hub.tw/6434/d94a01416b7c83c8952c19eebb24e500/wang2017.pdf#view=FitH" target="_blank" rel="noopener">2017_TCSVT_wang_Single Image Dehazing Based on the Physical Model and MSRCR Algorithm</a></p><p><a href="https://dacemirror.sci-hub.tw/journal-article/25ec4b30b80b4c84295de34b012d07d6/wang2014.pdf#view=FitH" target="_blank" rel="noopener">2014_TIP_wang_Single Image Defogging by Multiscale Depth Fusion</a></p><p><a href="https://twin.sci-hub.tw/6861/3c1334459c686e0fb489c9f660f0dc38/andrade2017.pdf#view=FitH" target="_blank" rel="noopener">2017_TLAT_andrade_Improvement of visibility under foggy conditions</a></p><p><a href="https://arxiv.org/pdf/1102.3328v1.pdf" target="_blank" rel="noopener">2011_Xuan_An Efficient and Integrated Algorithm for video enhancement in challenging lighting conditions</a></p><p><a href="https://dacemirror.sci-hub.tw/journal-article/cefe76f2a1fd3e95c8aa36380364c20b/li2015.pdf#view=FitH" target="_blank" rel="noopener">2015_TIP_Li_Edge-Preserving Decomposition-based Single Image Haze Removal</a></p><p><a href="https://dacemirror.sci-hub.tw/journal-article/6f500ac7d9c92f1c54be22ff0a48fc9b/liu2018.pdf#view=FitH" target="_blank" rel="noopener">2018_TIP_Liu_Contrast in Haze Removal_Configurable Contrast Enhancement Model Based on Dark Channel Prior</a></p><p><a href="https://zero.sci-hub.tw/3177/139604df5db0f01a08087be3ce4e2b3d/makarau2014.pdf#view=FitH" target="_blank" rel="noopener">2014_TIP_makarau_Haze Detection and Removal in Remotely Sensed Multispectral Imagery</a></p><p><a href="https://sci-hub.tw/downloads/2019-10-28/69/kim2019.pdf?rand=5db6b2cb979c5#view=FitH" target="_blank" rel="noopener">2019_TIP_Kim_Fast Single Image Dehazing Using Saturation Based Transimission Map Estimation</a></p><p><a href="https://twin.sci-hub.tw/6573/b490463b5e1f0083dd158388f999c4d9/li2017.pdf#view=FitH" target="_blank" rel="noopener">2017_TIP_Li_Single Image De-Hazing Using Globally Guided Image Filtering</a></p><p><a href="https://twin.sci-hub.tw/6671/813414db008fa079b3794d3b760f26a2/wei2017.pdf#view=FitH" target="_blank" rel="noopener">2017_ISCID_Wei_Low Light Image Enhancement Based on Luminance map and Haze Removal Model</a></p><p><a href="https://dacemirror.sci-hub.tw/proceedings-article/919ff593df1f244ae997f766ec67363f/iwamoto2018.pdf?rand=5db6cb253f7d5#view=FitH" target="_blank" rel="noopener">2018_ICNC_iwamoto_Fast Dark Channel Prior Based Haze Removal from a Single Image</a></p><p><a href="https://dacemirror.sci-hub.tw/journal-article/09382a1652c930f3fe938af35e9a0f1d/guo2017.pdf?rand=5db6d489f3ecd#view=FitH" target="_blank" rel="noopener">2017_TIP_guo_An Efficient Fusion-Based Defogging</a></p><p><a href="https://twin.sci-hub.tw/6914/d26f62d1cd48f42a40149bc72ccee7d8/tufail2018.pdf#view=FitH" target="_blank" rel="noopener">2018_IEEE Access_tufail_Improved Dark Channel Prior for Image Defogging using RGB and YCbCr ColorSpace</a></p><p>雾天检测：<br><a href="https://sci-hub.tw/10.1007/978-3-642-38715-9_52" target="_blank" rel="noopener">Video Image Clarity Algorithm Research of USV Visual System under the Sea Fog</a></p><h3 id="2-2-中文文献"><a href="#2-2-中文文献" class="headerlink" title="2.2  中文文献"></a>2.2  中文文献</h3><p><a href="https://www.ixueshu.com/document/347a218513581d6d318947a18e7f9386.html" target="_blank" rel="noopener">改进的基于暗原色先验的图像去雾算法</a><br><a href="http://xueshu.baidu.com/usercenter/paper/show?paperid=629b983147f11875e4c2131ac9ed44d4&site=xueshu_se&hitarticle=1" target="_blank" rel="noopener">图像去雾的无参考客观质量评测方法</a><br><a href="http://xueshu.baidu.com/usercenter/paper/show?paperid=aef9a018c719385d2d80275544f9bf93&site=xueshu_se&hitarticle=1" target="_blank" rel="noopener">图像快速去雾与清晰度恢复技术研究</a><br><a href="http://xueshu.baidu.com/usercenter/paper/show?paperid=87f13d14c1ec5d57c9a00e808672126b&site=xueshu_se&hitarticle=1" target="_blank" rel="noopener">基于双边滤波的实时图像去雾技术研究</a></p><h2 id="3、Github-code"><a href="#3、Github-code" class="headerlink" title="3、Github code"></a>3、Github code</h2><p><a href="ttps://github.com/Sar-Kerson/dehazeProcessor" target="_blank" rel="noopener">dehazeProcessor</a><br><a href="https://github.com/evmavrop/Hyperion" target="_blank" rel="noopener">Hyperion</a><br><a href="https://github.com/caibolun/DehazeNet" target="_blank" rel="noopener">DehazeNet</a></p><h2 id="4、图像去雾算法综述"><a href="#4、图像去雾算法综述" class="headerlink" title="4、图像去雾算法综述"></a>4、图像去雾算法综述</h2><h3 id="4-1-Overview-papers"><a href="#4-1-Overview-papers" class="headerlink" title="4.1  Overview papers"></a>4.1  Overview papers</h3><p><a href="https://cyber.sci-hub.tw/MTAuMTEwOS90aXAuMjAxMS4yMTY2OTY4/gibson2012.pdf#view=FitH" target="_blank" rel="noopener">2012_TIP_gibson-An Investigation of Dehazing Effects on Image and Video Coding</a></p><p><a href="https://zero.sci-hub.tw/2717/5deae28ee0b28b39af20d2d91fffb708/yadav2014.pdf#view=FitH" target="_blank" rel="noopener">2014_ICSPCT_yadav_Fog Removal Techniques From Images_A Comparative Review and Future Directions</a></p><p><a href="https://moscow.sci-hub.tw/4529/c575f8b9aab1f29c2716d7d421d1f572/chengtao2015.pdf#view=FitH" target="_blank" rel="noopener">2015_CCDC_chengtao_A survey of image dehazing approaches</a></p><p><a href="https://zero.sci-hub.tw/4866/bd097a47965b2a9cf51262f3e3297d49/xu2016.pdf#view=FitH" target="_blank" rel="noopener">2016_IEEE Access_xu_Review of Video and Image Defogging Algorithms and Related Studies on Image Restoration and Enhancement</a></p><p><a href="https://twin.sci-hub.tw/6417/6b1c3eaac8bce578fe195243a0598c9a/kaur2017.pdf#view=FitH" target="_blank" rel="noopener">2017_AEEICB_kaur_Comparative Study on Various Single Image Defogging Techniques</a></p><p><a href="https://twin.sci-hub.tw/7155/9447cb8def91fb9bd1ff1e62ba02b22c/min2018.pdf#view=FitH" target="_blank" rel="noopener">2018_ITS_min_Objective Quality Evaluation of Dehazed Images</a></p><p><a href="http://219.223.211.110/bitstream/F44010/2995/1/%E5%9B%BE%E5%83%8F%E5%8E%BB%E9%9B%BE%E6%8A%80%E6%9C%AF%E7%A0%94%E7%A9%B6%E8%BF%9B%E5%B1%95.pdf" target="_blank" rel="noopener">图像去雾技术研究进展</a></p><p><a href="http://www.joca.cn/CN/article/downloadArticleFile.do?attachType=PDF&id=13178" target="_blank" rel="noopener">图像去雾技术研究综述与展望</a></p><p><a href="http://www.aas.net.cn/CN/article/downloadArticleFile.do?attachType=PDF&id=18603" target="_blank" rel="noopener">图像去雾的最新研究进展</a></p><p><a href="一年去雾算法研究的总结。">一年去雾算法研究的总结。</a></p><p><a href="https://blog.csdn.net/u013684730/article/details/76640321" target="_blank" rel="noopener">图像去雾技术综述</a></p><h3 id="4-2-视频-图像去雾算法概述"><a href="#4-2-视频-图像去雾算法概述" class="headerlink" title="4.2  视频/图像去雾算法概述"></a>4.2  视频/图像去雾算法概述</h3><p>&ensp; &ensp;  去雾工作主要包括单幅图像去雾、视频去雾、雾天检测和构建去雾效果的客观评价体系四大内容。本文主要概述单幅图像去雾和视频去雾的内容。雾天图像的主要特征包括低对比度、低饱和度和亮度偏低，去雾处理后会产生色调偏移（颜色失真）、Halo光晕、过度增强等现象。<br>&ensp; &ensp;  目前对于雾天图像处理方法主要分为两大类：增强类和复原类。近年来，又有学者提出了基于融合和基于深度学习的去雾算法。</p><ul><li>基于增强的方法不考虑图像降质的原因，适用范围广，能有效提高雾天图像的对比度，突出图像的细节，改善图像的视觉效果，但是对于细节部分的信息可能会造成一定损失，存在颜色失真和色调偏移的问题，这点和增强类算法用于低照度图像增强是一样的。</li><li>基于复原的方法研究雾天图像降质的物理过程，并建立雾天退化模型（大气散射模型），反演退化过程，补偿退化过程造成的失真，以便获得未经干扰退化的无雾图像或无雾图像的最优估计值，从而改善雾天图像质量。这种方法针对性强，得到的去雾效果自然，一般不会有信息损失，处理的关键点在于模型中参数的估计。具体分类如下图所示：</li></ul><p>下图引用自：<a href="http://www.joca.cn/CN/article/downloadArticleFile.do?attachType=PDF&id=13178" target="_blank" rel="noopener">图像去雾技术研究综述与展望</a><br><img src="/img/20191030202107337.png" alt="图像去雾技术"></p><h2 id="5、图像去雾算法研究"><a href="#5、图像去雾算法研究" class="headerlink" title="5、图像去雾算法研究"></a>5、图像去雾算法研究</h2><h3 id="5-1-基于图像处理的雾天图像增强方法-Image-enhancement"><a href="#5-1-基于图像处理的雾天图像增强方法-Image-enhancement" class="headerlink" title="5.1 基于图像处理的雾天图像增强方法(Image enhancement)"></a>5.1 基于图像处理的雾天图像增强方法(Image enhancement)</h3><p><strong>（一）、全局化增强方法</strong></p><ul><li><p>全局直方图均衡化：提升图像对比度，但是会造成颜色失真和过度增强的问题。<br>(1) 基本思想：把有雾图像的直方图变换为均匀分布的形式，这样就增加了像素灰度值的动态范围从而达到增强雾天图像整体对比度的效果。<br>(2) 优缺点：优点是算法简单，对单景深图像的复原效果较好；缺点是很难反映景深多变的图像中局部景深的变化，会造成过度增强、细节损失和颜色失真的问题。<br>注： 景深（DOF），是指在摄影机镜头或其他成像器前沿能够取得清晰图像的成像所测定的被摄物体前后距离范围。而光圈、镜头、及拍摄物的距离是影响景深的重要因素<br>(3) 处理效果图：<br><img src="/img/20191031205452235.png" alt="全局直方图均衡化处理效果图"></p></li><li><p>同态滤波 Homomorphic filtering：同态滤波可以通过高通滤波来增强高频分量，减少低频分量。这种方法简单快速，但是不能处理浓雾或不均匀雾天的情况。<br>(1) 基本思想：该算法是一种把频率过滤和灰度变换相结合的图像增强方法，通过增强高频分量减少低频分量，照射分量对应低频分量，变化缓慢；反射分量对应高频分量，描述图像细节。<br>(2) 优缺点：优点是能去掉由光照不均所产生的黑斑暗影，能较好地保持图像的原始面貌；缺点是需要两次傅里叶变换，占用较大的运算空间。</p></li><li><p>小波方法：<br>(1) 基本思想：和同态滤波相似，小波变换方法也是增强图像的高频分量，减少低频分量。<br>(2) 优缺点：小波变换能够较好的增强图像的细节，但是无法解决图像过亮、过暗或者是光照不均的情况。</p></li><li><p>Retinex模型方法：<br>(1) 基本思想：通过求解Retinex模型得到反射分量。<br>(2) 优缺点：简单快速，非常适合于薄雾去除。但是不能增强不均匀雾天的场景，也不能够增强雾天图像的局部细节。<br>更多参考： <a href="https://www.cnblogs.com/Imageshop/archive/2013/04/17/3026881.html" target="_blank" rel="noopener">https://www.cnblogs.com/Imageshop/archive/2013/04/17/3026881.html</a><br>(3) 处理效果图：<br><img src="/img/2019103120594530.png" alt="Retinex模型方法处理效果图"></p></li><li><p>高提升滤波 Highboost filtering：这种方法增强高频分量，简单快速，但是会造成颜色失真和噪声放大。<br>(1) 基本思想：高提升滤波是通过增强图像的高频分量实现去雾的。高提升滤波结合掩模图像和原始图像来提高高频分量。<br>(2) 优缺点：这种方法简单快速，可以改善可见性，但是会造成颜色失真和噪声扩散。<br>(3) 处理效果图：</p></li></ul><p><strong>待补充</strong></p><p><strong>（二）、局部化增强方法</strong><br>局部直方图均衡化等。<br>文献：<a href="https://sci-hub.tw/https://ieeexplore.ieee.org/document/6968381" target="_blank" rel="noopener">Contrast limited adaptive histogram equalization based enhancement for real time video system</a><br>(1) 基本思想：将直方图均衡化运算分散到图像所有局部区域，通过局部运算的叠加自适应地增强局部信息。<br>(2) 优缺点：可使所关系的局部区域得到所需的增强效果，但是运算量大、存在局部块效应的现象。<br>(3) 处理效果图： OpenCV实现（CLAHE）<br><img src="/img/20191103210308139.png" alt="局部直方图均衡化处理效果图"><br>注：<br>（1）这类方法只能适用于景深一致的特定雾天场景，并且会出现过度增强和颜色失真的问题。并且对于不均匀雾天的情况也不适用。<br>（2）但是对于一些浓雾场景，采用直方图均衡化的方法的去雾效果要优于基于Retinex模型的方法和基于物理模型的方法。</p><h3 id="5-2-基于物理模型的雾天图像复原方法-Image-restoration"><a href="#5-2-基于物理模型的雾天图像复原方法-Image-restoration" class="headerlink" title="5.2 基于物理模型的雾天图像复原方法(Image restoration)"></a>5.2 基于物理模型的雾天图像复原方法(Image restoration)</h3><p>基于物理模型的方法利用大气散射模型，通过求解图像降质过程的逆过程来恢复清晰图像。它的目的是使估计图像尽可能逼近真实图像，属于图像复原的范畴。</p><p>大气散射模型：雾天图像降质的物理原理<br><img src="/img/20191029165315680.png" alt="大气散射模型"><br>模型公式如下：<br><img src="/img/20191030141200613.png" alt="模型公式"></p><p>利用大气散射模型将有雾图像恢复到无雾图像的方法，总体上可以分为三类：<br><strong>（1）基于景物深度信息的方法</strong>：这类方法使用某种手段得到图像中的深度信息，进而求解出图像退化模型的参数，把参数代入模型中，反演估计出无雾的图像。<br>注：这类方法需要通过某种手段（比如雷达装置）获取场景深度信息，条件苛刻，<font color="red">非自动</font>，很难满足实时图像处理需求。</p><p><strong>（2）基于大气光偏振特性的去雾算法：</strong> 能够有效提高雾天降质图像的对比度，视觉效果明显改善，但是图像深度的获取和大气散射系数的修改都<font color="red">需要用户参与</font>。</p><p><strong>（3）基于先验知识的去雾方法：</strong><br>经典文献主要有三篇:<br>[1].<a href="https://sci-hub.tw/10.1109/cvpr.2008.4587643" target="_blank" rel="noopener">2008_CVPR_Tan_Visibility in bad weather from a single image</a><br>文章思想：Tan基于统计信息，认为无雾图像相对于有雾图像来说对比度要高很多，并且在小的局部区域太阳光会变化很缓慢。作者首先采用白平衡操作将输入图像转换成白颜色，然后采用马尔科夫随机场对环境光模型进行建模。基于这个模型，环境光通过最大化恢复图像的局部对比度来估计。这种方法的目的是获得恢复图像的最大对比度，但是没有考虑颜色失真，会产生增强图像的颜色失真；由于采用基于块的操作估计环境光模型也会出现Halo现象。</p><p>[2].<a href="https://www.cse.huji.ac.il/~raananf/papers/defog.pdf" target="_blank" rel="noopener">2008_ACM_Fattal_single image dehazing</a><br>文章思想：Fattal将大气散射模型中的未知图像J(x)分解为表面反射率R和浓度系数l的乘积。作者假设一个前提，表面阴影和传输函数是统计无关的，根据这一前提对大气散射模型进行运算分析，即可求得传输函数并对图像去雾。Fattal的去雾算法是基于统计特性来估计参数用于恢复图像，但是这个算法对于浓雾和低信噪比情况下效果会很差。<br>算法详细介绍可参考：<a href="https://www.cnblogs.com/rust/p/10429333.html" target="_blank" rel="noopener">Single Image Dehazing</a></p><p>[3].<a href="https://dacemirror.sci-hub.tw/journal-article/207985df0f295083a5b9c1de09adc9e5/kaiminghe2011.pdf?rand=5db162457d04f#view=FitH" target="_blank" rel="noopener">2011_TPAMI_HeKaiming_Single Image Haze Removal Using Dark Channel Prior</a><br>文章思想：He通过对大量无雾图像统计特征的观察，发现了被命名为暗原色先验的先验规律，即在无雾图像的非天空区域里，若把图像分为多个子块，则每个子块中都会有某些像素的一个颜色通道的亮度接近于0。<br>算法详细介绍可参考：<a href="https://blog.csdn.net/SoaringLee_fighting/article/details/102820169" target="_blank" rel="noopener">【CV系列】The Analysis of Single Image Haze Removal Using Dark Channel Prior</a></p><h3 id="5-3-基于融合的图像去雾算法-fusion-based"><a href="#5-3-基于融合的图像去雾算法-fusion-based" class="headerlink" title="5.3 基于融合的图像去雾算法(fusion-based)"></a>5.3 基于融合的图像去雾算法(fusion-based)</h3><p>基于融合的方法：<br><a href="https://sci-hub.tw/https://ieeexplore.ieee.org/document/5413700" target="_blank" rel="noopener">Color image dehazing using the near-infrared</a></p><p><a href="https://doclib.uhasselt.be/dspace/bitstream/1942/11702/1/FINAL_ACCV_Dehazing.pdf" target="_blank" rel="noopener">A Fast Semi-Inverse Approach to Detect and Remove the Haze from a Single Image</a></p><p><a href="https://www.csie.ntu.edu.tw/~b98902025/%E8%AA%B2%E6%A5%AD/DIP/(wei)Effective%20Single%20Image%20Dehazing%20by%20Fusion.pdf" target="_blank" rel="noopener">Effective single image dehazing by fusion</a></p><p><a href="http://www.upt.ro/img/files/2016-2017/doctorat/abilitare/ancuti/10_lucrari_reperezentative_Codruta_Ancuti.pdf" target="_blank" rel="noopener">Single Image Dehazing by Multi-Scale Fusion</a></p><p><a href="https://sci-hub.tw/https://ieeexplore.ieee.org/document/7342728" target="_blank" rel="noopener">Fusion strategy for single image dehazing</a></p><p>基于理论：近红外光的散射要远远小于可见光的散射。所以在雾天场景下，近红外图像比可见光图像具有更多的细节信息和高对比度。因此，很多学者通过融合近红外图像和可见光图像的方法来增强雾天图像的可见度。<br>缺点：但是由于没有考虑雾天图像的深度信息，所以不适合处理不均匀雾天的场景。</p><h3 id="5-4-基于深度学习的图像去雾算法-DL-based"><a href="#5-4-基于深度学习的图像去雾算法-DL-based" class="headerlink" title="5.4 基于深度学习的图像去雾算法(DL-based)"></a>5.4 基于深度学习的图像去雾算法(DL-based)</h3><p>CNN： <a href="https://twin.sci-hub.tw/5867/395b729002f69c48399199812255f89f/cai2016.pdf#view=FitH" target="_blank" rel="noopener">2016_cai_TIP_DehazeNet An End-to-End System for Single Image Haze Removal</a></p><p>RNN：<a href="https://twin.sci-hub.tw/6689/ebb578f23da6393ff3c847414f91235f/jiang2018.pdf#view=FitH" target="_blank" rel="noopener">2018_TII_jiang_Video Image Defogging Recognition based on Recurrent Nerual Network</a></p><h3 id="5-5-图像去雾算法的客观评价准则"><a href="#5-5-图像去雾算法的客观评价准则" class="headerlink" title="5.5 图像去雾算法的客观评价准则"></a>5.5 图像去雾算法的客观评价准则</h3><p><strong>（1）图像可视性的评价准则</strong></p><ul><li>盲参考评价指标（e,r）</li><li>Image Visibility mesurement(IVM)</li><li>图像对比度</li><li>Visual contrast measure(VCM)</li></ul><p><strong>（2）颜色失真评价准则</strong></p><ul><li>盲参考评价指标（sigma）</li></ul><p><strong>（3）图像结构相似性</strong></p><ul><li>SSIM</li><li>Universal quality index(UQI)</li></ul><h3 id="5-6-主要图像去雾算法的对比分析"><a href="#5-6-主要图像去雾算法的对比分析" class="headerlink" title="5.6 主要图像去雾算法的对比分析"></a>5.6 主要图像去雾算法的对比分析</h3><p>引用自：<a href="http://www.joca.cn/CN/article/downloadArticleFile.do?attachType=PDF&id=13178" target="_blank" rel="noopener">图像去雾技术研究综述与展望</a><br><img src="/img/2019103020234964.png" alt="图像去雾技术研究综述与展望"></p><h3 id="5-7-雾天图像测试集"><a href="#5-7-雾天图像测试集" class="headerlink" title="5.7 雾天图像测试集"></a>5.7 雾天图像测试集</h3><p>NASA提供的雾天图像标准测试集：<br><a href="https://dragon.larc.nasa.gov/retinex/757/" target="_blank" rel="noopener">https://dragon.larc.nasa.gov/retinex/757/</a></p><hr><h2 id="THE-END"><a href="#THE-END" class="headerlink" title=" THE END! "></a><font color="red"> THE END! </font></h2>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 图像处理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CV </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>颜色空间转换CSConvert：YUV420P转MonoY</title>
      <link href="/2019/10/19/%E3%80%90Codecs%E7%B3%BB%E5%88%97%E3%80%91%E9%A2%9C%E8%89%B2%E7%A9%BA%E9%97%B4%E8%BD%AC%E6%8D%A2CSConvert%EF%BC%9AYUV420P%E8%BD%ACMonoY/"/>
      <url>/2019/10/19/%E3%80%90Codecs%E7%B3%BB%E5%88%97%E3%80%91%E9%A2%9C%E8%89%B2%E7%A9%BA%E9%97%B4%E8%BD%AC%E6%8D%A2CSConvert%EF%BC%9AYUV420P%E8%BD%ACMonoY/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="1、实现功能"><a href="#1、实现功能" class="headerlink" title="1、实现功能"></a>1、实现功能</h2><p>将YUV420P转换成亮度分量Y，比较简单，实现代码如下：</p><h2 id="2、C代码实现"><a href="#2、C代码实现" class="headerlink" title="2、C代码实现"></a>2、C代码实现</h2><pre><code class="c">#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;int main(int argc, char** argv){    int width, height;    int frame_size, frame_size_y;    FILE *fin, *fou;    char *y, *u, *v,*u1,*v1;    int i, frame_num = 0;    char outname[512] = { 0, };    printf(&quot;\nUsage:YUV420PtoMonoY.exe input.yuv output.yuv width height\n\n&quot;);    if (argc != 5)    {        return -1;    }    fin = fopen(argv[1], &quot;rb&quot;);    if (fin == NULL)    {        printf(&quot;error:open %s fail\n&quot;, argv[1]);        return -1;    }    sprintf_s(outname,&quot;%s&quot;, argv[2]);    width = atoi(argv[3]);    height = atoi(argv[4]);    frame_size = width*height * 3 / 2;    frame_size_y = width * height;    y = (char *)malloc(frame_size_y);    if (y == NULL)    {        printf(&quot;malloc y fail\n&quot;);        return -1;    }    fou = fopen(outname, &quot;wb&quot;);    if (fou == NULL)    {        printf(&quot;error: open %s fail\n&quot;, outname);        return -1;    }    while (width*height == fread(y, 1, width*height, fin))    {        fwrite(y, 1, frame_size_y, fou);        fseek(fin, frame_size_y/2, SEEK_CUR);        printf(&quot;%dth frame ok!!\n&quot;, frame_num);        frame_num++;    }    printf(&quot;YUV420P to MonoY successfully!!, stotal frames: %d\n&quot;,frame_num);    free(y);    y = NULL;    fclose(fin);    fclose(fou);    system(&quot;pause&quot;);    return 0;}</code></pre><hr><h4 id="THE-END"><a href="#THE-END" class="headerlink" title=" THE  END! "></a><font color="red"> <strong>THE  END!</strong> </font></h4>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 视频处理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Video </tag>
            
            <tag> CSConvert </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于变化与成长的小思考</title>
      <link href="/2019/09/15/%E3%80%90Think%E7%B3%BB%E5%88%97%E3%80%91%E5%85%B3%E4%BA%8E%E5%8F%98%E5%8C%96%E4%B8%8E%E6%88%90%E9%95%BF%E7%9A%84%E5%B0%8F%E6%80%9D%E8%80%83/"/>
      <url>/2019/09/15/%E3%80%90Think%E7%B3%BB%E5%88%97%E3%80%91%E5%85%B3%E4%BA%8E%E5%8F%98%E5%8C%96%E4%B8%8E%E6%88%90%E9%95%BF%E7%9A%84%E5%B0%8F%E6%80%9D%E8%80%83/</url>
      
        <content type="html"><![CDATA[<p>最近，一直有个问题困惑于心良久，苦苦不能思索明白，于是有了下面的一些小思考。</p><p>古人云：穷则变，变则通，通则久。</p><p>也有人说，以不变应万变？ 变化只是为了不变。</p><p>只有变化才能成长吗？那需要什么样的变化，才是真正的成长呢？</p><p>我们都喜欢在自己的舒适区里，不去改变，保持现状，安安稳稳。有人会选择这样的生活，这样的生活有什么不好吗，这样的生活难道就没有成长吗？当然也有人不断去突破自己，改变自己，成长很多，改变很多，有些人改变的连自己可能都不认识了，忘记了初心？这样的改变带来的成长有意义吗？</p><p>起初，自己很不希望被改变，抵触变化，不希望成为像社畜般做事的工具，不喜欢社会中的一些条条框框和形式化。然而，我们其实在一直改变着，无论是自己主动改变还是被迫改变着，所有的这些改变都会带给我们或多或少的成长。所以，在坚守自己初心的前提下，所有的改变都是有一定意义的，或许很多改变会影响我们一生，我愿意去接受这些改变，开始新的生活。</p><p>我想，在改变的过程中，那些不忘初心的改变和有意义的改变才会带来真正的成长。</p><p>我们要去不断的改变自己，完善自己，不断的成长，通过不断改变和进步来实现内心中信念的不变。</p><p>我们都有选择生活的权利，无论想要过什么样的生活，都应该敢于迈出生活的每一步，坚持自己的选择。或许我们应该在年轻的时候多去尝试生活的不同选择，每一种生活中都会有不一样的风景，会遇见不一样的人，会经历一些人生世事，或许你所经历的事正是别人所希冀的。你要相信，有人正过着你所希望的生活，当然他们定也付出了你所没有付出的努力。或许，我们只有经过很多的努力，才能成为自己想成为的人，过上自己想要的生活吧。</p><p>写了很多，不知道说了些什么，似乎对改变和成长有了一些自己的认识，希望所有的改变都会带给我们真正的成长！</p><hr><p>&ensp; &ensp; &ensp; &ensp; &ensp; &ensp; &ensp; &ensp; &ensp; &ensp; &ensp; &ensp; &ensp; &ensp; &ensp; &ensp; &ensp; &ensp; &ensp; &ensp; &ensp; &ensp; &ensp; &ensp; &ensp; &ensp; &ensp; &ensp; &ensp; &ensp; &ensp; &ensp;    记于浙江杭州  2019年中秋</p>]]></content>
      
      
      <categories>
          
          <category> 生活 </category>
          
          <category> 规划 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Think </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>select()函数的用法及实例</title>
      <link href="/2019/09/15/%E3%80%90Linux%E7%B3%BB%E5%88%97%E3%80%91select()%E5%87%BD%E6%95%B0%E7%9A%84%E7%94%A8%E6%B3%95%E5%8F%8A%E5%AE%9E%E4%BE%8B/"/>
      <url>/2019/09/15/%E3%80%90Linux%E7%B3%BB%E5%88%97%E3%80%91select()%E5%87%BD%E6%95%B0%E7%9A%84%E7%94%A8%E6%B3%95%E5%8F%8A%E5%AE%9E%E4%BE%8B/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="1、参考"><a href="#1、参考" class="headerlink" title="1、参考"></a>1、参考</h2><p><a href="https://www.cnblogs.com/zhangshenghui/p/6097387.html" target="_blank" rel="noopener">select()函数以及FD_ZERO、FD_SET、FD_CLR、FD_ISSET</a><br><a href="https://www.cnblogs.com/wuyepeng/p/9745573.html" target="_blank" rel="noopener">select函数及fd_set介绍</a></p><h2 id="2、select-函数使用方法"><a href="#2、select-函数使用方法" class="headerlink" title="2、select()函数使用方法"></a>2、select()函数使用方法</h2><p>select函数用于在非阻塞中，当一个套接字或一组套接字有信号时通知你，系统提供select函数来实现多路复用输入/输出模型，<br>原型：</p><pre><code class="c">int select(int maxfd,fd_set *rdset,fd_set *wrset,fd_set *exset,struct timeval *timeout);</code></pre><p>所在的头文件为：</p><pre><code class="c">#include &lt;sys/time.h&gt;#include &lt;unistd.h&gt;</code></pre><p><strong>参数说明：</strong></p><blockquote><p>参数maxfd是需要监视的最大的文件描述符值+1；<br>rdset,wrset,exset分别对应于需要检测的可读文件描述符的集合，可写文件描述符的集 合及异常文件描述符的集合。<br>struct timeval结构用于描述一段时间长度，如果在这个时间内，需要监视的描述符没有事件发生则函数返回，返回值为0。</p></blockquote><p>对于fd_set类型通过下面四个宏来操作：</p><blockquote><p>FD_ZERO(fd_set *fdset) 将指定的文件描述符集清空，在对文件描述符集合进行设置前，必须对其进行初始化，如果不清空，由于在系统分配内存空间后，通常并不作清空处理，所以结果是不可知的。<br>FD_SET(fd_set *fdset) 用于在文件描述符集合中增加一个新的文件描述符。<br>FD_CLR(fd_set *fdset) 用于在文件描述符集合中删除一个文件描述符。<br>FD_ISSET(int fd,fd_set *fdset) 用于测试指定的文件描述符是否在该集合中。</p></blockquote><h2 id="３、编程实践"><a href="#３、编程实践" class="headerlink" title="３、编程实践"></a>３、编程实践</h2><p>下面这个例子是在海思芯片视频编码获取码流时采用select函数的实例。</p><pre><code class="c">HI_VOID* SAMPLE_COMM_VENC_GetVencStreamProc(HI_VOID *p){    HI_S32 i;    HI_S32 s32ChnTotal;    VENC_CHN_ATTR_S stVencChnAttr;    SAMPLE_VENC_GETSTREAM_PARA_S *pstPara;    HI_S32 maxfd = 0;    struct timeval TimeoutVal;    fd_set read_fds;    HI_S32 VencFd[VENC_MAX_CHN_NUM];    HI_CHAR aszFileName[VENC_MAX_CHN_NUM][64];    FILE *pFile[VENC_MAX_CHN_NUM];    char szFilePostfix[10];    VENC_CHN_STAT_S stStat;    VENC_STREAM_S stStream;    HI_S32 s32Ret;    VENC_CHN VencChn;    PAYLOAD_TYPE_E enPayLoadType[VENC_MAX_CHN_NUM];    pstPara = (SAMPLE_VENC_GETSTREAM_PARA_S*)p;    s32ChnTotal = pstPara-&gt;s32Cnt;    /******************************************     step 1:  check &amp; prepare save-file &amp; venc-fd    ******************************************/    if (s32ChnTotal &gt;= VENC_MAX_CHN_NUM)    {        SAMPLE_PRT(&quot;input count invaild\n&quot;);        return NULL;    }    for (i = 0; i &lt; s32ChnTotal; i++)    {        /* decide the stream file name, and open file to save stream */        VencChn = i;        s32Ret = HI_MPI_VENC_GetChnAttr(VencChn, &amp;stVencChnAttr);        if(s32Ret != HI_SUCCESS)        {            SAMPLE_PRT(&quot;HI_MPI_VENC_GetChnAttr chn[%d] failed with %#x!\n&quot;, \                   VencChn, s32Ret);            return NULL;        }        enPayLoadType[i] = stVencChnAttr.stVeAttr.enType;        s32Ret = SAMPLE_COMM_VENC_GetFilePostfix(enPayLoadType[i], szFilePostfix);        if(s32Ret != HI_SUCCESS)        {            SAMPLE_PRT(&quot;SAMPLE_COMM_VENC_GetFilePostfix [%d] failed with %#x!\n&quot;, \                   stVencChnAttr.stVeAttr.enType, s32Ret);            return NULL;        }        sprintf(aszFileName[i], &quot;stream_chn%d%s&quot;, i, szFilePostfix);        pFile[i] = fopen(aszFileName[i], &quot;wb&quot;);        if (!pFile[i])        {            SAMPLE_PRT(&quot;open file[%s] failed!\n&quot;,                   aszFileName[i]);            return NULL;        }        /* Set Venc Fd. */        VencFd[i] = HI_MPI_VENC_GetFd(i);        if (VencFd[i] &lt; 0)        {            SAMPLE_PRT(&quot;HI_MPI_VENC_GetFd failed with %#x!\n&quot;,                   VencFd[i]);            return NULL;        }        if (maxfd &lt;= VencFd[i])        {            maxfd = VencFd[i];        }    }    /******************************************     step 2:  Start to get streams of each channel.    ******************************************/    while (HI_TRUE == pstPara-&gt;bThreadStart)    {        FD_ZERO(&amp;read_fds);        for (i = 0; i &lt; s32ChnTotal; i++)        {            FD_SET(VencFd[i], &amp;read_fds);        }        TimeoutVal.tv_sec  = 2;        TimeoutVal.tv_usec = 0;        s32Ret = select(maxfd + 1, &amp;read_fds, NULL, NULL, &amp;TimeoutVal);        if (s32Ret &lt; 0)        {            SAMPLE_PRT(&quot;select failed!\n&quot;);            break;        }        else if (s32Ret == 0)        {            SAMPLE_PRT(&quot;get venc stream time out, exit thread\n&quot;);            continue;        }        else        {            for (i = 0; i &lt; s32ChnTotal; i++)            {                if (FD_ISSET(VencFd[i], &amp;read_fds))                {                    /*******************************************************                     step 2.1 : query how many packs in one-frame stream.                    *******************************************************/                    memset(&amp;stStream, 0, sizeof(stStream));                    s32Ret = HI_MPI_VENC_Query(i, &amp;stStat);                    if (HI_SUCCESS != s32Ret)                    {                        SAMPLE_PRT(&quot;HI_MPI_VENC_Query chn[%d] failed with %#x!\n&quot;, i, s32Ret);                        break;                    }                    /*******************************************************                     step 2.2 : suggest to check both u32CurPacks and u32LeftStreamFrames at the same time,for example:                     if(0 == stStat.u32CurPacks || 0 == stStat.u32LeftStreamFrames)                       {                            SAMPLE_PRT(&quot;NOTE: Current  frame is NULL!\n&quot;);                            continue;                       }                  *******************************************************/                    if(0 == stStat.u32CurPacks)                    {                        continue;                    }                    /*******************************************************                     step 2.3 : malloc corresponding number of pack nodes.                    *******************************************************/                    stStream.pstPack = (VENC_PACK_S*)malloc(sizeof(VENC_PACK_S) * stStat.u32CurPacks);                    if (NULL == stStream.pstPack)                    {                        SAMPLE_PRT(&quot;malloc stream pack failed!\n&quot;);                        break;                    }                    /*******************************************************                     step 2.4 : call mpi to get one-frame stream                    *******************************************************/                    stStream.u32PackCount = stStat.u32CurPacks;                    s32Ret = HI_MPI_VENC_GetStream(i, &amp;stStream, HI_TRUE);                    if (HI_SUCCESS != s32Ret)                    {                        free(stStream.pstPack);                        stStream.pstPack = NULL;                        SAMPLE_PRT(&quot;HI_MPI_VENC_GetStream failed with %#x!\n&quot;, \                               s32Ret);                        break;                    }                    /*******************************************************                     step 2.5 : save frame to file                    *******************************************************/                    s32Ret = SAMPLE_COMM_VENC_SaveStream(enPayLoadType[i], pFile[i], &amp;stStream);                    if (HI_SUCCESS != s32Ret)                    {                        free(stStream.pstPack);                        stStream.pstPack = NULL;                        SAMPLE_PRT(&quot;save stream failed!\n&quot;);                        break;                    }                    /*******************************************************                     step 2.6 : release stream                    *******************************************************/                    s32Ret = HI_MPI_VENC_ReleaseStream(i, &amp;stStream);                    if (HI_SUCCESS != s32Ret)                    {                        free(stStream.pstPack);                        stStream.pstPack = NULL;                        break;                    }                    /*******************************************************                     step 2.7 : free pack nodes                    *******************************************************/                    free(stStream.pstPack);                    stStream.pstPack = NULL;                }            }        }    }    /*******************************************************    * step 3 : close save-file    *******************************************************/    for (i = 0; i &lt; s32ChnTotal; i++)    {        fclose(pFile[i]);    }    return NULL;}</code></pre><hr><h2 id="THE-END"><a href="#THE-END" class="headerlink" title=" THE END! "></a><font color="red"> <strong>THE END!</strong> </font></h2>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 工程化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux设备驱动之Ioctl控制</title>
      <link href="/2019/09/14/%E3%80%90Linux%E7%B3%BB%E5%88%97%E3%80%91Linux%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E4%B9%8BIoctl%E6%8E%A7%E5%88%B6/"/>
      <url>/2019/09/14/%E3%80%90Linux%E7%B3%BB%E5%88%97%E3%80%91Linux%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E4%B9%8BIoctl%E6%8E%A7%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="1、参考"><a href="#1、参考" class="headerlink" title="1、参考"></a>1、参考</h2><p><a href="https://blog.csdn.net/kai_zone/article/details/80459334" target="_blank" rel="noopener">linux设备驱动框架</a><br><a href="http://blog.chinaunix.net/uid-26104244-id-1885641.html" target="_blank" rel="noopener">ioctl系统调用流程</a><br><a href="https://www.cnblogs.com/geneil/archive/2011/12/04/2275372.html" target="_blank" rel="noopener">Linux设备驱动之Ioctl控制</a><br><a href="https://www.cnblogs.com/reality-soul/p/6124841.html" target="_blank" rel="noopener">使用ioctl“实现”自定义的系统调用</a><br><a href="https://blog.csdn.net/zifehng/article/details/59576539" target="_blank" rel="noopener">ioctl()分析——从用户空间到设备驱动</a></p><h2 id="2、Linux设备驱动模型"><a href="#2、Linux设备驱动模型" class="headerlink" title="2、Linux设备驱动模型"></a>2、Linux设备驱动模型</h2><p>(1) 在Linux文件系统中，每个文件都用一个struct inode结构体来描述，这个结构体记录了这个文件的所有信息，例如文件类型，访问权限等。</p><p>(2) 在linux操作系统中，每个驱动程序在应用层的/dev目录或者其他如/sys目录下都会有一个文件与之对应。</p><p>(3) 在linux操作系统中,   每个驱动程序都有一个设备号。</p><p>(4) 在linux操作系统中，每打开一次文件，Linux操作系统会在VFS层分配一个struct file结构体来描述打开的文件。<br><img src="/img/20190914094637885.png" alt="Linux设备驱动模型"></p><p>通过上图我们可以知道，如果想访问底层设备，就必须打开对应的设备文件。也就是在这个打开的过程中，Linux内核将应用层和对应的驱动程序关联起来。</p><p>(1) 当open函数打开设备文件时，可以根据设备文件对应的struct inode结构体描述的信息，可以知道接下来要操作的设备类型（字符设备还是块设备），还会分配一个struct file结构体。</p><p>(2) 根据struct inode结构体里面记录的设备号，可以找到对应的驱动程序。这里以字符设备为例。在Linux操作系统中每个字符设备都有一个struct cdev结构体。此结构体描述了字符设备所有信息，其中最重要的一项就是字符设备的操作函数接口。</p><p>(3) 找到struct cdev结构体后，linux内核就会将struct cdev结构体所在的内存空间首地址记录在struct inode结构体i_cdev成员中，将struct cdev结构体中的记录的函数操作接口地址记录在struct file结构体的f_ops成员中。</p><p>(4) 任务完成，VFS层会给应用返回一个文件描述符（fd）。这个fd是和struct file结构体对应的。接下来上层应用程序就可以通过fd找到struct file，然后在有struct file找到操作字符设备的函数接口了。</p><h2 id="3、Linux设备驱动之Ioctl控制"><a href="#3、Linux设备驱动之Ioctl控制" class="headerlink" title="3、Linux设备驱动之Ioctl控制"></a>3、Linux设备驱动之Ioctl控制</h2><p>　大部分驱动除了需要具备读写设备的能力之外，还需要具备对硬件控制的能力。</p><h3 id="3-1-用户空间调用ioctl控制设备"><a href="#3-1-用户空间调用ioctl控制设备" class="headerlink" title="3.1 用户空间调用ioctl控制设备"></a>3.1 用户空间调用ioctl控制设备</h3><pre><code class="c">int ioctl(int fd,unsigned long cmd,...);/*fd:文件描述符cmd:控制命令...:可选参数:*argp，具体内容依赖于cmd*/</code></pre><p>ioctl函数是用户态控制设备的接口。</p><p>这里只是将command下发给驱动程序去完成相应的动作或操作。</p><h3 id="3-2-驱动ioctl方法"><a href="#3-2-驱动ioctl方法" class="headerlink" title="3.2 驱动ioctl方法"></a>3.2 驱动ioctl方法</h3><pre><code class="c">int (*ioctl) (struct inode *inode,struct file *filp,unsigned int cmd,unsigned long arg);/*inode与filp两个指针对应于应用程序传递的文件描述符fd，这和传递open方法的参数一样。cmd: 由用户空间直接不经修改的传递给驱动程序arg: 可选。*/</code></pre><h3 id="3-3-用户态调用ioctl实例分析"><a href="#3-3-用户态调用ioctl实例分析" class="headerlink" title="3.3 用户态调用ioctl实例分析"></a>3.3 用户态调用ioctl实例分析</h3><pre><code class="c">#include &lt;sys/ioctl.h&gt;#define IAVENCIOC_MAGIC                &#39;V&#39;#define IAVENC_IOW(nr, size)        _IOW(IAVENCIOC_MAGIC, nr, size)IOC_START_ENCODE        = 0x12, /*!&lt; 0x12 */#define IAV_IOC_START_ENCODE                IAVENC_IOW(IOC_START_ENCODE, u32)#ifndef AM_IOCTL#define AM_IOCTL(_filp, _cmd, _arg)    \        do {                         \            if (ioctl(_filp, _cmd, _arg) &lt; 0) {    \                perror(#_cmd);        \                return -1;            \            }                        \        } while (0)#endifstatic int start_encode(u32 stream_map){    struct iav_queryinfo query_info;    struct iav_stream_info *stream_info;    int i;    for (i = 0; i &lt; MAX_ENCODE_STREAM_NUM; i++) {        if (stream_map &amp; (1 &lt;&lt; i)) {            memset(&amp;query_info, 0, sizeof(query_info));            query_info.qid = IAV_INFO_STREAM;            stream_info = &amp;query_info.arg.stream;            stream_info-&gt;id = i;            AM_IOCTL(fd_iav, IAV_IOC_QUERY_INFO, &amp;query_info);            if (stream_info-&gt;state == IAV_STREAM_STATE_ENCODING) {                stream_map &amp;= ~(1 &lt;&lt; i);            }        }    }    if (stream_map == 0) {        printf(&quot;already in encoding, nothing to do \n&quot;);        return 0;    }    AM_IOCTL(fd_iav, IAV_IOC_START_ENCODE, stream_map);    printf(&quot;Start encoding for stream 0x%x successfully\n&quot;, stream_map);    return 0;}</code></pre><hr><h2 id="THE-END"><a href="#THE-END" class="headerlink" title=" THE END! "></a><font color="red"> <strong>THE END!</strong> </font></h2>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 工程化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ARM架构中断异常处理机制</title>
      <link href="/2019/09/13/%E3%80%90ARM%E7%B3%BB%E5%88%97%E3%80%91ARM%E6%9E%B6%E6%9E%84%E4%B8%AD%E6%96%AD%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6/"/>
      <url>/2019/09/13/%E3%80%90ARM%E7%B3%BB%E5%88%97%E3%80%91ARM%E6%9E%B6%E6%9E%84%E4%B8%AD%E6%96%AD%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="1、参考"><a href="#1、参考" class="headerlink" title="1、参考"></a>1、参考</h2><p><a href="http://news.eeworld.com.cn/mcu/2018/ic-news121942578.html" target="_blank" rel="noopener">ARM中断处理过程</a><br><a href="https://www.cnblogs.com/alantu2018/p/8447474.html" target="_blank" rel="noopener">Linux中断 - ARM中断处理过程</a><br><a href="https://blog.csdn.net/caihaitao2000/article/details/84843270" target="_blank" rel="noopener">ARM架构异常中断处理流程</a></p><h2 id="2、-ARM架构异常中断介绍"><a href="#2、-ARM架构异常中断介绍" class="headerlink" title="2、 ARM架构异常中断介绍"></a>2、 ARM架构异常中断介绍</h2><h3 id="2-1、ARM异常中断种类"><a href="#2-1、ARM异常中断种类" class="headerlink" title="2.1、ARM异常中断种类"></a>2.1、ARM异常中断种类</h3><p>ARM体系中异常中断如下面的介绍。</p><ul><li><p><font color="red">复位(Reset)：</font>当处理器的复位引脚有效时，系统产生复位异常中断，程序跳转到复位异常中断处理程序处执行。复位异常中断通常用在下面两种情况下：系统加电时，系统复位时，跳转到复位中断向量处执行，称为软复位。</p></li><li><p><font color="red">未定义指令(Undefined)</font>：当ARM处理器或者是系统中的协处理器认为当前指令未定义时，产生未定义的指令异常中断。可以通过该异常中断机制仿真浮点向量运算。</p></li><li><p><font color="red">软中断(software interrupt)</font>：这是一个由用户定义的中断指令。可用于用户模式下的程序调用特权操作指令。在实时操作系统(RTOS)中可以通过该机制实现系统功能调用。</p></li><li><p><font color="red">指令预取中止</font>：如果处理器预取的指令的地址不存在，或者该地址不允许当前指令访问，当该被预取的指令执行时，处理器产生指令预取中止异常中断。</p></li><li><p><font color="red">数据访问中止</font>：如果数据访问指令的目标地址不存在，或者该地址不允许当前指令访问，处理器产生数据访问中止异常中断。</p></li><li><p><font color="red">外部中断请求(IRQ)</font>：当处理器的外部中断请求引脚有效，而且CPSR寄存器中的I控制位被清除时，处理器产生外部中断请求异常中断。系统中各个外设通常通过该异常中断请求处理器服务。</p></li><li><p><font color="red">快速中断请求(FIQ)</font>：当处理器的外部快速中断请求引脚有效，而且CPSR寄存器中的F控制位被清除时，处理器产生外部中断请求(FIQ)异常中断。</p></li></ul><h3 id="2-2、-异常中断向量表及异常中断优先级"><a href="#2-2、-异常中断向量表及异常中断优先级" class="headerlink" title="2.2、 异常中断向量表及异常中断优先级"></a>2.2、 <strong>异常中断向量表及异常中断优先级</strong></h3><p>中断异常向量表中指定了个异常中断及其处理程序的对应关系。它通常存放在存储地址的低端。在ARM体系中，异常中断向量表的大小为32个字节。其中，每个异常中断占据4个字节大小，保留4个字节空间。</p><p>每个异常中断对应的中断向量表中的4个字节的空间中存放了一个跳转指令或者一个向PC寄存器中赋值的数据访问指令。通常这两种指令，程序将跳转到相应的异常中断处理程序处执行。</p><p>当几个异常中断同时发生时，就必须按照一定的次序来处理这些异常中断。在ARM中通过给异常中断赋予一定的优先级来实现这种处理次序。当然有异常中断是不可能同时发生的，如指令预取中止异常和软中断(SWI)异常中断是由同一条指令的执行触发的，它们是不可能同时发生的。处理器执行某个特定的异常中断的过程中，称为处理器处于特定的中断模式。各异常中断的中断向量地址以及中断的处理优先级如下表所示。</p><table><thead><tr><th>中断向量地址</th><th>异常中断类型</th><th>异常中断模式</th><th>优先级</th></tr></thead><tbody><tr><td>0x0</td><td>复位</td><td>特权模式(SVC)</td><td>1</td></tr><tr><td>0x4</td><td>未定义指令</td><td>未定义指令中止模式</td><td>6</td></tr><tr><td>0x8</td><td>软中断(SWI)</td><td>特权模式(SVC)</td><td>6</td></tr><tr><td>0xC</td><td>指令预取中止</td><td>中止模式</td><td>5</td></tr><tr><td>0x10</td><td>数据访问中止</td><td>中止模式</td><td>2</td></tr><tr><td>0x14</td><td>保留</td><td>未使用</td><td>未使用</td></tr><tr><td>0x18</td><td>外部中断请求</td><td>外部中断模式</td><td>4</td></tr><tr><td>0x1C</td><td>快速中断请求</td><td>快速中断模式</td><td>3</td></tr></tbody></table><h3 id="2-3、异常中断使用的寄存器"><a href="#2-3、异常中断使用的寄存器" class="headerlink" title="2.3、异常中断使用的寄存器"></a>2.3、异常中断使用的寄存器</h3><p>各异常中断对应着一定的处理器模式。应用程序通常运行在用户模式下。ARM中的处理器模式如下表所示。</p><table><thead><tr><th>处理器模式</th><th>描述</th></tr></thead><tbody><tr><td>用户模式(user)</td><td>正常程序执行的模式（用户态一般处于这种模式）</td></tr><tr><td>快速中断模式(FIQ)</td><td>用于高速数据传输和通道处理</td></tr><tr><td>外部中断模式(IRQ)</td><td>用于通常的中断处理</td></tr><tr><td>特权模式(SVC)</td><td>供操作系统使用的一种保护模式(一般内核态处于这种模式)</td></tr><tr><td>中止模式(abort)</td><td>用于虚拟存储及存储保护</td></tr><tr><td>未定义指令模式(undefined)</td><td>用于支持软件仿真硬件的协处理器</td></tr><tr><td>系统模式(system)</td><td>用于运行特权级的操作系统任务</td></tr></tbody></table><h2 id="3、ARM中断处理机制"><a href="#3、ARM中断处理机制" class="headerlink" title="3、ARM中断处理机制"></a>3、ARM中断处理机制</h2><p>ARM有七种异常中断类型，优先级、工作模式（有七种工作模式）、地址、功能都不一样。如其中软件中断SWI优先级为6，工作模式管理模式，异常向量地址为0x00000008，功能是用户定义的中断指令，可用于用户模式下的程序调用特权操作。</p><p>当中断产生后，除了复位中断立即中止当前指令外，其余情况都是处理器完成当前指令后，才去执行异常处理程序。</p><p>ARM处理器有多种processor mode，例如user mode（用户空间的AP所处于的模式）、supervisor mode（即SVC mode，大部分的内核态代码都处于这种mode）、IRQ mode（发生中断后，处理器会切入到该mode）等。对于linux kernel，其中断处理处理过程中，ARM 处理器大部分都是处于SVC mode。但是，实际上产生中断的时候，ARM处理器实际上是进入IRQ mode，因此在进入真正的IRQ异常处理之前会有一小段IRQ mode的操作，之后会进入SVC mode进行真正的IRQ异常处理。</p><h3 id="3-1-中断处理过程"><a href="#3-1-中断处理过程" class="headerlink" title="3.1 中断处理过程"></a>3.1 中断处理过程</h3><p>当一个IRQ产生时，会发生什么？</p><p>当一个IRQ产生后，CPU会首先自动跳转到IRQ的中断向量(这个中断向量是可设置的)，在这个IRQ中断向量里又是一个跳转指令，CPU再次跳转，跳转后的代码主要完成的工作是保存一些寄存器，然后读取中断寄存器经过计算(这个计算并不是单纯的跟INTPND对应)得到中断号，然后跳转到一个中断处理的通用函数，并把中断号传过去(汇编向C传参数)。</p><p>在这个通用处理函数里，根据中断号找到我们自己设定的中断处理函数，然后执行。</p><p>（1）将CPSR的值保存到将要执行的异常中断对应的各自SPSR中，以实现对处理器当前状态、中断屏蔽及各标志位的保护。</p><p>（2）设置当前状态寄存器CPSR的相应位。设置CPSR中的M4~M0的5位，进入相应工作模式，设置I=1禁止IRQ中断，如果进入复位模式或FIQ模式，还要设置F=1以禁止FIQ中断。</p><p>（3）将引起异常指令的下一条地址（断点地址）保存到新异常工作模式的LR（R14）中，使异常处理程序执行完后正确返回原来程序处继续向下执行。</p><p>（4）给程序计数器PC强制赋值，转入向量地址，以便执行相应的处理程序。</p><p>每种中断异常模式对应两个寄存器SP和LR。</p><p>更详细的讲，linux的中断机制可以分为两部分：</p><ol><li>定义的中断处理函数是如何注册到linux系统的？</li><li>当中断发生时，linux如何自动跳转并找出中断号，然后根据中断号来找到注册在该中断号上的中断处理函数并执行？</li></ol><h3 id="3-2-中断返回过程"><a href="#3-2-中断返回过程" class="headerlink" title="3.2 中断返回过程"></a>3.2 中断返回过程</h3><p>从中断返回。如果是复位异常，系统自动从0x00000000开始重新执行程序，无需返回。</p><p>（1）首先恢复原来被保护的用户寄存器。</p><p>（2）将SPSR寄存器复制到CPSR中，使得原来CPSR状态从相应的SOSR中恢复，一恢复被中断的程序状态。</p><p>（3）根据异常类型将PC值恢复成断点地址，以继续执行用户原来运行着的程序。</p><p>（4）清除CPSR中的中断禁止标志I和F，开放外部中断和快速中断。</p><p>注意：（1）程序状态寄存器及断点地址的恢复必须同时进行。</p><p>（2）由于异常随机发生，所以要对异常向量进行初始化，即在异常向量的地址处放置一条跳转指令，跳转到异常处理程序。</p><hr><h3 id="THE-END"><a href="#THE-END" class="headerlink" title=" THE END! "></a><font color="red"> <strong>THE END!</strong> </font></h3>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 优化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ARM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>命令行参数解析的两种方法</title>
      <link href="/2019/09/07/%E3%80%90PE%E7%B3%BB%E5%88%97%E3%80%91%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%8F%82%E6%95%B0%E8%A7%A3%E6%9E%90%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%96%B9%E6%B3%95/"/>
      <url>/2019/09/07/%E3%80%90PE%E7%B3%BB%E5%88%97%E3%80%91%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%8F%82%E6%95%B0%E8%A7%A3%E6%9E%90%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>&ensp; &ensp;  在实际工程使用中，命令行参数解析主要用于灵活的使用demo或库中不同功能特性，是一个非常重要的功能。本文主要讲述两种命令行参数解析的方法，重要讲述Linux平台采用getopt函数的方法进行命令行参数解析。在Linux系统中，Linux命令用法的参数解析一般采用getopt()或getopt_long()的方法进行，这种方法可以任意指定参数，不需要按顺序指定，更加灵活。</p><h2 id="1、参考"><a href="#1、参考" class="headerlink" title="1、参考"></a>1、参考</h2><p><a href="https://www.gnu.org/software/libc/manual/html_node/Getopt.html" target="_blank" rel="noopener">Parsing program options using getopt</a><br><a href="https://blog.csdn.net/coding__madman/article/details/51043733" target="_blank" rel="noopener">getopt函数和getopt_long函数详解</a><br><a href="https://blog.csdn.net/qq_33850438/article/details/80172275" target="_blank" rel="noopener">浅谈linux的命令行解析参数之getopt_long函数</a></p><h2 id="2、命令行参数解析的两种方法"><a href="#2、命令行参数解析的两种方法" class="headerlink" title="2、命令行参数解析的两种方法"></a>2、命令行参数解析的两种方法</h2><h3 id="2-1-普通的命令行参数解析方法"><a href="#2-1-普通的命令行参数解析方法" class="headerlink" title="2.1 普通的命令行参数解析方法"></a>2.1 普通的命令行参数解析方法</h3><p>具体参见：<br><a href="https://blog.csdn.net/SoaringLee_fighting/article/details/90180846" target="_blank" rel="noopener">【PE/C系列】C工程中灵活的参数解析方式</a></p><p>主要是通过字符串函数strcmp和strncmp进行参数的解析。</p><pre><code>if(argc &gt; 1){   int i = 0;   for(i = 1; i &lt; argc; ++i)   {      if(!strncmp(argv[i], &quot;-h&quot;, 2) || !strncmp(argv[i], &quot;-help&quot;, 5))      {          print_help(argv[0]);      }      else if(!strncmp(argv[i], &quot;-s&quot;, 2))      {          width = atoi(argv[++i]);          height = atoi(argv[++i]);      }      else if(!strcmp(argv[i], &quot;-ss&quot;, 3))      {          length = atoi(argv[++i]);      }   }}</code></pre><h3 id="2-2-通过getopt函数进行命令行参数解析（仅限Linux平台）"><a href="#2-2-通过getopt函数进行命令行参数解析（仅限Linux平台）" class="headerlink" title="2.2 通过getopt函数进行命令行参数解析（仅限Linux平台）"></a>2.2 通过getopt函数进行命令行参数解析（仅限Linux平台）</h3><h4 id="2-2-1-getopt和getopt-long函数用法"><a href="#2-2-1-getopt和getopt-long函数用法" class="headerlink" title="2.2.1 getopt和getopt_long函数用法"></a>2.2.1 getopt和getopt_long函数用法</h4><p><font color="red"><strong>函数声明：</strong></font></p><pre><code>#include&lt;unistd.h&gt;#include&lt;getopt.h&gt;          /*所在头文件 *//*函数声明*/int getopt(intargc, char * const argv[], const char *optstring);int getopt_long(int argc, char * const argv[], const char *optstring,                          const struct option *longopts, int*longindex);int getopt_long_only(int argc, char * const argv[],const char *optstring,                          const struct option *longopts, int*longindex); /*系统声明的全局变量 */extern char *optarg;        extern int optind, opterr, optopt;</code></pre><p><font color="red"><strong>全局变量的作用：</strong></font></p><ul><li>Variable: int <strong>opterr</strong><br>参数opterr不等于0，在参数解析时遇到未知选项或者缺少必要参数时，会打印错误信息给标准错误流。<br>参数opterrr等于0，不会打印任何信息，但是仍然返回？表示错误信息。<br>If the value of this variable is nonzero, then getopt prints an error message to the standard error stream if it encounters an unknown option character or an option with a missing required argument. This is the default behavior. If you set this variable to zero, getopt does not print any messages, but it still returns the character ? to indicate an error.</li></ul><ul><li><p>Variable: int <strong>optopt</strong> 表示最后一个未知选项。<br>When getopt encounters an unknown option character or an option with a missing required argument, it stores that option character in this variable. You can use this for providing your own diagnostic messages.</p></li><li><p>Variable: int <strong>optind</strong> 表示argv数组中下一个元素的索引。<br>This variable is set by getopt to the index of the next element of the argv array to be processed. Once getopt has found all of the option arguments, you can use this variable to determine where the remaining non-option arguments begin. The initial value of this variable is 1.</p></li><li><p>Variable: char * <strong>optarg</strong> 表示指向当前选项参数的指针。<br>This variable is set by getopt to point at the value of the option argument, for those options that accept arguments.</p></li></ul><p><font color="red"><strong>getopt函数用法：只支持短选项 -a</strong></font></p><p>具体参考：<a href="https://www.gnu.org/software/libc/manual/html_node/Using-Getopt.html#Using-Getopt" target="_blank" rel="noopener">Using-Getopt</a></p><pre><code>#include&lt;unistd.h&gt;int getopt(int argc, char * const argv[], const char *optstring);</code></pre><p>getopt函数用于从argc和argv[]指定的参数列表中获取下一个选项参数。</p><p>参数<strong>optstring</strong>: 比如getopt(argc, argv, “td:ch:q::”)</p><ol><li>单个字符，表示选项，这里一共有t、d、c、h、q五个选项；</li><li>单个字符后接一个冒号“：”表示该选项后必须跟一个参数，参数紧跟在选项后或者以空格隔开；</li><li>单个字符后跟两个冒号，表示该选项后可以跟一个参数，也可以不跟，如果后边跟一个参数，参数必须紧跟在选项后不能以空格隔开。</li></ol><p><strong>返回值：</strong><br>The getopt function returns the option character for the next command line option. When no more option arguments are available, it returns -1.</p><p><font color="red"><strong>getopt_long函数用法：支持短选项和长选项--all</strong></font></p><p>具体参考：<a href="https://www.gnu.org/software/libc/manual/html_node/Getopt-Long-Options.html#Getopt-Long-Options" target="_blank" rel="noopener">Getopt-Long-Options</a></p><pre><code>#include&lt;getopt.h&gt;          /*所在头文件 */int getopt_long(int argc, char * const argv[], const char *optstring,                          const struct option *longopts, int*longindex);</code></pre><ul><li>参数optstring表示短选项参数；</li><li>参数longopts表示长选项参数；</li><li>参数longindex表示选项索引（即longopts的下标值）。</li></ul><p>举个栗子：</p><pre><code>struct option{       const char *name;     //表示选项的名称     int         has_arg;  //表示选项后面是否携带参数。该参数有三个不同值：     //no_argument(或者是0)；required_argument(或者是1)；optional_argument(或者是2)     int        *flag;   // 空或者非空。      //a:如果参数为空NULL，那么当选中某个长选项的时候，getopt_long将返回val值。      // b:如果参数不为空，那么当选中某个长选项的时候，getopt_long将返回0，并且将flag指针参数指向val值。     int         val;   //表示指定函数找到该选项时的返回值，或者当flag非空时指定flag指向的数据的值val};  eg: static struct option longOpts[] = {      { &quot;daemon&quot;, no_argument, NULL, &#39;D&#39; },      { &quot;dir&quot;, required_argument, NULL, &#39;d&#39; },      { &quot;out&quot;, required_argument, NULL, &#39;o&#39; },      { &quot;log&quot;, required_argument, NULL, &#39;l&#39; },      { &quot;split&quot;, required_argument, NULL, &#39;s&#39; },      { &quot;http-proxy&quot;, required_argument, &amp;lopt, 1 },      { &quot;http-user&quot;, required_argument, &amp;lopt, 2 },      { &quot;http-passwd&quot;, required_argument, &amp;lopt, 3 },      { &quot;http-proxy-user&quot;, required_argument, &amp;lopt, 4 },      { &quot;http-proxy-passwd&quot;, required_argument, &amp;lopt, 5 },      { &quot;http-auth-scheme&quot;, required_argument, &amp;lopt, 6 },      { &quot;version&quot;, no_argument, NULL, &#39;v&#39; },      { &quot;help&quot;, no_argument, NULL, &#39;h&#39; },      { 0, 0, 0, 0 }    };</code></pre><p><font color="red"><strong>getopt_long_only函数用法：只支持长选项--all</strong></font></p><pre><code>#include&lt;getopt.h&gt;          /*所在头文件 */int getopt_long_only(int argc, char * const argv[],const char *optstring,                          const struct option *longopts, int*longindex);</code></pre><h4 id="2-2-2-实例用法Demo"><a href="#2-2-2-实例用法Demo" class="headerlink" title="2.2.2 实例用法Demo"></a>2.2.2 实例用法Demo</h4><p>参考：<br><a href="https://www.gnu.org/software/libc/manual/html_node/Example-of-Getopt.html#Example-of-Getopt" target="_blank" rel="noopener">Example-of-Getopt</a><br><a href="https://www.gnu.org/software/libc/manual/html_node/Getopt-Long-Option-Example.html#Getopt-Long-Option-Example" target="_blank" rel="noopener">Getopt-Long-Option-Example</a></p><p><strong>1、GNUC Linux提供的Demo:</strong></p><pre><code>#include &lt;ctype.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;int main (int argc, char **argv){  int aflag = 0;  int bflag = 0;  char *cvalue = NULL;  int index;  int c;  opterr = 0;  while ((c = getopt (argc, argv, &quot;abc:&quot;)) != -1)    switch (c)      {      case &#39;a&#39;:        aflag = 1;        break;      case &#39;b&#39;:        bflag = 1;        break;      case &#39;c&#39;:        cvalue = optarg;        break;      case &#39;?&#39;:        if (optopt == &#39;c&#39;)          fprintf (stderr, &quot;Option -%c requires an argument.\n&quot;, optopt);        else if (isprint (optopt))          fprintf (stderr, &quot;Unknown option `-%c&#39;.\n&quot;, optopt);        else          fprintf (stderr,                   &quot;Unknown option character `\\x%x&#39;.\n&quot;,                   optopt);        return 1;      default:        abort ();      }  printf (&quot;aflag = %d, bflag = %d, cvalue = %s\n&quot;,          aflag, bflag, cvalue);  for (index = optind; index &lt; argc; index++)    printf (&quot;Non-option argument %s\n&quot;, argv[index]);  return 0;}</code></pre><p><strong>2、实例Demo:</strong></p><pre><code>static const char *short_options = &quot;ABCDEb:c:d:f:I:i:L:M:m:n:r:s:T:t:vy:&quot;;/*! * @brief `-A --streamA` : Specify the following options are for stream A */#define STREAM_A_OPTION \    {&quot;streamA&quot;,    NO_ARG,        0,    &#39;A&#39;},/*! * @brief `-B --streamB` : Specify the following options are for stream B */#define STREAM_B_OPTION \    {&quot;streamB&quot;,    NO_ARG,     0,    &#39;B&#39;},/*! * @brief `-C --streamC` : Specify the following options are for stream C */#define STREAM_C_OPTION \    {&quot;streamC&quot;,    NO_ARG,        0,    &#39;C&#39;},/*! * @brief `-D --streamD` : Specify the following options are for stream D */#define STREAM_D_OPTION \    {&quot;streamD&quot;,    NO_ARG,        0,    &#39;D&#39;},/*! * @brief `-E --streamE` : Specify the following options are for stream E */#define STREAM_E_OPTION \    {&quot;streamE&quot;,    NO_ARG,        0,    &#39;E&#39;},/*! * @brief `-t --type` : Specify the supported EFM type, 0: YUV File, 1: YUV Capture, 2: YUV RAW, 3: RGB RAW */#define TYPE_OPTION \    {&quot;type&quot;,    HAS_ARG,    0,    &#39;t&#39;},/*! * @brief `-b --buffer` : Specify the source buffer for YUV Capture */#define BUFFER_OPTION \    {&quot;buffer&quot;,    HAS_ARG,    0,    &#39;b&#39;},/*! * @brief `-f --yuv-format` : Specify YUV format of the YUV input file for YUV File */#define YUV_FORMAT_OPTION \    {&quot;yuv-format&quot;,    HAS_ARG,    0,    &#39;f&#39;},/*! * @brief `-y --yuv-input` : Specify YUV input file path for YUV File, if multi input files, please * input prefix, like xxx_0.yuv, xxx_1.yuv, please input xxx */#define YUV_INPUT_OPTION \    {&quot;yuv-input&quot;,    HAS_ARG,    0,    &#39;y&#39;},/*! * @brief `-i --raw-input` : pecify raw input (RGB or YUV) file path, if multi input files, please * input prefix, like xxx_0.raw, xxx_1.raw, please input xxx */#define RAW_INPUT_OPTION \    {&quot;raw-input&quot;,    HAS_ARG,    0,    &#39;i&#39;},/*! * @brief `-m --me1-input` : Specify ME1 input file path for YUV File, if multi input files, please * input prefix, like xxx_0.me1, xxx_1.me1, please input xxx */#define ME1_INPUT_OPTION \    {&quot;me1-input&quot;,    HAS_ARG,    0,    &#39;m&#39;},/*! * @brief `-M --me0-input` : Specify ME0 input file path for YUV File, if multi input files, please * input prefix, like xxx_0.me0, xxx_1.me0, please input xxx */#define ME0_INPUT_OPTION \    {&quot;me0-input&quot;,    HAS_ARG,    0,    &#39;M&#39;},/*! * @brief `-n --frame-num` [&gt;0]: Specify frame number to be encoded */#define FRAME_NUM_OPTION \    {&quot;frame-num&quot;,    HAS_ARG,    0,    &#39;n&#39;},/*! * @brief `-s --frame-size` [resulotion]: Specify the frame resolution for YUV/RAW file */#define FRAME_SIZE_OPTION \    {&quot;frame-size&quot;,    HAS_ARG,    0,    &#39;s&#39;},/*! * @brief `-r --frame-rate` : Specify the frame rate of YUV input file for YUV File */#define FRAME_RATE_OPTION \    {&quot;frame-rate&quot;,    HAS_ARG,    0,    &#39;r&#39;},/*! * @brief `-I --file-index` [m~n]: Specify the input file index */#define FILE_INDEX_OPTION \    {&quot;file-index&quot;,    HAS_ARG,    0,    &#39;I&#39;},/*! * @brief `-L --loop-num` [&gt;0]: Specify the loop num */#define LOOP_NUM_OPTION \    {&quot;loop-num&quot;,    HAS_ARG,    0,    &#39;L&#39;},/*! * @brief `-c --copy-method` [0|1]: Specify the copy method for YUV Capture, 0: GDMA, 1: ARM */#define COPY_METHOD_OPTION \    {&quot;copy-method&quot;,    HAS_ARG,    0,    &#39;c&#39;},/*! * @brief `-T --feed-type` [0|1]: Specify the YUV feed type for YUV File, 0: Normal, 1: Repeate */#define FEED_TYPE_OPTION \    {&quot;feed-type&quot;,    HAS_ARG,    0,    &#39;T&#39;},/*! * @brief `-d --me-method` [0|1]: Specify the method of me downscale, 0: Normal, 1: Neon, default 0 */#define ME_METHOD_OPTION \    {&quot;me-method&quot;,    HAS_ARG,    0,    &#39;d&#39;},/*! * @brief `-v --verbose` : Print more information */#define VERBOSE_OPTION \    {&quot;verbose&quot;,    NO_ARG,    0,    &#39;v&#39;},/*! @} */static struct option long_options[] = {    STREAM_A_OPTION    STREAM_B_OPTION    STREAM_C_OPTION    STREAM_D_OPTION    STREAM_E_OPTION    TYPE_OPTION    BUFFER_OPTION    YUV_FORMAT_OPTION    YUV_INPUT_OPTION    RAW_INPUT_OPTION    ME1_INPUT_OPTION    ME0_INPUT_OPTION    FRAME_NUM_OPTION    FRAME_SIZE_OPTION    FRAME_RATE_OPTION    FILE_INDEX_OPTION    LOOP_NUM_OPTION    COPY_METHOD_OPTION    FEED_TYPE_OPTION    ME_METHOD_OPTION    VERBOSE_OPTION    {0,    0,    0,    0},};int init_param(int argc, char **argv){    int ch, value;    int width, height;    int option_index = 0;    u32 min_value, max_value;    opterr = 0;    while ((ch = getopt_long(argc, argv, short_options, long_options,        &amp;option_index)) != -1) {        switch (ch) {        case &#39;A&#39;:            current_stream = 0;            break;        case &#39;B&#39;:            current_stream = 1;            break;        case &#39;C&#39;:            current_stream = 2;            break;        case &#39;D&#39;:            current_stream = 3;            break;        case &#39;E&#39;:            current_stream = 4;            break;        case &#39;f&#39;:            value = atoi(optarg);            yuv_format = value;            break;        case &#39;y&#39;:            strcpy(yuv_name, optarg);            break;        case &#39;i&#39;:            strcpy(raw_name, optarg);            break;        case &#39;m&#39;:            strcpy(me1_name, optarg);            break;        case &#39;M&#39;:            strcpy(me0_name, optarg);            break;        case &#39;n&#39;:            value = atoi(optarg);            frame_num = value;            break;        case &#39;s&#39;:            get_arbitrary_resolution(optarg, &amp;width, &amp;height);            frame_size.width = width;            frame_size.height = height;            break;        case &#39;r&#39;:            frame_rate = atoi(optarg);            break;        case &#39;c&#39;:            mem_cpy_type = atoi(optarg);            break;        case &#39;v&#39;:            verbose = 1;            break;        default:            printf(&quot;unknown option found: %c\n&quot;, ch);            return -1;        }    }    return 0;}</code></pre><hr><h2 id="THE-END"><a href="#THE-END" class="headerlink" title="THE  END!"></a><font color="red"><strong>THE  END!</strong></font></h2>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 工程化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>颜色空间转换CSConvert：YUV422P转YUV422SP(NV16)</title>
      <link href="/2019/09/01/%E3%80%90Codecs%E7%B3%BB%E5%88%97%E3%80%91%E9%A2%9C%E8%89%B2%E7%A9%BA%E9%97%B4%E8%BD%AC%E6%8D%A2CSConvert%EF%BC%9AYUV422P%E8%BD%ACYUV422SP(NV16)/"/>
      <url>/2019/09/01/%E3%80%90Codecs%E7%B3%BB%E5%88%97%E3%80%91%E9%A2%9C%E8%89%B2%E7%A9%BA%E9%97%B4%E8%BD%AC%E6%8D%A2CSConvert%EF%BC%9AYUV422P%E8%BD%ACYUV422SP(NV16)/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="1、参考"><a href="#1、参考" class="headerlink" title="1、参考"></a>1、参考</h2><p><a href="https://blog.csdn.net/subfate/article/details/47305315" target="_blank" rel="noopener">YUV格式学习：NV16和YUV422P格式互换</a><br><a href="https://blog.csdn.net/subfate/article/details/47304945" target="_blank" rel="noopener">YUV格式学习：YUV422P、YV16、NV16、NV61格式转换成RGB24</a><br><a href="http://www.fourcc.org/yuv.php" target="_blank" rel="noopener">yuv格式介绍</a><br><a href="https://wiki.videolan.org/YUV/#Other_NV_formats" target="_blank" rel="noopener">yuv格式介绍</a></p><h2 id="2、YUV422SP的两种格式"><a href="#2、YUV422SP的两种格式" class="headerlink" title="2、YUV422SP的两种格式"></a>2、YUV422SP的两种格式</h2><p>V4L2_PIX_FMT_NV16 (‘NV16’)<br>V4L2_PIX_FMT_NV61 (‘NV61’)</p><p>均为YUV422SP格式。对于NV16来说，紧跟Y平面的是UV交替的平面，而对于NV61来说，紧跟的是VU交替的平面。</p><h2 id="3、YUV422P转换成YUV422SP-NV16"><a href="#3、YUV422P转换成YUV422SP-NV16" class="headerlink" title="3、YUV422P转换成YUV422SP(NV16)"></a>3、YUV422P转换成YUV422SP(NV16)</h2><pre><code>#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;/**yyyy yyyyuv    uv-&gt;yyyy yyyyuuvv*/void yuv422sp_to_yuv422p(unsigned char* yuv422sp, unsigned char* yuv422p, int width, int height){    int i, j;    int y_size;    int uv_size;    unsigned char* p_y1;    unsigned char* p_uv;    unsigned char* p_y2;    unsigned char* p_u;    unsigned char* p_v;    y_size = uv_size = width * height;    p_y1 = yuv422sp;    p_uv = yuv422sp + y_size;    p_y2 = yuv422p;    p_u  = yuv422p + y_size;    p_v  = p_u + width * height / 2;    memcpy(p_y2, p_y1, y_size);    for (j = 0, i = 0; j &lt; uv_size; j+=2, i++)    {        p_u[i] = p_uv[j];        p_v[i] = p_uv[j+1];    }}/**yyyy yyyyuuvv-&gt;yyyy yyyyuv    uv*/void yuv422p_to_yuv422sp(unsigned char* yuv422p, unsigned char* yuv422sp, int width, int height){    int i, j;    int y_size;    int uv_size;    unsigned char* p_y1;    unsigned char* p_uv;    unsigned char* p_y2;    unsigned char* p_u;    unsigned char* p_v;    y_size = uv_size = width * height;    p_y1 = yuv422p;    p_y2 = yuv422sp;    p_u  = p_y1 + y_size;    p_v  = p_u + width * height / 2;    p_uv = p_y2 + y_size;    memcpy(p_y2, p_y1, y_size);    for (j = 0, i = 0; j &lt; uv_size; j+=2, i++)    {        // 此处可调整U、V的位置，变成NV16或NV61#if 01        p_uv[j] = p_u[i];        p_uv[j+1] = p_v[i];#else        p_uv[j] = p_v[i];        p_uv[j+1] = p_u[i];#endif    }}int main(int argc, char** argv){    int width, height;    int frame_size;    FILE *fin, *fou;    unsigned char *y, *nv16;    int i, frame_num = 0;    char outname[512]=&quot;out_NV16.yuv&quot;;    printf(&quot;\nUsage: YUV422PtoNV16.exe input.yuv width height\n\n&quot;);    if (argc != 4)    {        return -1;    }    fin = fopen(argv[1], &quot;rb&quot;);    if (fin == NULL)    {        printf(&quot;error:open %s fail\n&quot;, argv[1]);        return -1;    }    width = atoi(argv[2]);    height = atoi(argv[3]);    frame_size = width * height * 2;//++YUV422P    y = (unsigned char *)malloc(frame_size);    if (y == NULL)    {        printf(&quot;malloc y fail\n&quot;);        return -1;    }    nv16 = (unsigned char *)malloc(width*height*2);    if (nv16 == NULL)    {        printf(&quot;malloc nv16 fail\n&quot;);        return -1;    }    //memset(outname, 0, sizeof(outname));    //sprintf_s(outname, &quot;%s_NV16.yuv&quot;, argv[1]);    fou = fopen(outname, &quot;wb&quot;);    if (fou == NULL)    {        printf(&quot;error: open %s fail\n&quot;, outname);        return -1;    }    while (!feof(fin))    {        int n = 0;        n = fread(y, 1, width*height*2, fin);        yuv422p_to_yuv422sp(y, nv16, width, height);        fwrite(nv16, 1, height*width*2, fou);        printf(&quot;%dth frame ok!!\n&quot;, frame_num);        frame_num++;    }    printf(&quot;YUV422P to NV16 successfully!!, total frames: %d\n&quot;,frame_num);    free(y);    y = NULL;    free(nv16);    nv16 = NULL;    fclose(fin);    fclose(fou);    return 0;}</code></pre><h2 id="4、效果图"><a href="#4、效果图" class="headerlink" title="4、效果图"></a>4、效果图</h2><p>由于暂时YUVPlayer不支持NV16格式的显示，故效果图暂不展示。</p><hr><h2 id="THE-END"><a href="#THE-END" class="headerlink" title=" THE END! "></a><font color="red"> <strong>THE END!</strong> </font></h2>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 视频处理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Video </tag>
            
            <tag> CSConvert </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>多线程中如何进行参数传递？</title>
      <link href="/2019/08/25/%E3%80%90Tools%E7%B3%BB%E5%88%97%E3%80%91%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%AD%E5%A6%82%E4%BD%95%E8%BF%9B%E8%A1%8C%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92%EF%BC%9F/"/>
      <url>/2019/08/25/%E3%80%90Tools%E7%B3%BB%E5%88%97%E3%80%91%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%AD%E5%A6%82%E4%BD%95%E8%BF%9B%E8%A1%8C%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92%EF%BC%9F/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="1、参考"><a href="#1、参考" class="headerlink" title="1、参考"></a>1、参考</h2><p><a href="https://www.cnblogs.com/ngnetboy/p/3391368.html" target="_blank" rel="noopener">【C】——如何用线程进行参数的传递</a><br><a href="https://www.cnblogs.com/xiaoshiwang/p/9867091.html" target="_blank" rel="noopener">c/c++ 多线程 参数传递</a><br><a href="https://www.cnblogs.com/warioland/archive/2011/11/01/2231070.html" target="_blank" rel="noopener">向线程传递参数的两种基本方法</a></p><h2 id="2、多线程中参数传递方法"><a href="#2、多线程中参数传递方法" class="headerlink" title="2、多线程中参数传递方法"></a>2、多线程中参数传递方法</h2><h3 id="2-1-方法说明"><a href="#2-1-方法说明" class="headerlink" title="2.1 方法说明"></a>2.1 方法说明</h3><p>这里讲述的多线程中参数传递是指将主线程中的参数传递到线程中。</p><pre><code>int  pthread_create(pthread_t  *  thread,pthread_attr_t * attr,void * (*start_routine)(void *),void * arg);thread：返回创建的线程的IDattr：线程属性，调度策略、优先级等都在这里设置，如果为NULL则表示用默认属性start_routine：线程入口函数，可以返回一个void*类型的返回值，该返回值可由pthread_join()捕获arg：传给start_routine的参数， 可以为NULL返回值：成功返回0</code></pre><p>最简单的方法就是在创建线程时通过*arg指针参数传递给线程。</p><h3 id="2-2-demo"><a href="#2-2-demo" class="headerlink" title="2.2  demo"></a>2.2  demo</h3><pre><code>#include &lt;pthread.h&gt;#include &lt;stdio.h&gt;#include &lt;windows.h&gt;struct val{    int num1;    int num2;};//send a int to argvoid *text(void *arg){    int *p = (int *)arg;    printf(&quot;[debug] arg is %d\n&quot;,*p);    pthread_exit(NULL);    return 0;}//send char to argvoid *text2(void *arg){    char *d = (char *)arg;    printf(&quot;[debug] arg is %s\n&quot;,arg);    pthread_exit(NULL);    return 0;}//send a struct to argvoid *text3(void *arg){    struct val *v = (struct val *)arg;    printf(&quot;[debug] arg is v.num1:%d, v.num2:%d\n&quot;,v-&gt;num1,v-&gt;num2);    pthread_exit(NULL);    return 0;}int main(){    pthread_t pth;    char val[255] = &quot;This is a string paramter to thread.&quot;;    int arry = 10;    pthread_create(&amp;pth, NULL, text,(void *)&amp;arry);    pthread_join(pth, NULL);    pthread_create(&amp;pth, NULL, text2, (void *)val);    pthread_join(pth, NULL);        struct val v;    v.num1 = 10;    v.num2 = 11;    pthread_create(&amp;pth, NULL, text3, (void *)&amp;v); //一定要用&amp;v因为结构体是值类型；    pthread_join(pth, NULL);    system(&quot;pause&quot;);    return 0;}</code></pre><h3 id="2-3-实验结果"><a href="#2-3-实验结果" class="headerlink" title="2.3 实验结果"></a>2.3 实验结果</h3><p><img src="/img/20190825135150358-.png" alt="实验结果"></p><hr><h2 id="THE-END"><a href="#THE-END" class="headerlink" title="THE END!"></a><font color="red"><strong>THE END!</strong></font></h2>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
          <category> 多线程编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Tools </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OpenCV中在同一窗口显示多幅图片</title>
      <link href="/2019/08/11/%E3%80%90CV%E7%B3%BB%E5%88%97%E3%80%91%E5%9C%A8%E5%90%8C%E4%B8%80%E7%AA%97%E5%8F%A3%E6%98%BE%E7%A4%BA%E5%A4%9A%E5%B9%85%E5%9B%BE%E7%89%87/"/>
      <url>/2019/08/11/%E3%80%90CV%E7%B3%BB%E5%88%97%E3%80%91%E5%9C%A8%E5%90%8C%E4%B8%80%E7%AA%97%E5%8F%A3%E6%98%BE%E7%A4%BA%E5%A4%9A%E5%B9%85%E5%9B%BE%E7%89%87/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="1、参考"><a href="#1、参考" class="headerlink" title="1、参考"></a>1、参考</h2><p><a href="https://blog.csdn.net/yang_xian521/article/details/7915396" target="_blank" rel="noopener">OpenCV学习笔记（五十七）——在同一窗口显示多幅图片</a><br><a href="https://blog.csdn.net/Grhdu/article/details/74109493" target="_blank" rel="noopener">opencv—提取图像RGB各个通道分量</a><br><a href="https://www.cnblogs.com/muyuge/p/6152366.html" target="_blank" rel="noopener">OpenCV——RGB三通道分离</a></p><h2 id="2、OpenCV中在同一窗口中显示多幅图片"><a href="#2、OpenCV中在同一窗口中显示多幅图片" class="headerlink" title="2、OpenCV中在同一窗口中显示多幅图片"></a>2、OpenCV中在同一窗口中显示多幅图片</h2><pre><code class="c">/******************************************************************/*    2010-2019 Copyright reversed/*    File:        demo.cpp/*    Function: this file used to imshow multiple picture in one window/*    Author:    SoaringLee/*    Modified: 2019.8.11 Created/********************************************************************/#include &lt;opencv2/core/core.hpp&gt;#include &lt;opencv2/highgui/highgui.hpp&gt;#include &lt;opencv2/imgproc/imgproc.hpp&gt;#include &lt;stdio.h&gt;using namespace cv;/******************************************************************/*    2010-2019 Copyright reversed/*    Declaration:    void imshowMulti(const std::string&amp; _winName, const std::vector&lt;Mat&gt;&amp; _imgs)/*    Function:        imshow multiple picture in one window using ROI/*    Parameters:/*         @Input:/*            _winName: 显示窗口的名字字符串/*            _img:        要显示的图片的集合/*         @Output:/*            return ：void/*    Author:    SoaringLee/*    Modified:    2019.8.11 Created/********************************************************************/void imshowMulti(const std::string&amp; _winName, const std::vector&lt;Mat&gt;&amp; _imgs){    int nImg = (int)_imgs.size();    Mat dispImg;    int size;    int x, y;    // w - Maximum number of images in a row    // h - Maximum number of images in a column    int w, h;    // scale - How much we have to resize the image    float scale;    int max;    if (nImg &lt;= 0)    {        printf(&quot;Number of arguments too small....\n&quot;);        return;    }    else if (nImg &gt; 12)    {        printf(&quot;Number of arguments too large....\n&quot;);        return;    }    switch(nImg)    {    case 1:        w = h = 1;        size = 300;        break;    case 2:        w = 2; h = 1;        size = 300;        break;    case 3:    case 4:        w = 2; h = 2;        size = 300;        break;        break;    case 5:    case 6:        w = 3; h = 2;        size = 200;        break;    case 7:    case 8:        w = 4; h = 2;        size = 200;        break;    default:        w = 4; h = 3;        size = 150;        break;    }    dispImg.create(Size(100 + size*w, 60 + size*h), CV_8UC3);    for (int i= 0, m=20, n=20; i&lt;nImg; i++, m+=(20+size))    {        x = _imgs[i].cols;        y = _imgs[i].rows;        max = (x &gt; y)? x: y;        scale = (float) ( (float) max / size );        if (i%w==0 &amp;&amp; m!=20)        {            m = 20;            n += 20+size;        }        Mat imgROI = dispImg(Rect(m, n, (int)(x/scale), (int)(y/scale)));        resize(_imgs[i], imgROI, Size((int)(x/scale), (int)(y/scale)));    }    namedWindow(_winName);    imshow(_winName, dispImg);}</code></pre><h2 id="3、效果图"><a href="#3、效果图" class="headerlink" title="3、效果图"></a>3、效果图</h2><p><img src="/img/20190811153803544-.png" alt="效果图"></p><h2 id="4、工程下载"><a href="#4、工程下载" class="headerlink" title="4、工程下载"></a>4、工程下载</h2><p><a href="https://download.csdn.net/download/soaringlee_fighting/11522571" target="_blank" rel="noopener">https://download.csdn.net/download/soaringlee_fighting/11522571</a></p><hr><h2 id="THE-END"><a href="#THE-END" class="headerlink" title=" THE  END! "></a><font color="red"> <strong>THE  END!</strong> </font></h2>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 图像处理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CV </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>技术发展之路---专业能力</title>
      <link href="/2019/08/10/%E3%80%90Think%E7%B3%BB%E5%88%97%E3%80%91%E6%8A%80%E6%9C%AF%E5%8F%91%E5%B1%95%E4%B9%8B%E8%B7%AF%E2%80%94%E2%80%94%E4%B8%93%E4%B8%9A%E8%83%BD%E5%8A%9B/"/>
      <url>/2019/08/10/%E3%80%90Think%E7%B3%BB%E5%88%97%E3%80%91%E6%8A%80%E6%9C%AF%E5%8F%91%E5%B1%95%E4%B9%8B%E8%B7%AF%E2%80%94%E2%80%94%E4%B8%93%E4%B8%9A%E8%83%BD%E5%8A%9B/</url>
      
        <content type="html"><![CDATA[<h2 id="整理于2019年8月10日-星期六-杭州滨江"><a href="#整理于2019年8月10日-星期六-杭州滨江" class="headerlink" title="整理于2019年8月10日 星期六 杭州滨江"></a>整理于2019年8月10日 星期六 杭州滨江</h2><p>[TOC]</p><p><strong>1、专业技能：</strong></p><ol><li>精通MPEG-4、SVAC1、H265视频编码标准及其实现</li><li>熟悉MPEG-2、H.264、AVS、SVAC2视频编码标准，熟悉ffmpeg开源框架的开发</li><li>熟悉C/C++、Matlab、Python和Linux Shell 等语言，熟悉makefile及技术文档的撰写</li><li>熟悉amba、hisi平台相关的智能编码开发以及DSP平台的硬件编解码开发</li><li>熟悉视频编码算法相关的汇编优化（x86平台、arm平台）</li><li>熟悉计算机视觉、图像处理和模式识别的常用算法，熟悉OpenCV开发</li></ol><p><strong>2、专业能力梳理：</strong></p><ol><li>软件开发能力：C/C++, Shell, Python, windows cmd</li><li>视频编解码开发能力：</li></ol><ul><li>软件解码器开发：H.264,H.265,SVAC,MPEG4,MPEG2</li><li>硬件编解码开发： 海思HISI, 安霸Amba, 晨星SigmaStar</li></ul><ol start="3"><li>图像算法开发能力：Denoise, LLE, Dehaze, Sharpen</li><li>工程化能力：工程编译等</li><li>汇编优化能力：ARM汇编，X86汇编</li></ol><p><strong>3、学习计划：</strong><br>2019年目标之一：2019学习一门新的不同风格的编程语言（Objective-C）</p><p>关于编程语言的学习计划：<br>1、深入Qt，巩固C++，精通面向对象思想；<br>2、深入Python,Shell和Makefile脚本语言；<br>3、初步入门OC语言<br>4、总结不同编程语言的异同（实现方式、思想、特点、应用场景等）。</p><p><strong>4、音视频技术方向专家</strong></p><p><a href="https://www.cnblogs.com/imstudy/p/9099514.html" target="_blank" rel="noopener">音视频技术全站路线</a><br><a href="https://blog.csdn.net/allen8612433/article/details/80328876" target="_blank" rel="noopener">音视频技术原理</a></p><hr><h2 id="THE-END"><a href="#THE-END" class="headerlink" title="THE END!"></a><font color="red">THE END!</font></h2>]]></content>
      
      
      <categories>
          
          <category> 生活 </category>
          
          <category> 规划 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Think </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>吉他学习入门基本知识</title>
      <link href="/2019/08/08/%E3%80%90%E9%9F%B3%E4%B9%90%E7%B3%BB%E5%88%97%E3%80%91%E5%90%89%E4%BB%96%E5%AD%A6%E4%B9%A0%E5%85%A5%E9%97%A8%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86/"/>
      <url>/2019/08/08/%E3%80%90%E9%9F%B3%E4%B9%90%E7%B3%BB%E5%88%97%E3%80%91%E5%90%89%E4%BB%96%E5%AD%A6%E4%B9%A0%E5%85%A5%E9%97%A8%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="1、吉他选择"><a href="#1、吉他选择" class="headerlink" title="1、吉他选择"></a>1、吉他选择</h2><p><a href="https://baijiahao.baidu.com/s?id=1602270316606536108&wfr=spider&for=pc" target="_blank" rel="noopener">新手学吉他，如何快速入门</a><br><a href="http://jitapaizi.lofter.com/" target="_blank" rel="noopener">初学吉他买什么吉他好？新手买吉他必看</a><br><a href="http://www.sosmusic.cn/wap/news/view?id=600" target="_blank" rel="noopener">雅马哈F310</a></p><p>经过几天对吉他构造的研究，对于面板的选择，最终选择了雅马哈的F310系列吉他，作为初学的吉他。</p><h2 id="2、吉他教程"><a href="#2、吉他教程" class="headerlink" title="2、吉他教程"></a>2、吉他教程</h2><p><a href="https://www.jitatang.com/jiaocheng" target="_blank" rel="noopener">吉他教程</a><br><a href="https://blog.csdn.net/justdoit_potato/article/details/70256482" target="_blank" rel="noopener">吉他入门乐理知识精髓篇</a><br><a href="https://www.cnblogs.com/devymex/p/3385179.html" target="_blank" rel="noopener">写给理工科人看的乐理（一）声学基础</a></p><h2 id="3、吉他理论"><a href="#3、吉他理论" class="headerlink" title="3、吉他理论"></a>3、吉他理论</h2><p>原文链接：<a href="https://blog.csdn.net/justdoit_potato/article/details/70256482" target="_blank" rel="noopener">https://blog.csdn.net/justdoit_potato/article/details/70256482</a></p><h3 id="3-1-时值"><a href="#3-1-时值" class="headerlink" title="3.1 时值"></a>3.1 时值</h3><p>时值就是控制音符长短的单位，他的计算单位是：拍</p><p>我们目前的记谱方法有三种：五线谱、六线谱、简谱等。在这三种不同的记谱方法中，它们表示时值长短的方法略有不同，但大体相似，他们都是以五线谱为基础形成的。</p><h3 id="3-2-六线谱"><a href="#3-2-六线谱" class="headerlink" title="3.2 六线谱"></a>3.2 六线谱</h3><p>六线谱是世界上通用的一种专为吉他设计的记谱方法，我们在学习吉他时，接触最多的也是他。六线谱的基本结构是由六根间隔相等的线组成，这六根线分别代表吉他上的六根弦，最下面的一条线，代表吉他的第六根弦，注意，是第六，不是第一，这个要反过来理解的，然后依次是又上到下看谱，倒数第二根线代表第五根弦，下面的依次类推。</p><p>六线谱:六线谱是把吉他的六根弦对应地划出六条平行的横线来表示两手演奏的位置和动作（即指法），而不是记录的音的高低，但它与简谱或五线谱结合对照起来使用时非常方便，既能表示音高，又能表示指法。</p><p>六线谱对吉他常用的演奏方式（独奏、分解伴奏和漫弹节奏）分别用如下方式记录： 独奏（旋律）记谱：在六条线上写上阿拉伯数字。</p><p>六线谱中的数字表示吉他的品格，写在线上的数字表示左手按第几品，数字所在的线即右手应弹的弦。</p><p>分解和弦伴奏记谱：在六线上画“X”，此时六线谱上方往往有关于左手按和弦的指法图或标记表示。那么你就用左手按好和弦，“X”表示用右手指弹响其所在的弦。</p><p><img src="/img/20190810155516304-.png" alt="六线谱"></p><p>“x”表示右手拨弦的顺序，即分解节奏，第一小节中第一拍可记做6 3 2 第二拍记作6 1 2 3，第三四拍重复一二拍。这是一个两拍的节奏，即6 3 2 6 1 2 3.</p><h3 id="3-3-音符和唱名"><a href="#3-3-音符和唱名" class="headerlink" title="3.3 音符和唱名"></a>3.3 音符和唱名</h3><p>记录音乐的方式很多，如五线谱、简谱、六线谱等。</p><p>例如，在简谱中，记录音的高低和长短的符号，就叫做音符，它是由7个阿拉伯数字或缀以其他符号构成的。</p><p>而记录拟稿的基本符号，只是用七个阿拉伯数字来表示。这七个数字各表示一个音名，其读法就是该音名的唱名：</p><pre><code>简谱 1 2 3 4 5 6 7 1音名 C D E F G A B C唱名 Do Re Mi Fa Sol La Ti Do</code></pre><p>注意：在这个音阶中 3——4 相隔半音，7——1 也相隔半音，其余相邻两音都相差全音，这也是吉它乐理中一个极重要的公式。在吉它指板上，半音是相邻两格之间的距离。</p><h3 id="3-4-和弦知识概述"><a href="#3-4-和弦知识概述" class="headerlink" title="3.4 和弦知识概述"></a>3.4 和弦知识概述</h3><p>这里指的和弦通常指同时响出三个或三个以上不同高度的音，音名的排列有C、D、E、F、G、A 和 B七个音其中任何一个音都可以作主音（即根音）加上其上三度音和上五度音，便构成最基本的三和弦，分述如下：</p><pre><code>C ：1 3 5D ：2 4 6E ：3 5 7F ：4 6 1G ：5 7 2A ：6 1 3B ：7 2 4</code></pre><p>以上七和弦均由相隔三度的三个音组成，所以称为三度和弦，这七个三和弦便是一切和弦的根基。</p><p><strong>三和弦</strong></p><p>上述七个基础的三和弦，从音程上来说，可分出三种不同性质的三和弦</p><p>1、大三和弦</p><p>主音至三度音共有四个半音；主音至五度音共有七个半音。上面七个三和弦中的 C、F、G 便是。</p><p>2、小三和弦</p><p>主音至三度音共有三个半音；主音至五度音共有七个半音。上面七个三和弦中的 D、E、</p><p>A 便是。为了区别，写成 Dm、Em、Am 。</p><p>3、减三和弦</p><p>主音至三度音共有四个半音；主音至三度音共有七个半音。上面七个三和弦中的 B 便是。写成 B- 。</p><p><strong>七和弦</strong></p><p>由于上面的七个三和弦不够用，因此，在各三和弦的上方，加上一个三度音，便够成下列七个七和弦：</p><pre><code>C7 ：1 3 5 7Dm7 ：2 4 6 1Em7 ：3 5 7 2F7 ：4 6 1 3G7 ：5 7 2 4Am7 ：6 1 3 5B-7 ：7 2 4 6</code></pre><p>七个七和弦中，在音名排列第五个音 G、即属音作主音所成的七和弦，是上述七和弦中最常用的一个，既属七和弦 G7 。</p><p>因 G7 的四个组成音：“5 7 2 4” 已包含了 G 和弦的 “5 7 2”。因此，在和声手法上，大调歌曲用 C、F、G7 这三个和弦，便可以伴奏一般简单的大调歌曲。</p><hr><h2 id="THE-END"><a href="#THE-END" class="headerlink" title=" THE END! "></a><font color="red"> THE END! </font></h2>]]></content>
      
      
      <categories>
          
          <category> 生活 </category>
          
          <category> 音乐 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 吉他 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python+Qt实现简单的视频监控界面</title>
      <link href="/2019/08/04/%E3%80%90%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE%E3%80%91Python+Qt%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E7%9A%84%E8%A7%86%E9%A2%91%E7%9B%91%E6%8E%A7%E7%95%8C%E9%9D%A2/"/>
      <url>/2019/08/04/%E3%80%90%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE%E3%80%91Python+Qt%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E7%9A%84%E8%A7%86%E9%A2%91%E7%9B%91%E6%8E%A7%E7%95%8C%E9%9D%A2/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="1、前言"><a href="#1、前言" class="headerlink" title="1、前言"></a>1、前言</h2><p>这个界面是之前读研时候学习QT时写的一个简单的界面，主要实现了人脸检测部分的功能，比较简单。</p><p>从今年3月份就开始写这个视频监控的功能，一直拖到了11月份。找工作结束后，可以好好研究一下Python和Qt以及两者的混合编程了。<br>不过，在实现视频监控界面的过程中，甚是纠结，看来混合编程是不好弄的。</p><h2 id="2、简单的视频监控界面实现"><a href="#2、简单的视频监控界面实现" class="headerlink" title="2、简单的视频监控界面实现"></a>2、简单的视频监控界面实现</h2><p>平台：Python + Qt<br>初步代码如下：</p><pre><code># -*- coding:utf-8 -*-#Created by SoaringLee at 2016/3/26#Updated by SoaringLee at 2016/11/9from PyQt4 import QtCore, QtGuiimport sysimport cv2import cv2.cv as cvimport numpy as npcascade_fn = &#39;data/haarcascades/haarcascade_frontalface_alt2.xml&#39; #训练好的xml数据save_video = Falsesnap_flag = Falseopen_face = Truepreprocessing = Truedef Face_detect(img, cascade):  #人脸检测函数    rects = cascade.detectMultiScale(img, scaleFactor=1.3,minNeighbors=5, minSize=(20, 20),                                         flags = cv.CV_HAAR_SCALE_IMAGE)    if len(rects) == 0:            return []    #print rects    rects[:,2:] += rects[:,:2]  #这是什么意思,设置矩形框的大小    print rects    return rectsdef draw_rects(img, rects, color): #在img上绘制矩形    for x1, y1, x2, y2 in rects:        cv2.rectangle(img, (x1, y1), (x2, y2), color, 2)def laplaceTransform(img):    #Laplace滤波    gray_laplace = cv2.Laplacian(img,cv2.CV_16S,ksize = 3)    dst = cv2.convertScaleAbs(gray_laplace)    return dstdef SobelFilter(img):        #Sobel滤波    x = cv2.Sobel(img,cv2.CV_16S,1,0)    y = cv2.Sobel(img,cv2.CV_16S,0,1)    absX = cv2.convertScaleAbs(x)    absY = cv2.convertScaleAbs(y)    gray_sobel = cv2.addWeighted(absX,0.5,absY,0.5,0)    return gray_sobel###########################################################################视频监控界面原型 功能说明：##（1）按下ESC或者q键，退出视频监控界面【已实现】##（2）按下空格键，保存当前视频图像到本地（摄像头拍照功能）【已实现】##（3）选择是否人脸检测和将视频保存到本地（本地录像功能）【已实现】##（4）增加功能：多路实时监控，调节亮度和对比度功能，调节画质功能，网络视频监控，循环录像功能##（5）GUI界面封装：将视频监控功能封装成界面，实现监控产品的基本功能。进一步考虑网络功能#########################################################################try:    _fromUtf8 = QtCore.QString.fromUtf8except AttributeError:    def _fromUtf8(s):        return stry:    _encoding = QtGui.QApplication.UnicodeUTF8    def _translate(context, text, disambig):        return QtGui.QApplication.translate(context, text, disambig, _encoding)except AttributeError:    def _translate(context, text, disambig):        return QtGui.QApplication.translate(context, text, disambig)class Ui_MainWindow(object):    def setupUi(self, MainWindow):        MainWindow.setObjectName(_fromUtf8(&quot;Video Surveilliance Interface&quot;))        MainWindow.resize(688, 427)        self.centralWidget = QtGui.QWidget(MainWindow)        self.centralWidget.setObjectName(_fromUtf8(&quot;centralWidget&quot;))        self.Btn_VideoWriter = QtGui.QPushButton(self.centralWidget)        self.Btn_VideoWriter.setGeometry(QtCore.QRect(20, 40, 91, 41))        self.Btn_VideoWriter.setObjectName(_fromUtf8(&quot;Btn_VideoWriter&quot;))        self.Btn_VideoWriter.clicked.connect(self.Btn_VideoWriter_Clicked)        self.Btn_VideoWarning = QtGui.QPushButton(self.centralWidget)        self.Btn_VideoWarning.setGeometry(QtCore.QRect(20, 110, 91, 41))        self.Btn_VideoWarning.setObjectName(_fromUtf8(&quot;Btn_VideoWarning&quot;))        self.Btn_VideoSnap = QtGui.QPushButton(self.centralWidget)        self.Btn_VideoSnap.setGeometry(QtCore.QRect(20, 180, 91, 41))        self.Btn_VideoSnap.setObjectName(_fromUtf8(&quot;Btn_VideoSnap&quot;))        self.Btn_VideoSnap.clicked.connect(self.Btn_VideoSnap_Clicked)        self.Btn_FaceDetection = QtGui.QPushButton(self.centralWidget)        self.Btn_FaceDetection.setGeometry(QtCore.QRect(20, 250, 91, 41))        self.Btn_FaceDetection.setObjectName(_fromUtf8(&quot;Btn_FaceDetection&quot;))        self.Btn_FaceDetection.clicked.connect(self.Btn_FaceDetection_Clicked)        self.Btn_Preprocessing = QtGui.QPushButton(self.centralWidget)        self.Btn_Preprocessing.setGeometry(QtCore.QRect(20, 320, 91, 41))        self.Btn_Preprocessing.setObjectName(_fromUtf8(&quot;Btn_Preprocessing&quot;))        self.Btn_Preprocessing.clicked.connect(self.Btn_Preprocessing_Clicked)        self.label = QtGui.QLabel(self.centralWidget)        self.label.setObjectName(_fromUtf8(&quot;label&quot;))        #self.label.setGeometry(QtCore.QRect(20, 320, 91, 41))        MainWindow.setCentralWidget(self.centralWidget)        self.menuBar = QtGui.QMenuBar(MainWindow)        self.menuBar.setGeometry(QtCore.QRect(0, 0, 688, 23))        self.menuBar.setObjectName(_fromUtf8(&quot;menuBar&quot;))        MainWindow.setMenuBar(self.menuBar)        self.mainToolBar = QtGui.QToolBar(MainWindow)        self.mainToolBar.setObjectName(_fromUtf8(&quot;mainToolBar&quot;))        MainWindow.addToolBar(QtCore.Qt.TopToolBarArea, self.mainToolBar)        self.statusBar = QtGui.QStatusBar(MainWindow)        self.statusBar.setObjectName(_fromUtf8(&quot;statusBar&quot;))        MainWindow.setStatusBar(self.statusBar)        self.retranslateUi(MainWindow)        QtCore.QMetaObject.connectSlotsByName(MainWindow)    def Btn_VideoWriter_Clicked(self):        save_video =True    def Btn_VideoSnap_Clicked(self):        snap_flag = True    def Btn_FaceDetection_Clicked(self):        open_face = True    def Btn_Preprocessing_Clicked(self):        preprocessing = True    def retranslateUi(self, MainWindow):        MainWindow.setWindowTitle( &quot;MainWindow&quot;)        self.Btn_VideoWriter.setText(_fromUtf8(&quot;Recoding&quot;))        self.Btn_VideoWarning.setText(_translate(&quot;MainWindow&quot;,&quot;Video Warning&quot;,None))        self.Btn_VideoSnap.setText(_translate(&quot;MainWindow&quot;,&quot;Snap&quot;,None))        self.Btn_FaceDetection.setText(_translate(&quot;MainWindow&quot;,&quot;Face Detection&quot;,None))        self.Btn_Preprocessing.setText(_translate(&quot;MainWindow&quot;,&quot;Preprocessing&quot;,None))        self.label.setText(&quot;Image&quot;)    def camera_cap(self,MainWindow):        capture1=cv2.VideoCapture(0) #获取摄像头数据      #将capture保存为motion-jpeg,cv_fourcc为保存格式        size = (int(capture1.get(cv2.cv.CV_CAP_PROP_FRAME_WIDTH)),            int(capture1.get(cv2.cv.CV_CAP_PROP_FRAME_HEIGHT)))      #isopened可以查看摄像头是否开启        print capture1.isOpened(),r&quot;摄像头1已开启！&quot;        num=0        if save_video:            flag = True            video=cv2.VideoWriter(&quot;VideoTest.avi&quot;, cv2.cv.CV_FOURCC(&#39;I&#39;,&#39;4&#39;,&#39;2&#39;,&#39;0&#39;),30, size)        else:            flag = None          #要不断读取image需要设置一个循环        while True:            if capture1.isOpened():                ret1,img1=capture1.read()           #视频中的图片一张张写入            if flag:                video.write(img1)            cv2.imshow(r&#39;【视频监控画面1】&#39;,img1);            cv2.waitKey(1)            #cv2.imwrite(&#39;%s.jpg&#39;%(str(num)),img)            gray = cv2.cvtColor(img1,cv2.COLOR_BGR2GRAY)            cascade = cv2.CascadeClassifier(cascade_fn) #加载分类器            if not cascade:                print stderr,&quot;ERROR:Could not load classifier cascade!&quot;            else:                pass            rects1 = Face_detect(gray, cascade) #进行人脸检测            vis1= img1.copy()            if open_face:                draw_rects(vis1, rects1, (0, 255, 0))                cv2.imshow(r&#39;人脸检测&#39;, vis1)            if preprocessing:                laplace=laplaceTransform(vis1)                cv2.imshow(r&#39;laplace【拉普拉斯锐化】&#39;,laplace)                sobel =SobelFilter(vis1)                cv2.imshow(r&#39;Sobel【边缘提取】&#39;,sobel)                equalize = cv2.equalizeHist(gray)                cv2.imshow(r&#39;【直方图均衡化】&#39;,equalize)            key=cv2.waitKey(2)#里面数字为delay时间，如果大于0为刷新时间，                #超过指定时间则返回-1，等于0没有返回值，但也可以读取键盘数值。此处设置刷新时间为2ms            num = num+1            if key == ord(&#39;q&#39;):                break            if key == 27: #27表示ESC的ASCII码值                break            if snap_flag:                cv2.imwrite(r&#39;通道1_保存的图片&#39;+str(num)+&#39;.jpg&#39;,img1)        capture1.release()#关闭摄像头        cv2.destroyAllWindows()#关闭所有窗口if __name__ == &quot;__main__&quot;:    app = QtGui.QApplication(sys.argv)    MainWindow = QtGui.QMainWindow()    ui = Ui_MainWindow()    ui.setupUi(MainWindow)    MainWindow.show()    ui.camera_cap(MainWindow)    sys.exit(app.exec_())</code></pre><p>运行结果：</p><p><img src="/img/20181209201726351.png" alt="初步界面"></p><h2 id="3、功能更新"><a href="#3、功能更新" class="headerlink" title="3、功能更新"></a>3、功能更新</h2><p><font color="red"> <strong>相关功能有待进一步完善！</strong></font></p><h2 id="THE-END"><a href="#THE-END" class="headerlink" title=" THE END! "></a><font color="red"> THE END! </font></h2>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 开源项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Conda安装和使用方法</title>
      <link href="/2019/07/27/%E3%80%90Tools%E7%B3%BB%E5%88%97%E3%80%91Conda%E5%AE%89%E8%A3%85%E5%92%8C%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/"/>
      <url>/2019/07/27/%E3%80%90Tools%E7%B3%BB%E5%88%97%E3%80%91Conda%E5%AE%89%E8%A3%85%E5%92%8C%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>&ensp; &ensp; &ensp;  在一个机器上需要安装多个版本的软件包时，我们一般需要卸载了旧版本再安装新版本。使用Conda，可以实现在一个机器上同时安装多个版本的软件包，并且可以管理软件包。下面记录Conda工具的安装和使用方法。</p><h2 id="1、参考"><a href="#1、参考" class="headerlink" title="1、参考"></a>1、参考</h2><p><a href="https://python.freelycode.com/contribution/detail/1366" target="_blank" rel="noopener">conda的最佳实践</a><br><a href="https://www.cnblogs.com/liaohuiqiang/p/9380417.html" target="_blank" rel="noopener">conda环境管理</a><br><a href="https://blog.csdn.net/chenfeidi1/article/details/80873993" target="_blank" rel="noopener">Conda使用手册</a><br><a href="https://pypi.org/project/conda/" target="_blank" rel="noopener">https://pypi.org/project/conda/</a><br><a href="https://www.anaconda.com/" target="_blank" rel="noopener">anaconda官网</a><br><a href="https://github.com/conda" target="_blank" rel="noopener">github-conda</a></p><h2 id="2、Conda简介"><a href="#2、Conda简介" class="headerlink" title="2、Conda简介"></a>2、Conda简介</h2><p>为什么要使用Conda？</p><p>Conda 是一个开源的软件包管理系统和环境管理系统，用于安装多个版本的软件包及其依赖关系，并在它们之间轻松切换。 Conda 是为 Python 程序创建的，适用于 Linux，OS X 和Windows，也可以打包和分发其他软件。Conda是完全由Python语言写的，是BSD协议开源的。</p><p>英文简介：<a href="https://conda.io/en/latest/" target="_blank" rel="noopener">https://conda.io/en/latest/</a></p><p>Conda is an open source package management system and environment management system that runs on Windows, macOS and Linux. Conda quickly installs, runs and updates packages and their dependencies. Conda easily creates, saves, loads and switches between environments on your local computer. It was created for Python programs, but it can package and distribute software for any language.</p><h2 id="3、Conda用途"><a href="#3、Conda用途" class="headerlink" title="3、Conda用途"></a>3、Conda用途</h2><ul><li>Quickly download 1,500+ Python/R data science packages</li><li>Manage libraries, dependencies, and environments with Conda</li><li>Develop and train machine learning and deep learning models with scikit-learn, TensorFlow, and Theano</li><li>Analyze data with scalability and performance with Dask, NumPy, pandas, and Numba</li><li>Visualize results with Matplotlib, Bokeh, Datashader, and Holoviews</li></ul><h2 id="4、Conda安装和使用说明"><a href="#4、Conda安装和使用说明" class="headerlink" title="4、Conda安装和使用说明"></a>4、Conda安装和使用说明</h2><h3 id="4-1-Conda安装"><a href="#4-1-Conda安装" class="headerlink" title="4.1 Conda安装"></a>4.1 Conda安装</h3><p>conda分为anaconda和miniconda。anaconda是包含一些常用包的版本，miniconda则是精简版，需要啥装啥，所以推荐使用miniconda。<br>miniconda下载网址：<a href="https://conda.io/en/latest/miniconda.html" target="_blank" rel="noopener">https://conda.io/en/latest/miniconda.html</a><br>anaconda下载网址：<a href="https://www.anaconda.com/distribution/#download-section" target="_blank" rel="noopener">https://www.anaconda.com/distribution/#download-section</a></p><p>下面以miniconda为例说明：<br><strong>一、Windows平台安装步骤</strong></p><p><a href="https://conda.io/projects/conda/en/latest/user-guide/install/windows.html" target="_blank" rel="noopener">https://conda.io/projects/conda/en/latest/user-guide/install/windows.html</a></p><p><strong>二、Linux平台安装步骤</strong></p><p><a href="https://conda.io/projects/conda/en/latest/user-guide/install/linux.html" target="_blank" rel="noopener">https://conda.io/projects/conda/en/latest/user-guide/install/linux.html</a></p><h3 id="4-2-Conda使用说明"><a href="#4-2-Conda使用说明" class="headerlink" title="4.2 Conda使用说明"></a>4.2 Conda使用说明</h3><p>1、查看当前Conda安装信息</p><pre><code class="shell">conda info</code></pre><p>2、查看当前已有的环境</p><pre><code class="shell">conda env list</code></pre><p>3、移除指定的环境</p><pre><code class="shell">conda remove -n env_name --all</code></pre><p>4、创建一个新的环境</p><pre><code class="shell">conda create -n env_name python=3.7.3</code></pre><p>5、列出某个环境中的相关包</p><pre><code class="shell">conda list -n env_name</code></pre><p>列出当前环境中的相关包</p><pre><code class="shell">conda list</code></pre><p>6、根据环境名进行该环境</p><pre><code class="shell">source activate env_name # linux下activate env_name   # windows下</code></pre><p>7、退出conda环境</p><pre><code class="shell">source deactivate</code></pre><p>8、查找相关的包（搜索）</p><pre><code class="shell">conda search xxxx</code></pre><p>9、安装相关的包</p><pre><code class="shell">conda isntall xxxx</code></pre><p>10、增加指定源（使用国内 conda 软件源）</p><pre><code class="shell">$ conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/$ conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main/$ conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/conda-forge/$ conda config --set show_channel_urls yes</code></pre><p>11、指定环境，安装指定版本的包</p><pre><code class="shell">conda install -n python36 mxnet==1.0.0</code></pre><p>12、指定环境，删除包</p><pre><code class="shell">conda remove -n python36 mxnet</code></pre><p>13、导出环境为yml</p><pre><code class="shell">conda env export &gt;  environment.yml</code></pre><p>14、根据yml创建环境</p><pre><code class="shell">conda env create -f environment.yml</code></pre><h2 id="5、补充知识：fish-shell"><a href="#5、补充知识：fish-shell" class="headerlink" title="5、补充知识：fish shell"></a>5、补充知识：fish shell</h2><p><a href="http://fishshell.com/" target="_blank" rel="noopener">http://fishshell.com/</a></p><h2 id="6、Conda-cheatsheet-操作简介"><a href="#6、Conda-cheatsheet-操作简介" class="headerlink" title="6、Conda cheatsheet(操作简介)"></a>6、Conda cheatsheet(操作简介)</h2><p><a href="http://know.continuum.io/rs/387-XNW-688/images/conda-cheatsheet.pdf" target="_blank" rel="noopener">http://know.continuum.io/rs/387-XNW-688/images/conda-cheatsheet.pdf</a></p><hr><h2 id="THE-END"><a href="#THE-END" class="headerlink" title=" THE  END! "></a><font color="red"> THE  END! </font></h2>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Conda </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git使用方法</title>
      <link href="/2019/07/14/%E3%80%90Tools%E7%B3%BB%E5%88%97%E3%80%91Git%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/"/>
      <url>/2019/07/14/%E3%80%90Tools%E7%B3%BB%E5%88%97%E3%80%91Git%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="1、参考"><a href="#1、参考" class="headerlink" title="1、参考"></a>1、参考</h2><p><a href="https://blog.csdn.net/listener51/article/details/53872174" target="_blank" rel="noopener">github代码仓创建及更新</a><br><a href="https://blog.csdn.net/WindSwordNeverRegret/article/details/79758457" target="_blank" rel="noopener">GitHub上传、更新代码</a><br><a href="https://www.liaoxuefeng.com/wiki/896043488029600" target="_blank" rel="noopener">Git教程</a></p><h2 id="2、Git安装"><a href="#2、Git安装" class="headerlink" title="2、Git安装"></a>2、Git安装</h2><h3 id="2-1、Git下载"><a href="#2-1、Git下载" class="headerlink" title="2.1、Git下载"></a>2.1、Git下载</h3><p>Git官网：<a href="https://git-scm.com/" target="_blank" rel="noopener">https://git-scm.com/</a></p><p>Git is a free and open source distributed version control system designed to handle everything from small to very large projects with speed and efficiency.</p><p>Git下载地址：<a href="https://git-scm.com/downloads" target="_blank" rel="noopener">https://git-scm.com/downloads</a><br><img src="/img/20190714110814949-.png" alt="Git下载界面"></p><h3 id="2-2、Git配置"><a href="#2-2、Git配置" class="headerlink" title="2.2、Git配置"></a>2.2、Git配置</h3><p>安装完成之后，在开始菜单里找到“Git”-&gt;“Git Bash”，蹦出一个类似命令行窗口的东西，就说明Git安装成功！</p><p>安装完成后，还需要最后一步设置，在命令行输入：</p><pre><code class="c">$ git config --global user.name &quot;Your Name&quot;$ git config --global user.email &quot;email@example.com&quot;</code></pre><h2 id="3、Git使用方法"><a href="#3、Git使用方法" class="headerlink" title="3、Git使用方法"></a>3、Git使用方法</h2><p>Git命令有下面这些，我们分别来看这些命令是怎么使用的。<strong>我们通过Github代码仓库创建，通过Git上传、更新和下载代码为主线进行分析。</strong><br><img src="/img/2019071411160131-.png" alt="Git命令行用法"></p><h3 id="3-1、在Github上创建版本库"><a href="#3-1、在Github上创建版本库" class="headerlink" title="3.1、在Github上创建版本库"></a>3.1、在Github上创建版本库</h3><p>&ensp;    &ensp;  版本库又名仓库，英文名repository，你可以简单理解成一个目录，这个目录里面的所有文件都可以被Git管理起来，每个文件的修改、删除，Git都能跟踪，以便任何时刻都可以追踪历史，或者在将来某个时刻可以“还原”。我们可以在本地创建版本库，也可以在Github上创建版本库，下面以在Github上创建版本库为例。</p><p>&ensp;  &ensp;  在github创建仓库用于存储管理本地文件，示例：YUV420P2RGB24。点击账号前的加号（Create New）–New repository，根据引导创建一个Blog仓库，如下图所示：<br><img src="/img/20190714113034856-.png" alt="Github版本库创建"></p><h3 id="3-2、-git-clone新建好的版本库到本地目录"><a href="#3-2、-git-clone新建好的版本库到本地目录" class="headerlink" title="3.2、 git clone新建好的版本库到本地目录"></a>3.2、 git clone新建好的版本库到本地目录</h3><p>打开Git Bash，输入：</p><pre><code class="c">git clone  https://github.com/soaringleefighting/YUV420P2RGB24.git</code></pre><p>本地clone到的目录和文件如下：<br><img src="/img/20190714113713164-.png" alt="本地目录"></p><h3 id="3-3、-将想要上传的代码目录拷贝到上面目录中"><a href="#3-3、-将想要上传的代码目录拷贝到上面目录中" class="headerlink" title="3.3、 将想要上传的代码目录拷贝到上面目录中"></a>3.3、 将想要上传的代码目录拷贝到上面目录中</h3><p><img src="/img/20190714114239441-.png" alt="本地目录"></p><h3 id="3-4、通过Git上传代码"><a href="#3-4、通过Git上传代码" class="headerlink" title="3.4、通过Git上传代码"></a>3.4、通过Git上传代码</h3><p>输入命令：</p><pre><code class="c">【1】#git init //本地建立一个空的Git仓库，此处前面已经建好了仓库，直接下面的步骤即可【2】git add .  // 上传本地目录下所有文件【3】git commit -m &#39;[add] add code and project&#39;  //提交更改log日志【4】#git remote add origin https://github.com/Flowerowl/stumansys.git  //添加新的远程仓库【5】git pull //更新代码【6】#git push origin master // 上传代码git push //上传代码</code></pre><p>上传成功：<br><img src="/img/20190714115357118-.png" alt="上传成功示意图"></p><h3 id="3-5、更新仓库代码"><a href="#3-5、更新仓库代码" class="headerlink" title="3.5、更新仓库代码"></a>3.5、更新仓库代码</h3><p>对于已经存在代码仓库，添加新的文件或文件夹到代码仓库中，步骤如下：</p><pre><code class="c">【1】git add filename or git add.【2】git commit -m &quot;comment&quot;【3】git pull origin master【4】git push -u origin master</code></pre><hr><h2 id="THE-END"><a href="#THE-END" class="headerlink" title=" THE  END! "></a><font color="red"> THE  END! </font></h2>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>颜色空间转换CSConvert：YUV420转YUV444</title>
      <link href="/2019/07/13/%E3%80%90Codecs%E7%B3%BB%E5%88%97%E3%80%91%E9%A2%9C%E8%89%B2%E7%A9%BA%E9%97%B4%E8%BD%AC%E6%8D%A2CSConvert%EF%BC%9AYUV420%E8%BD%ACYUV444/"/>
      <url>/2019/07/13/%E3%80%90Codecs%E7%B3%BB%E5%88%97%E3%80%91%E9%A2%9C%E8%89%B2%E7%A9%BA%E9%97%B4%E8%BD%AC%E6%8D%A2CSConvert%EF%BC%9AYUV420%E8%BD%ACYUV444/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="1、YUV的三种采样方式"><a href="#1、YUV的三种采样方式" class="headerlink" title="1、YUV的三种采样方式"></a>1、YUV的三种采样方式</h2><p><img src="/img/YUV.jpg" alt="YUV三种采样格式"></p><ul><li><p>YUV444：对于每一个像素都对应一个Y分量、一个U分量、一个V分量。</p></li><li><p>YUV422：对于一个像素都对应一个Y分量，但是每两个像素（或者说Y分量）对应一个U分量和一个V分量。</p></li><li><p>YUV420：对于一个像素都对应一个Y分量，但是每四个像素（或者说Y分量）对应一个U分量和一个V分量。</p></li></ul><h2 id="2、YUV的存储格式"><a href="#2、YUV的存储格式" class="headerlink" title="2、YUV的存储格式"></a>2、YUV的存储格式</h2><p>YUV在存储时是以数组的形式存储的，可以看做连续的三个数组。三个数组分别单独存储Y、U、V分量。</p><p>同理对于YUV420和YUV422，只是U和V的数组大小的不同而已。</p><p>以1920x1080分辨率为例，总数据量来看，YUV444需要存储1920x1080x3个值，YUV422需要存储1920x1080x2个值，YUV420需要存储192x1080x3/2个值。</p><h2 id="3、YUV420转YUV444主要思路"><a href="#3、YUV420转YUV444主要思路" class="headerlink" title="3、YUV420转YUV444主要思路"></a>3、YUV420转YUV444主要思路</h2><p>YUV420转YUV444，实际就是对色度进行上采样，最为简单的实现思路是直接填充。</p><p>以U分量为例，其序列如下</p><p><img src="/img/20180531213038569.png" alt="U分量示意"></p><p>对U进行插值，每个田字格四个位置使用一个U值。<br><img src="/img/20180531213048656.png" alt="U分量填充示意"></p><p>在代码中，可以直接通过对数组循环赋值即可完成。</p><p>对V分量的操作相同。</p><p>填充方式实现简单，效果较差，可以通过插值来完成上采样。</p><p>部分参考：<a href="https://blog.csdn.net/lin453701006/article/details/53053185" target="_blank" rel="noopener">https://blog.csdn.net/lin453701006/article/details/53053185</a></p><h2 id="4、算法实现（YUV420toYUV444）"><a href="#4、算法实现（YUV420toYUV444）" class="headerlink" title="4、算法实现（YUV420toYUV444）"></a>4、算法实现（YUV420toYUV444）</h2><p>自己实现的C代码如下：</p><pre><code>#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;int main(int argc, char** argv){    int i, j, width, height, frame_size;    FILE *fp_in, *fp_out;    unsigned char *y1, *u1, *v1, *y2, *u2, *v2;    int n = 0;    printf(&quot;\nUsage:YUV420toYUV444.exe inputfile outputfile width height\n\n&quot;);    for (i = 0; i &lt; argc;i++)    {        printf(&quot;Input parameters: %s \n&quot;, argv[i]);    }    if (argc &lt; 5)    {        return -1;    }    fp_in = fopen(argv[1], &quot;rb&quot;);    if (NULL == fp_in)    {        printf(&quot;ERROR: open %s fail\n&quot;, argv[1]);        return -1;    }    fp_out = fopen(argv[2], &quot;wb&quot;);    if (NULL == fp_out)    {        printf(&quot;ERROR: open %s fail\n&quot;, argv[2]);        return -1;    }    width = atoi(argv[3]);    height = atoi(argv[4]);    frame_size = width*height;    y1 = (unsigned char *)malloc(frame_size*3/2);    if ( NULL == y1 )    {        printf(&quot;malloc y1 fail\n&quot;);        return -1;    }    u1 = y1 + width*height;    v1 = u1 + width*height / 4;    y2 = (char *)malloc(frame_size*3);    if (NULL== y2 )    {        printf(&quot;malloc y2 fail\n&quot;);        return -1;    }    u2 = y2 + width*height;    v2 = u2 + width*height;    while (fread(y1,1,frame_size*3/2,fp_in) == frame_size*3/2)    {        memcpy(y2, y1, frame_size);//Y        for (j = 0; j &lt; height; j++)//U,V        {            for (i = 0; i &lt; width; i++)            {                u2[j*width + i] = u1[j / 2 * width / 2 + i / 2];                v2[j*width + i] = v1[j / 2 * width / 2 + i / 2];            }        }        fwrite(y2, 1, frame_size*3, fp_out);        n++;    }    printf(&quot;YUV420toYUV444 successfully!!,total frames: %d\n&quot;,n);    free(y1);    y1 = NULL;    free(y2);    y2 = NULL;    fclose(fp_in);    fclose(fp_out);    return 0;}</code></pre><h2 id="THE-END"><a href="#THE-END" class="headerlink" title=" THE  END!"></a><font color="red"> THE  END!</font></h2>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 视频处理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Video </tag>
            
            <tag> CSConvert </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>颜色空间转换CSconvert：NV21转BGR24和BGR24转NV21</title>
      <link href="/2019/07/13/%E3%80%90Codecs%E7%B3%BB%E5%88%97%E3%80%91%E9%A2%9C%E8%89%B2%E7%A9%BA%E9%97%B4%E8%BD%AC%E6%8D%A2CSconvert%EF%BC%9ANV21%E8%BD%ACBGR24%E5%92%8CBGR24%E8%BD%ACNV21/"/>
      <url>/2019/07/13/%E3%80%90Codecs%E7%B3%BB%E5%88%97%E3%80%91%E9%A2%9C%E8%89%B2%E7%A9%BA%E9%97%B4%E8%BD%AC%E6%8D%A2CSconvert%EF%BC%9ANV21%E8%BD%ACBGR24%E5%92%8CBGR24%E8%BD%ACNV21/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="1、参考"><a href="#1、参考" class="headerlink" title="1、参考"></a>1、参考</h2><p><a href="https://blog.csdn.net/baidu_31872269/article/details/64451869" target="_blank" rel="noopener">NV21转BGR图像</a></p><p><a href="https://blog.csdn.net/SoaringLee_fighting/article/details/95375517" target="_blank" rel="noopener">【Codecs系列】颜色空间转换CSconvert：RGB24转YUV420P</a></p><h2 id="2、NV21ToBGR24"><a href="#2、NV21ToBGR24" class="headerlink" title="2、NV21ToBGR24"></a>2、NV21ToBGR24</h2><p>NV21ToBGR24</p><pre><code class="c">/*********************************************************************/* Function: NV21ToBGR24/* Usage: colorspace convertion from YUV420SP(NV21) to BGR24/* Parameters:/*     pYUV   [In]        - source YUV data/*    pBGR24 [Out]    - output RGB data/*  width  [In]        - image width/*    height [In]        - image height/*/* Modified: 2019.7.13/*********************************************************************/int NV21ToBGR24(unsigned char *pYUV, unsigned char *pBGR24, int width, int height){    int bgr[3];    int i,j,k;    int yIdx, uIdx, vIdx, idx;    int len = width * height;    if(!pYUV || !pBGR24 || width &lt; 1 || height &lt; 1)          return -1;    unsigned char* yData = pYUV;    unsigned char* pVUData = &amp;yData[len];    for(i = 0; i &lt; height; i++)    {       for(j = 0; j &lt; width; j++)         {           yIdx = i*width+j;           vIdx = (i/2)*(width/2)+(j/2);           uIdx = vIdx;          // BT. 601           bgr[0] = (298*(yData[yIdx] - 16) + 517 * (pVUData[uIdx*2+1] - 128) + (1&lt;&lt;7)) &gt;&gt; 8; // b分量值           bgr[1] = (298*(yData[yIdx] - 16) - 208 * (pVUData[vIdx*2+0] - 128) - 100 * (pVUData[uIdx*2+1] - 128) + (1&lt;&lt;7))&gt;&gt;8;// g分量值           bgr[2] = (298*(yData[yIdx] - 16) + 409 * (pVUData[vIdx*2+0] - 128) + (1&lt;&lt;7))&gt;&gt;8; // r分量值         for(k=0; k&lt;3; k++)         {            idx = (i*width+j)*3+k;            pBGR24[idx] = CLIP_COLOR(bgr[k]);         }      }    }    return 0;}</code></pre><h2 id="3、BGR24toNV21"><a href="#3、BGR24toNV21" class="headerlink" title="3、BGR24toNV21"></a>3、BGR24toNV21</h2><pre><code class="c">/*********************************************************************/* Function: BGR24toNV21/* Usage: colorspace convertion from BGR24 to YUV420SP(NV21)/* Parameters:/*     pBGR24  [In]        - source RGB data/*    pYUV    [Out]        - output YUV data/*  width   [In]        - image width/*    height  [In]        - image height/*/* Modified: 2019.7.13/*********************************************************************/int BGR24toNV21(unsigned char *pBGR24, unsigned char *pYUV, int width, int height){    int i,j,index;    unsigned char *bufY, *bufVU, *bufRGB;    unsigned char y, u, v, r, g, b;    if(!pYUV || !pBGR24 || width &lt; 1 || height &lt; 1)       return -1;    memset(pYUV, 0 ,width*height*3/2*sizeof(unsigned char));    bufY = pYUV;    bufVU = bufY + width*height;    for(j=0; j &lt; height; j++)    {          bufRGB = pBGR24 + width*j*3;      for(i=0; i &lt; width; i++)       {         index = j*width+i;         b = *(bufRGB++);         g = *(bufRGB++);         r = *(bufRGB++);         y = (unsigned char)((66  * r + 129 * g + 25  * b + 128) &gt;&gt; 8) + 16;         u = (unsigned char)((-38 * r - 74  * g + 112 * b + 128) &gt;&gt; 8) + 128;         v = (unsigned char)((112 * r - 94  * g - 18  * b + 128) &gt;&gt; 8) + 128;         *(bufY++) = CLIP_COLOR(y);         if(j%2==0 &amp;&amp; index%2==0)          {                *(bufVU++) = CLIP_COLOR(v);              *(bufVU++) = CLIP_COLOR(u);          }       }    }    return 0;}</code></pre><h2 id="4、测试Demo"><a href="#4、测试Demo" class="headerlink" title="4、测试Demo"></a>4、测试Demo</h2><pre><code class="c">//Demo: This demo used to test YUV2BGR and BGR2YUVint main(int argc, char *argv[]){   FILE *fin, fou;   unsigned char *pInYUVBuf, *pYBuf, *pUBuf, *pVBuf;   unsigned char *pBGRBuf;   int index, framesize;   char string[255] = &quot;../testset/1.yuv&quot;;   char output[255] = &quot;../testset/output.yuv&quot;;   int width = 1280;   int height = 720;   Mat mBGR_to_show = Mat(height, width, CV_8UC3);   fin = fopen(string, &quot;rb&quot;);   if(NULL == fin)    {      printf(&quot;[demo] error: open fin failed!!!\n&quot;);      return -1;     }   fou = fopen(output, &quot;wb&quot;);   if(NULL == fou)    {      printf(&quot;[demo] error: open fou failed!!!\n&quot;);      return -1;     }   pInYUVBuf = (unsigned char*) malloc(width*height*3/2); // YUV buffer   if(NULL == pInYUVBuf)    {      printf(&quot;[demo] error: open pInYUVBuffer failed!!!\n&quot;);      return -1;     }   pYBuf = pInYUVBuff;   pUBuf = pYBuf + width*height;   pVBuf = pUBuf + width*height/4;   framesize = width*height*3/2;   pBGRBuf = (unsigned char*) malloc(width*height*3); // BGR buffer   if(NULL == pBGRBuf)    {      printf(&quot;[demo] error: open pBGRBuf failed!!!\n&quot;);      return -1;     }    index = 0;    while(framesize == fread(pInYUVBuf,1,width*height*3/2,fin))    {      NV21ToBGR24(pInYUVBuf, pBGRBuf, width, height);      memcpy(mBGR_to_show.data, pBGRBuf, sizeof(unsigned char)*width*height*3);      namedWindow(&quot;RGB&quot;, CV_WINDOW_NORMAL);      imshow(&quot;RGB&quot;, mBGR_to_show);      waitKey(2);      BGR24ToNV21(pBGRBuf, pInYUVBuf, width, height);      fwrite(pInYUVBuf, 1, width*height*3/2, fou);      index++;      printf(&quot;[demo] info: %d frame process ok!!!\n&quot;, index);     }     system(&quot;pause&quot;);     return 0;   }</code></pre><h2 id="5、效果图"><a href="#5、效果图" class="headerlink" title="5、效果图"></a>5、效果图</h2><p><img src="/img/20190809210150145-.png" alt="转换效果图"></p><p><img src="/img/20190809210520832-.png" alt="转换输出YUV"></p><p><img src="/img/20190809210844504-.png" alt="差值图像"></p><h2 id="6、分析"><a href="#6、分析" class="headerlink" title="6、分析"></a>6、分析</h2><p>将NV21转换成BGR24，然后再转换到NV21，会有一定的损失，转换的后的YUV与原始YUV会有1~5个像素值的差异 。</p><hr><h2 id="THE-END！"><a href="#THE-END！" class="headerlink" title=" THE END！ "></a><font color="red"> THE END！ </font></h2>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 视频处理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Codecs </tag>
            
            <tag> CSConvert </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>颜色空间转换CSConvert：NV12toYVYU或NV12toYUYV</title>
      <link href="/2019/07/13/%E3%80%90Codecs%E7%B3%BB%E5%88%97%E3%80%91%E9%A2%9C%E8%89%B2%E7%A9%BA%E9%97%B4%E8%BD%AC%E6%8D%A2CSConvert%EF%BC%9ANV12toYVYU%E6%88%96NV12toYUYV/"/>
      <url>/2019/07/13/%E3%80%90Codecs%E7%B3%BB%E5%88%97%E3%80%91%E9%A2%9C%E8%89%B2%E7%A9%BA%E9%97%B4%E8%BD%AC%E6%8D%A2CSConvert%EF%BC%9ANV12toYVYU%E6%88%96NV12toYUYV/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="1、NV12-YVYU-YUYV格式说明"><a href="#1、NV12-YVYU-YUYV格式说明" class="headerlink" title="1、NV12\YVYU\YUYV格式说明"></a>1、NV12\YVYU\YUYV格式说明</h2><p>NV12格式是YUV420sp，Intel原生态支持NV12格式；<br>YVYU格式属于YUV422，按照Y,V,Y,U一个平面排列。<br>YUYV格式与YVYU格式类似，都属于YUV422，按照Y,U,Y,V一个平面排列。</p><h2 id="2、NV12转YVYU"><a href="#2、NV12转YVYU" class="headerlink" title="2、NV12转YVYU"></a>2、NV12转YVYU</h2><p>下面实现NV12格式转换成YVYU或者YUYV功能：</p><p>NV12toYVYU.c</p><pre><code>#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;int main(int argc, char** argv){    int width, height, frame_size;    FILE *fin, *fou;    char *y, *uv, *y2, *temp_y, *temp_uv, *temp_y2;    int i, j, frame_num = 0;    printf(&quot;\nUsage: NV12toYVYU.exe infile outfile width height\n\n&quot;);    if (argc != 5)    {        return -1;    }    fin = fopen(argv[1], &quot;rb&quot;);    if (fin == NULL)    {        printf(&quot;ERROR: open %s fail\n&quot;, argv[1]);        return -1;    }    fou = fopen(argv[2], &quot;wb&quot;);    if (fou == NULL)    {        printf(&quot;RRROR: open %s fail\n&quot;, argv[2]);        return -1;    }    width = atoi(argv[3]);    height = atoi(argv[4]);    frame_size = width * height;    y = (char *)malloc(frame_size * 3 / 2);//++NV12    if (y == NULL)    {        printf(&quot;ERROR: malloc y fail\n&quot;);        return -1;    }    uv = y + width*height;    y2 = (char *)malloc(frame_size * 2);//++YVYU    if (y2 == NULL)    {        printf(&quot;ERROR: malloc y2 fail\n&quot;);        return -1;    }    while (!feof(fin))    {        int n = 0;        n = fread(y, 1, width*height, fin);        n += fread(uv, 1, width*height &gt;&gt; 1, fin);        if (n != frame_size *3/2)        {            break;        }        temp_y = y;        temp_uv = uv;        temp_y2 = y2;        for (j = 0; j &lt; height;j++)        {            for (i = 0; i &lt; width / 2;i++)            {                temp_y2[0] = temp_y[2 * i];//y                temp_y2[1] = temp_uv[2 * i + 1];//v                temp_y2[2] = temp_y[2 * i + 1];//y                temp_y2[3] = temp_uv[2 * i];//u                temp_y2 += 4;            }            temp_y += width;            if (j &amp; 1)            {                temp_uv += width;            }        }        fwrite(y2, 1, frame_size * 2, fou);        printf(&quot;%dth frame ok!!\n&quot;, frame_num);        frame_num++;    }    printf(&quot;NV12 to YVYU successfully!!,total frames: %d\n&quot;, frame_num);    free(y);    y = NULL;    free(y2);    y2 = NULL;    fclose(fin);    fclose(fou);    return 0;}</code></pre><h2 id="3、NV12转YUYV"><a href="#3、NV12转YUYV" class="headerlink" title="3、NV12转YUYV"></a>3、NV12转YUYV</h2><p>NV12toYUYV.c</p><pre><code>#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;int main(int argc, char** argv){    int width, height, frame_size;    FILE *fin, *fou;    char *y, *uv, *y2, *temp_y, *temp_uv, *temp_y2;    int i, j, frame_num = 0;    printf(&quot;\nUsage: NV12toYVYU.exe infile outfile width height\n\n&quot;);    if (argc != 5)    {        return -1;    }    fin = fopen(argv[1], &quot;rb&quot;);    if (fin == NULL)    {        printf(&quot;ERROR: open %s fail\n&quot;, argv[1]);        return -1;    }    fou = fopen(argv[2], &quot;wb&quot;);    if (fou == NULL)    {        printf(&quot;RRROR: open %s fail\n&quot;, argv[2]);        return -1;    }    width = atoi(argv[3]);    height = atoi(argv[4]);    frame_size = width * height;    y = (char *)malloc(frame_size * 3 / 2);//++NV12    if (y == NULL)    {        printf(&quot;ERROR: malloc y fail\n&quot;);        return -1;    }    uv = y + width*height;    y2 = (char *)malloc(frame_size * 2);//++YVYU    if (y2 == NULL)    {        printf(&quot;ERROR: malloc y2 fail\n&quot;);        return -1;    }    while (!feof(fin))    {        int n = 0;        n = fread(y, 1, width*height, fin);        n += fread(uv, 1, width*height &gt;&gt; 1, fin);        if (n != frame_size *3/2)        {            break;        }        temp_y = y;        temp_uv = uv;        temp_y2 = y2;        for (j = 0; j &lt; height;j++)        {            for (i = 0; i &lt; width / 2;i++)            {                temp_y2[0] = temp_y[2 * i];//y                temp_y2[1] = temp_uv[2 * i];//u                temp_y2[2] = temp_y[2 * i + 1];//y                temp_y2[3] = temp_uv[2 * i + 1];//v                temp_y2 += 4;            }            temp_y += width;            if (j &amp; 1)            {                temp_uv += width;            }        }        fwrite(y2, 1, frame_size * 2, fou);        printf(&quot;%dth frame ok!!\n&quot;, frame_num);        frame_num++;    }    printf(&quot;NV12 to YVYU successfully!!,total frames: %d\n&quot;, frame_num);    free(y);    y = NULL;    free(y2);    y2 = NULL;    fclose(fin);    fclose(fou);    return 0;}</code></pre><h2 id="THE-END"><a href="#THE-END" class="headerlink" title=" THE END! "></a><font color="red"> THE END! </font></h2>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 视频处理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Video </tag>
            
            <tag> CSConvert </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>颜色空间转换CSConvert：NV12、NV21、YV12和I420的相互转换</title>
      <link href="/2019/07/13/%E3%80%90Codecs%E7%B3%BB%E5%88%97%E3%80%91%E9%A2%9C%E8%89%B2%E7%A9%BA%E9%97%B4%E8%BD%AC%E6%8D%A2CSConvert%EF%BC%9ANV12%E3%80%81NV21%E3%80%81YV12%E5%92%8CI420%E7%9A%84%E7%9B%B8%E4%BA%92%E8%BD%AC%E6%8D%A2/"/>
      <url>/2019/07/13/%E3%80%90Codecs%E7%B3%BB%E5%88%97%E3%80%91%E9%A2%9C%E8%89%B2%E7%A9%BA%E9%97%B4%E8%BD%AC%E6%8D%A2CSConvert%EF%BC%9ANV12%E3%80%81NV21%E3%80%81YV12%E5%92%8CI420%E7%9A%84%E7%9B%B8%E4%BA%92%E8%BD%AC%E6%8D%A2/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="1、NV12转I420"><a href="#1、NV12转I420" class="headerlink" title="1、NV12转I420"></a>1、NV12转I420</h2><p>NV12toI420.c</p><pre><code>#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;int main(int argc, char** argv){    int width, height;    int frame_size;    FILE *fin, *fou;    char *y, *uv, *u, *v;    int i, frame_num = 0;    char outname[512] = { 0, };    printf(&quot;\nUsage: NV12toI420.exe input.yuv width height\n\n&quot;);    if (argc != 4)    {        return -1;    }    fin = fopen(argv[1], &quot;rb&quot;);    if (fin == NULL)    {        printf(&quot;error:open %s fail\n&quot;, argv[1]);        return -1;    }    width = atoi(argv[2]);    height = atoi(argv[3]);    frame_size = width*height * 3 / 2;//++YUV420    y = (char *)malloc(frame_size);    if (y == NULL)    {        printf(&quot;malloc y fail\n&quot;);        return -1;    }    u = y + width*height;    v = u + width*height / 4;    uv = (char *)malloc(width*height &gt;&gt; 1);    if (uv == NULL)    {        printf(&quot;malloc uv fail\n&quot;);        return -1;    }    memset(outname, 0, sizeof(outname));    sprintf_s(outname, &quot;%s_I420.yuv&quot;, argv[1]);    fou = fopen(outname, &quot;wb&quot;);    if (fou == NULL)    {        printf(&quot;error: open %s fail\n&quot;, outname);        return -1;    }    while (!feof(fin))    {        int n = 0;        n = fread(y, 1, width*height, fin);        n += fread(uv, 1, width*height &gt;&gt; 1, fin);        if (n != frame_size)        {            break;        }        for (i = 0; i &lt; height*width &gt;&gt; 2; i++)        {            u[i] = uv[2 * i + 0];            v[i] = uv[2 * i + 1];        }        fwrite(y, 1, frame_size, fou);        printf(&quot;%dth frame ok!!\n&quot;, frame_num);        frame_num++;    }    printf(&quot;NV12 to I420 successfully!!,total frames: %d\n&quot;, frame_num);    free(y);    y = NULL;    free(uv);    uv = NULL;    fclose(fin);    fclose(fou);    return 0;}</code></pre><h2 id="2、I420转NV21"><a href="#2、I420转NV21" class="headerlink" title="2、I420转NV21"></a>2、I420转NV21</h2><p>I420toNV21.c</p><pre><code>#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;int main(int argc, char** argv){    int width, height;    int frame_size;    FILE *fin, *fou;    char *y, *uv, *u, *v;    int i, frame_num = 0;    char outname[512] = { 0, };    printf(&quot;\nUsage:I420toNV21.exe input.yuv width height\n\n&quot;);    if (argc != 4)    {        return -1;    }    fin = fopen(argv[1], &quot;rb&quot;);    if (fin == NULL)    {        printf(&quot;error:open %s fail\n&quot;, argv[1]);        return -1;    }    width = atoi(argv[2]);    height = atoi(argv[3]);    frame_size = width*height * 3 / 2;//++YUV420    y = (char *)malloc(frame_size);    if (y == NULL)    {        printf(&quot;malloc y fail\n&quot;);        return -1;    }    uv = y + width*height;    u = (char *)malloc(width*height &gt;&gt; 2);    v = (char *)malloc(width*height &gt;&gt; 2);    if (u == NULL || v == NULL)    {        printf(&quot;malloc u or v fail\n&quot;);        return -1;    }    memset(outname, 0, sizeof(outname));    sprintf(outname, &quot;%s_NV21.yuv&quot;, argv[1]);    fou = fopen(outname, &quot;wb&quot;);    if (fou == NULL)    {        printf(&quot;error: open %s fail\n&quot;, outname);        return -1;    }    while (!feof(fin))    {        int n = 0;        n = fread(y, 1, width*height, fin);        n += fread(u, 1, width*height &gt;&gt; 2, fin);        n += fread(v, 1, width*height &gt;&gt; 2, fin);        if (n != frame_size)        {            break;        }        for (i = 0; i &lt; height*width &gt;&gt; 2; i++)        {            uv[2 * i + 0] = v[i]; // v            uv[2 * i + 1] = u[i]; // u        }        fwrite(y, 1, height*width, fou);        fwrite(uv, 1, height*width &gt;&gt; 1, fou);        printf(&quot;%dth frame ok!!\n&quot;, frame_num);        frame_num++;    }    printf(&quot;I420 to NV21 successfully!!, total frames: %d\n&quot;, frame_num);    free(y);    y = NULL;    free(u);    u = NULL;    free(v);    v = NULL;    fclose(fin);    fclose(fou);    return 0;}</code></pre><h2 id="3、NV12转YV12"><a href="#3、NV12转YV12" class="headerlink" title="3、NV12转YV12"></a>3、NV12转YV12</h2><p>NV21toYV12.c</p><pre><code>#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;int main(int argc, char** argv){    int width, height;    int frame_size;    FILE *fin, *fou;    char *y, *uv, *u, *v;    int i, frame_num = 0;    char outname[512] = { 0, };    printf(&quot;\nUsage: NV21toYV12.exe input.yuv width height\n\n&quot;);    if (argc != 4)    {        return -1;    }    fin = fopen(argv[1], &quot;rb&quot;);    if (fin == NULL)    {        printf(&quot;error:open %s fail\n&quot;, argv[1]);        return -1;    }    width = atoi(argv[2]);    height = atoi(argv[3]);    frame_size = width*height * 3 / 2;//++YUV420    y = (char *)malloc(frame_size);    if (y == NULL)    {        printf(&quot;malloc y fail\n&quot;);        return -1;    }    v = y + width*height;    u = v + width*height / 4;    uv = (char *)malloc(width*height &gt;&gt; 1);    if (uv == NULL)    {        printf(&quot;malloc uv fail\n&quot;);        return -1;    }    memset(outname, 0, sizeof(outname));    sprintf_s(outname, &quot;%s_YV12.yuv&quot;, argv[1]);    fou = fopen(outname, &quot;wb&quot;);    if (fou == NULL)    {        printf(&quot;error: open %s fail\n&quot;, outname);        return -1;    }    while (!feof(fin))    {        int n = 0;        n = fread(y, 1, width*height, fin);        n += fread(uv, 1, width*height &gt;&gt; 1, fin);        if (n != frame_size)        {            break;        }        for (i = 0; i &lt; height*width &gt;&gt; 2; i++)        {            v[i] = uv[2 * i + 0];// v            u[i] = uv[2 * i + 1];// u        }        fwrite(y, 1, frame_size, fou);        printf(&quot;%dth frame ok!!\n&quot;, frame_num);        frame_num++;    }    printf(&quot;NV21 to YV12 successfully!!,total frames: %d\n&quot;, frame_num);    free(y);    y = NULL;    free(uv);    uv = NULL;    fclose(fin);    fclose(fou);    return 0;}</code></pre><h2 id="4、NV12转YV12"><a href="#4、NV12转YV12" class="headerlink" title="4、NV12转YV12"></a>4、NV12转YV12</h2><p>NV12toYV12.c</p><pre><code>#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;int main(int argc, char** argv){    int width, height;    int frame_size;    FILE *fin, *fou;    char *y, *uv, *u, *v;    int i, frame_num = 0;    char outname[512] = { 0, };    printf(&quot;\nUsage:NV12toYV12.exe input.yuv width height\n\n&quot;);    if (argc != 4)    {        return -1;    }    fin = fopen(argv[1], &quot;rb&quot;);    if (fin == NULL)    {        printf(&quot;error:open %s fail\n&quot;, argv[1]);        return -1;    }    width = atoi(argv[2]);    height = atoi(argv[3]);    frame_size = width*height * 3 / 2;//++YUV420    y = (char *)malloc(frame_size);    if (y ==NULL)    {        printf(&quot;malloc y fail\n&quot;);        return -1;    }    v = y + width*height;    u = v + width*height / 4;    uv = (char *)malloc(width*height &gt;&gt; 1);    if (uv == NULL)    {        printf(&quot;malloc uv fail\n&quot;);        return -1;    }    memset(outname, 0, sizeof(outname));    sprintf_s(outname, &quot;%s_YV12.yuv&quot;, argv[1]);    fou = fopen(outname, &quot;wb&quot;);    if (fou == NULL)    {        printf(&quot;error: open %s fail\n&quot;, outname);        return -1;    }    while (!feof(fin))    {        int n = 0;        n = fread(y, 1, width*height, fin);        n += fread(uv, 1, width*height &gt;&gt; 1, fin);        if (n != frame_size)        {            break;        }        for (i = 0; i &lt; height*width &gt;&gt; 2;i++)        {            u[i] = uv[2 * i + 0];            v[i] = uv[2 * i + 1];        }        fwrite(y, 1, frame_size, fou);        printf(&quot;%dth frame ok!!\n&quot;, frame_num);        frame_num++;    }    printf(&quot;NV12 to YV12 successfully!!,total frames: %d\n&quot;, frame_num);    free(y);    y = NULL;    free(uv);    uv = NULL;    fclose(fin);    fclose(fou);    return 0;}</code></pre><h2 id="5、I420转NV12"><a href="#5、I420转NV12" class="headerlink" title="5、I420转NV12"></a>5、I420转NV12</h2><p>I420toNV12.c</p><pre><code>#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;int main(int argc, char** argv){    int width, height;    int frame_size;    FILE *fin, *fou;    char *y, *uv, *u, *v;    int i, frame_num = 0;    char outname[512] = { 0, };    printf(&quot;\nUsage:I420toNV12.exe input.yuv width height\n\n&quot;);    if (argc != 4)    {        return -1;    }    fin = fopen(argv[1], &quot;rb&quot;);    if (fin == NULL)    {        printf(&quot;error:open %s fail\n&quot;, argv[1]);        return -1;    }    width = atoi(argv[2]);    height = atoi(argv[3]);    frame_size = width*height * 3 / 2;//++YUV420    y = (char *)malloc(frame_size);    if (y == NULL)    {        printf(&quot;malloc y fail\n&quot;);        return -1;    }    uv = y + width*height;    u = (char *)malloc(width*height &gt;&gt; 2);    v = (char *)malloc(width*height &gt;&gt; 2);    if (u == NULL || v == NULL)    {        printf(&quot;malloc u or v fail\n&quot;);        return -1;    }    memset(outname, 0, sizeof(outname));    sprintf_s(outname, &quot;%s_NV12.yuv&quot;, argv[1]);    fou = fopen(outname, &quot;wb&quot;);    if (fou == NULL)    {        printf(&quot;error: open %s fail\n&quot;, outname);        return -1;    }    while (!feof(fin))    {        int n = 0;        n = fread(y, 1, width*height, fin);        n += fread(u, 1, width*height &gt;&gt; 2, fin);        n += fread(v, 1, width*height &gt;&gt; 2, fin);        if (n != frame_size)        {            break;        }        for (i = 0; i &lt; height*width &gt;&gt; 2; i++)        {             uv[2 * i + 0] = u[i];             uv[2 * i + 1] = v[i];        }        fwrite(y, 1, height*width, fou);        fwrite(uv, 1, height*width &gt;&gt; 1, fou);        printf(&quot;%dth frame ok!!\n&quot;, frame_num);        frame_num++;    }    printf(&quot;I420 to NV12 successfully!!, total frames: %d\n&quot;,frame_num);    free(y);    y = NULL;    free(u);    u = NULL;    free(v);    v = NULL;    fclose(fin);    fclose(fou);    return 0;}</code></pre><h2 id="6、I420转YV12"><a href="#6、I420转YV12" class="headerlink" title="6、I420转YV12"></a>6、I420转YV12</h2><p>I420toYV12.c</p><pre><code>#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;int main(int argc, char** argv){    int width, height;    int frame_size;    FILE *fin, *fou;    char *y, *u, *v,*u1,*v1;    int i, frame_num = 0;    char outname[512] = { 0, };    printf(&quot;\nUsage:I420toYV12.exe input.yuv width height\n\n&quot;);    if (argc != 4)    {        return -1;    }    fin = fopen(argv[1], &quot;rb&quot;);    if (fin == NULL)    {        printf(&quot;error:open %s fail\n&quot;, argv[1]);        return -1;    }    width = atoi(argv[2]);    height = atoi(argv[3]);    frame_size = width*height * 3 / 2;    y = (char *)malloc(frame_size);    if (y == NULL)    {        printf(&quot;malloc y fail\n&quot;);        return -1;    }    v = y + width*height;    u = v + width*height/4;    u1 = (char *)malloc(width*height &gt;&gt; 2);    v1 = (char *)malloc(width*height &gt;&gt; 2);    if (u1 == NULL || v1== NULL)    {        printf(&quot;malloc u1 or v1 fail\n&quot;);        return -1;    }    memset(outname, 0, sizeof(outname));    sprintf_s(outname, &quot;%s_YV12.yuv&quot;, argv[1]);    fou = fopen(outname, &quot;wb&quot;);    if (fou == NULL)    {        printf(&quot;error: open %s fail\n&quot;, outname);        return -1;    }    while (!feof(fin))    {        int n = 0;        n = fread(y, 1, width*height, fin);        n += fread(u1, 1, width*height &gt;&gt; 2, fin);        n += fread(v1, 1, width*height &gt;&gt; 2, fin);        if (n != frame_size)        {            break;        }        for (i = 0; i &lt; height*width &gt;&gt; 2; i++)        {            v[i] = v1[i];            u[i] = u1[i];        }        fwrite(y, 1, frame_size, fou);        printf(&quot;%dth frame ok!!\n&quot;, frame_num);        frame_num++;    }    printf(&quot;I420 to YV12 successfully!!,total frames: %d\n&quot;,frame_num);    free(y);    y = NULL;    free(u1);    u1 = NULL;    free(v1);    v1 = NULL;    fclose(fin);    fclose(fou);    return 0;}</code></pre><h2 id="THE-END"><a href="#THE-END" class="headerlink" title=" THE END! "></a><font color="red"> THE END! </font></h2>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 视频处理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Video </tag>
            
            <tag> CSConvert </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>颜色空间转换CSConvert：YUV420P(I420)转NV12</title>
      <link href="/2019/07/13/%E3%80%90Codecs%E7%B3%BB%E5%88%97%E3%80%91%E9%A2%9C%E8%89%B2%E7%A9%BA%E9%97%B4%E8%BD%AC%E6%8D%A2CSConvert%EF%BC%9AYUV420P(I420)%E8%BD%ACNV12/"/>
      <url>/2019/07/13/%E3%80%90Codecs%E7%B3%BB%E5%88%97%E3%80%91%E9%A2%9C%E8%89%B2%E7%A9%BA%E9%97%B4%E8%BD%AC%E6%8D%A2CSConvert%EF%BC%9AYUV420P(I420)%E8%BD%ACNV12/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="1、颜色空间I420和NV12说明"><a href="#1、颜色空间I420和NV12说明" class="headerlink" title="1、颜色空间I420和NV12说明"></a>1、颜色空间I420和NV12说明</h2><p>I420即常用的YUV420P格式，YUV存储按照Y\U\V三个平面顺序存放。<br>NV12是YUV420sp的格式，Y分量占用一个平面，UV分量交错存放占用一个平面。</p><h2 id="2、I420转NV12实现"><a href="#2、I420转NV12实现" class="headerlink" title="2、I420转NV12实现"></a>2、I420转NV12实现</h2><p>I420toNV12.c</p><pre><code>#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;int main(int argc, char** argv){    int width, height;    int frame_size;    FILE *fin, *fou;    char *y, *uv, *u, *v;    int i;    char outname[512] = { 0, };    printf(&quot;\nUsage:I420toNV12.exe input.yuv width height\n\n&quot;);    if (argc != 4)    {        return -1;    }    fin = fopen(argv[1], &quot;rb&quot;);    if (fin == NULL)    {        printf(&quot;error:open %s fail\n&quot;, argv[1]);        return -1;    }    width = atoi(argv[2]);    height = atoi(argv[3]);    frame_size = width*height * 3 / 2;//++YUV420    y = (char *)malloc(frame_size);    if (y == NULL)    {        printf(&quot;malloc y fail\n&quot;);        return -1;    }    uv = y + width*height;    u = (char *)malloc(width*height &gt;&gt; 2);    v = (char *)malloc(width*height &gt;&gt; 2);    if (u == NULL || v == NULL)    {        printf(&quot;malloc u or v fail\n&quot;);        return -1;    }    memset(outname, 0, sizeof(outname));    sprintf_s(outname, &quot;%s_NV12.yuv&quot;, argv[1]);    fou = fopen(outname, &quot;wb&quot;);    if (fou == NULL)    {        printf(&quot;error: open %s fail\n&quot;, outname);        return -1;    }    while (!feof(fin))    {        int n = 0;        n = fread(y, 1, width*height, fin);        n += fread(u, 1, width*height &gt;&gt; 2, fin);        n += fread(v, 1, width*height &gt;&gt; 2, fin);        if (n != frame_size)        {            break;        }        for (i = 0; i &lt; height*width &gt;&gt; 2; i++)        {             uv[2 * i + 0] = u[i];             uv[2 * i + 1] = v[i];        }        fwrite(y, 1, height*width, fou);        fwrite(uv, 1, height*width &gt;&gt; 1, fou);    }    printf(&quot;I420 to NV12 successfully!&quot;);    free(y);    free(u);    free(v);    fclose(fin);    fclose(fou);    return 0;}</code></pre><h2 id="THE-END"><a href="#THE-END" class="headerlink" title=" THE END! "></a><font color="red"> THE END! </font></h2>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 视频处理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Video </tag>
            
            <tag> CSConvert </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>颜色空间转换CSConvert：RGB24转YUV420</title>
      <link href="/2019/07/12/%E3%80%90Codecs%E7%B3%BB%E5%88%97%E3%80%91%E9%A2%9C%E8%89%B2%E7%A9%BA%E9%97%B4%E8%BD%AC%E6%8D%A2CSConvert%EF%BC%9ARGB24%E8%BD%ACYUV420P/"/>
      <url>/2019/07/12/%E3%80%90Codecs%E7%B3%BB%E5%88%97%E3%80%91%E9%A2%9C%E8%89%B2%E7%A9%BA%E9%97%B4%E8%BD%AC%E6%8D%A2CSConvert%EF%BC%9ARGB24%E8%BD%ACYUV420P/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="1、参考"><a href="#1、参考" class="headerlink" title="1、参考"></a>1、参考</h2><p><a href="https://www.cnblogs.com/zhengjianhong/p/7872459.html" target="_blank" rel="noopener">总结各种RGB转YUV的转换公式</a><br><a href="https://www.cnblogs.com/DdiAgnes/articles/5288340.html" target="_blank" rel="noopener">RGB24转YUV422转换算法</a><br><a href="https://www.cnblogs.com/poissonnotes/p/7326167.html" target="_blank" rel="noopener">RGB24转YUV420</a><br><a href="https://blog.csdn.net/mshgocn/article/details/82428634" target="_blank" rel="noopener">总结各种RGB转YUV的转换公式</a><br><a href="https://blog.csdn.net/junzia/article/details/54707322" target="_blank" rel="noopener">Android视频编码——RGBA、RGB、BGRA、BGR转YUV420P、YUV420SP</a><br><a href="http://wss.co.uk/pinknoise/yuv2rgb/" target="_blank" rel="noopener">YUV2RGB</a><br><a href="https://www.xuebuyuan.com/1918823.html" target="_blank" rel="noopener">YUV420P转换为RGB32格式</a><br><a href="https://www.cnblogs.com/luoyinjie/p/7219319.html" target="_blank" rel="noopener">YUV与RGB互转各种公式 (YUV与RGB的转换公式有很多种，请注意区别！！！)</a><br><a href="https://blog.csdn.net/subfate/article/details/47305147" target="_blank" rel="noopener">YUV格式学习：YUV420P、YV12、NV12、NV21格式转换成RGB24</a><br><a href="https://www.cnblogs.com/qinjunni/archive/2012/04/06/2434393.html" target="_blank" rel="noopener">YUV / RGB 格式及快速转换算法 YUV RGB 转换公式</a></p><h2 id="2、视频颜色空间标准BT601-BT709差异"><a href="#2、视频颜色空间标准BT601-BT709差异" class="headerlink" title="2、视频颜色空间标准BT601/BT709差异"></a>2、视频颜色空间标准BT601/BT709差异</h2><p>参考：<a href="https://blog.csdn.net/SoaringLee_fighting/article/details/88790371" target="_blank" rel="noopener">【Codecs系列】视频格式国际标准：BT601/BT709/BT2020</a></p><p>BT.601格式的颜色空间转换：</p><pre><code>    //YUV---&gt;RGB    //R = 1.164(Y - 16) + 1.596(V - 128)    //G = 1.164(Y - 16) - 0.813(V - 128) - 0.391(U - 128)    //B = 1.164(Y - 16)                  + 2.018(U - 128)    //RGB---&gt;YUV    //Y = 16  + 0.257 * R + 0.504 * G + 0.098 *B              //U = 128 - 0.148 * R - 0.291 * G + 0.439 * B              //V = 128 + 0.439 * R - 0.368 * G - 0.071 * B</code></pre><p>BT.709格式的颜色空间转换：</p><pre><code>   // RGB---&gt;YUV   //  Y = 16  + 0.183 * R + 0.614 * G + 0.062 * B                 // Cb = 128 - 0.101 * R - 0.339 * G + 0.439 * B                // Cr = 128 + 0.439 * R - 0.399 * G - 0.040 * B            // YUV---&gt;RGB        //  R = 1.164 *(Y - 16) + 1.792 *(Cr - 128)                      //  G = 1.164 *(Y - 16) - 0.213 *(Cb - 128) - 0.534 *(Cr - 128)   //  B = 1.164 *(Y - 16) + 2.114 *(Cb - 128)                  </code></pre><h2 id="3、YUV420P转BGR24"><a href="#3、YUV420P转BGR24" class="headerlink" title="3、YUV420P转BGR24"></a>3、YUV420P转BGR24</h2><pre><code class="c">/*********************************************************************/* Function: YUV420pToBGR24/* Usage: colorspace convertion from YUV420P(I420) to BGR24/* Parameters:/*     pYUV   [In]        - source YUV data/*    pBGR24 [Out]    - output RGB data/*  width  [In]        - image width/*    height [In]        - image height/*/* Modified: 2019.7.13/*********************************************************************/int YUV420pToBGR24(unsigned char *pYUV, unsigned char *pBGR24, int width, int height){    int bgr[3];    int i,j,k;    int yIdx, uIdx, vIdx, idx;    int len = width * height;    if(!pYUV || !pBGR24 || width &lt; 1 || height &lt; 1)       return -1;    unsigned char* yData = pYUV;    unsigned char* uData = &amp;yData[len];    unsigned char* vData = &amp;uData[len&gt;&gt;2];    for(i = 0; i &lt; height; i++)    {       for(j = 0; j &lt; width; j++)         {           yIdx = i*width+j;           vIdx = (i/2)*(width/2)+(j/2);           uIdx = vIdx;          // BT. 601           bgr[0] = (298*(yData[yIdx] - 16) + 517 * (uData[uIdx] - 128) + (1&lt;&lt;7)) &gt;&gt; 8; // b分量值           bgr[1] = (298*(yData[yIdx] - 16) - 208 * (vData[vIdx] - 128) - 100 * (uData[uIdx] - 128) + (1&lt;&lt;7))&gt;&gt;8;// g分量值           bgr[2] = (298*(yData[yIdx] - 16) + 409 * (vData[vIdx] - 128) + (1&lt;&lt;7))&gt;&gt;8; // r分量值         for(k=0; k&lt;3; k++)         {            idx = (i*width+j)*3+k;            pBGR24[idx] = CLIP_COLOR(bgr[k]);         }      }    }    return 0;}</code></pre><h2 id="4、BGR24转YUV420P"><a href="#4、BGR24转YUV420P" class="headerlink" title="4、BGR24转YUV420P"></a>4、BGR24转YUV420P</h2><pre><code class="c">/*********************************************************************/* Function: BGR24toYUV420P/* Usage: colorspace convertion from BGR24 to YUV420P(I420)/* Parameters:/*     pBGR24  [In]        - source RGB data/*    pYUV    [Out]        - output YUV data/*  width   [In]        - image width/*    height  [In]        - image height/*/* Modified: 2019.7.13/*********************************************************************/int BGR24toYUV420P(unsigned char *pBGR24, unsigned char *pYUV, int width, int height){    int i,j,index;    unsigned char *bufY, *bufU, *bufV, *bufRGB;    unsigned char y, u, v, r, g, b;    if(!pYUV || !pBGR24 || width &lt; 1 || height &lt; 1)       return -1;    memset(pYUV, 0 ,width*height*3/2*sizeof(unsigned char));    bufY = pYUV;    bufU = bufY + width*height;    bufV = bufU + (width*height*1/4);    for(j=0; j &lt; height; j++)    {          bufRGB = pBGR24 + width*j*3;      for(i=0; i &lt; width; i++)       {         index = j*width+i;         b = *(bufRGB++);         g = *(bufRGB++);         r = *(bufRGB++);         y = (unsigned char)((66  * r + 129 * g + 25  * b + 128) &gt;&gt; 8) + 16;         u = (unsigned char)((-38 * r - 74  * g + 112 * b + 128) &gt;&gt; 8) + 128;         v = (unsigned char)((112 * r - 94  * g - 18  * b + 128) &gt;&gt; 8) + 128;         *(bufY++) = CLIP_COLOR(y);         if(j%2==0 &amp;&amp; index%2==0)          {                *(bufU++) = CLIP_COLOR(u);              *(bufV++) = CLIP_COLOR(v);          }       }    }    return 0;}</code></pre><h2 id="5、测试Demo"><a href="#5、测试Demo" class="headerlink" title="5、测试Demo"></a>5、测试Demo</h2><pre><code class="c">//Demo: This demo used to test YUV2BGR and BGR2YUVint main(int argc, char *argv[]){    FILE *fin, *fou;    unsigned char *pInYUVBuf, *pYBuf, *pUBuf, *pVBuf;    unsigned char *pBGRBuf;    int index, framesize;    if (argc &lt; 4)    {        printf(&quot;Usage: ./BGR24toYUV420P.exe inputYUV outputYUV width height\n&quot;);        return -1;    }    char* input = argv[1];    char* output = argv[2];    int width = atoi(argv[3]);    int height = atoi(argv[4]);    Mat mBGR_to_show = Mat(height, width, CV_8UC3);    fin = fopen(input, &quot;rb&quot;);    if(NULL == fin)    {        printf(&quot;[demo] error: open fin failed!!!\n&quot;);        return -1;    }    fou = fopen(output, &quot;wb&quot;);    if(NULL == fou)    {        printf(&quot;[demo] error: open fou failed!!!\n&quot;);        return -1;    }    pInYUVBuf = (unsigned char*) malloc(width*height*3/2); // YUV buffer    if(NULL == pInYUVBuf)    {        printf(&quot;[demo] error: open pInYUVBuffer failed!!!\n&quot;);        return -1;    }    pYBuf = pInYUVBuf;    pUBuf = pYBuf + width*height;    pVBuf = pUBuf + width*height/4;    framesize = width*height*3/2;    pBGRBuf = (unsigned char*) malloc(width*height*3); // BGR buffer    if(NULL == pBGRBuf)    {        printf(&quot;[demo] error: open pBGRBuf failed!!!\n&quot;);        return -1;    }    index = 0;    while(framesize == fread(pInYUVBuf,1,width*height*3/2,fin))    {        YUV420pToBGR24(pInYUVBuf, pBGRBuf, width, height);        memcpy(mBGR_to_show.data, pBGRBuf, sizeof(unsigned char)*width*height*3);        namedWindow(&quot;RGB&quot;, CV_WINDOW_NORMAL);        imshow(&quot;RGB&quot;, mBGR_to_show);        waitKey(2);        BGR24toYUV420P(pBGRBuf, pInYUVBuf, width, height);        fwrite(pInYUVBuf, 1, width*height*3/2, fou);        index++;        printf(&quot;[demo] info: %d frame process ok!!!\n&quot;, index);    }    system(&quot;pause&quot;);    return 0;   }</code></pre><h2 id="6、效果图"><a href="#6、效果图" class="headerlink" title="6、效果图"></a>6、效果图</h2><p><img src="/img/20190713203014665-.png" alt="测试Demo运行过程"></p><p><img src="/img/20190713201956132-.png" alt="YUV比较"></p><h2 id="7、分析"><a href="#7、分析" class="headerlink" title="7、分析"></a>7、分析</h2><p>将YUV420P转换成BGR24，然后再转换到YUV420P，会有一定的损失，转换的后的YUV与原始YUV会有1~5个像素值的差异 。</p><hr><h2 id="THE-END"><a href="#THE-END" class="headerlink" title=" THE  END!"></a><font color="red"> THE  END!</font></h2>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 视频处理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Video </tag>
            
            <tag> CSConvert </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于颜色空间转换的一个思考</title>
      <link href="/2019/07/12/%E3%80%90Codecs%E7%B3%BB%E5%88%97%E3%80%91%E5%85%B3%E4%BA%8E%E9%A2%9C%E8%89%B2%E7%A9%BA%E9%97%B4%E8%BD%AC%E6%8D%A2%E7%9A%84%E4%B8%80%E4%B8%AA%E6%80%9D%E8%80%83/"/>
      <url>/2019/07/12/%E3%80%90Codecs%E7%B3%BB%E5%88%97%E3%80%91%E5%85%B3%E4%BA%8E%E9%A2%9C%E8%89%B2%E7%A9%BA%E9%97%B4%E8%BD%AC%E6%8D%A2%E7%9A%84%E4%B8%80%E4%B8%AA%E6%80%9D%E8%80%83/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="1、思考点"><a href="#1、思考点" class="headerlink" title="1、思考点"></a>1、思考点</h2><p>从YUV转换到RGB（比如YUV图片保存成bmp图像），再将RGB转换成灰度图gray，那么灰度图gray与YUV中亮度分量Y有差异吗？差异有多大？</p><h2 id="2、验证"><a href="#2、验证" class="headerlink" title="2、验证"></a>2、验证</h2><h3 id="2-1、-YUV转换成RGB再转换成gray图："><a href="#2-1、-YUV转换成RGB再转换成gray图：" class="headerlink" title="2.1、 YUV转换成RGB再转换成gray图："></a>2.1、 YUV转换成RGB再转换成gray图：</h3><p>代码： <a href="https://blog.csdn.net/SoaringLee_fighting/article/details/80572275" target="_blank" rel="noopener">【Codecs】颜色空间转换CSconvert：YUV420PtoRGB24</a><br><img src="/img/20191019213830629.png" alt="YUV转换成RGB再转换成gray图"></p><h3 id="2-2、-YUV中的亮度分量Y"><a href="#2-2、-YUV中的亮度分量Y" class="headerlink" title="2.2、  YUV中的亮度分量Y:"></a>2.2、  YUV中的亮度分量Y:</h3><p>代码：<a href="https://blog.csdn.net/SoaringLee_fighting/article/details/102643662" target="_blank" rel="noopener">【Codecs系列】颜色空间转换CSConvert：YUV420P转MonoY</a><br><img src="/img/20191019213848341.png" alt="YUV中的亮度分量Y"></p><h3 id="2-3、-两者之间的差异比较："><a href="#2-3、-两者之间的差异比较：" class="headerlink" title="2.3、 两者之间的差异比较："></a>2.3、 两者之间的差异比较：</h3><p><img src="/img/20191019214404824.png" alt="灰度分量和色度分量差异比较"></p><h2 id="3、分析"><a href="#3、分析" class="headerlink" title="3、分析"></a>3、分析</h2><p>从比较可知，灰度分量Gray和亮度分量Y之间的差异很小，只有一个像素值的大小差异，这个差异是由于YUV转换到RGB时造成。</p><hr><h4 id="THE-END"><a href="#THE-END" class="headerlink" title=" THE  END! "></a><font color="red"> <strong>THE  END!</strong> </font></h4>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 视频处理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Video </tag>
            
            <tag> CSConvert </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2019年阅读书单</title>
      <link href="/2019/07/11/%E3%80%90Books%E7%B3%BB%E5%88%97%E3%80%912019%E5%B9%B4%E9%98%85%E8%AF%BB%E4%B9%A6%E5%8D%95/"/>
      <url>/2019/07/11/%E3%80%90Books%E7%B3%BB%E5%88%97%E3%80%912019%E5%B9%B4%E9%98%85%E8%AF%BB%E4%B9%A6%E5%8D%95/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="2019年阅读书单"><a href="#2019年阅读书单" class="headerlink" title="2019年阅读书单"></a>2019年阅读书单</h2><p>1、读好书，读完6本书，做好读书笔记。</p><h3 id="1、文学"><a href="#1、文学" class="headerlink" title="1、文学"></a>1、文学</h3><table><thead><tr><th>书籍</th><th>状态</th></tr></thead><tbody><tr><td>《好吗好的》</td><td>已读</td></tr><tr><td>《我不》</td><td>已读</td></tr><tr><td>《你坏》</td><td>已读</td></tr><tr><td>《白夜行》</td><td><font color="red">未读</font></td></tr><tr><td>《活着》</td><td>已读</td></tr><tr><td>《局外人》</td><td>已读</td></tr><tr><td>《摆渡人》</td><td><font color="red">未读</font></td></tr><tr><td>《走到人生边上》</td><td>已读</td></tr></tbody></table><h3 id="2、商业"><a href="#2、商业" class="headerlink" title="2、商业"></a>2、商业</h3><table><thead><tr><th>书籍</th><th>状态</th></tr></thead><tbody><tr><td>《新物种爆炸》</td><td>已读</td></tr></tbody></table><h3 id="3、心理学"><a href="#3、心理学" class="headerlink" title="3、心理学"></a>3、心理学</h3><table><thead><tr><th>书籍</th><th>状态</th></tr></thead><tbody><tr><td>《读心术》</td><td><font color="red">进行中</font></td></tr></tbody></table><h3 id="4、历史"><a href="#4、历史" class="headerlink" title="4、历史"></a>4、历史</h3><table><thead><tr><th>书籍</th><th>状态</th></tr></thead><tbody><tr><td>《人类简史》</td><td><font color="red">未读</font></td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 读书 </category>
          
          <category> 书单 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Books </tag>
            
            <tag> ReadingList </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图像直方图均衡化原理和算法实现</title>
      <link href="/2019/07/08/%E3%80%90CV%E7%B3%BB%E5%88%97%E3%80%91%E5%9B%BE%E5%83%8F%E7%9B%B4%E6%96%B9%E5%9B%BE%E5%9D%87%E8%A1%A1%E5%8C%96%E5%8E%9F%E7%90%86%E5%92%8C%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0/"/>
      <url>/2019/07/08/%E3%80%90CV%E7%B3%BB%E5%88%97%E3%80%91%E5%9B%BE%E5%83%8F%E7%9B%B4%E6%96%B9%E5%9B%BE%E5%9D%87%E8%A1%A1%E5%8C%96%E5%8E%9F%E7%90%86%E5%92%8C%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="1、参考"><a href="#1、参考" class="headerlink" title="1、参考"></a>1、参考</h2><p><a href="https://blog.csdn.net/fengxianghui01/article/details/85107273" target="_blank" rel="noopener">C语言实现BMP图像处理（直方图均衡化）</a><br><a href="https://blog.csdn.net/zhangbei_/article/details/47680411" target="_blank" rel="noopener">直方图均衡化的编程实现</a><br><a href="https://blog.csdn.net/thecentry/article/details/80348625" target="_blank" rel="noopener">直方图均衡化—算法分析与编程实现（opencv与c++）</a></p><h2 id="2、直方图和直方图均衡化原理"><a href="#2、直方图和直方图均衡化原理" class="headerlink" title="2、直方图和直方图均衡化原理"></a>2、直方图和直方图均衡化原理</h2><p><strong>直方图</strong>：是图像中像素强度分布的图形表达方式。<br><strong>直方图均衡化</strong>：把原始图像的灰度直方图从比较集中的某个灰度区间变成在全部灰度范围内的均匀分布。直方图均衡化就是对图像进行非线性拉伸，重新分配图像像素值，使一定灰度范围内的像素数量大致相同。直方图均衡化就是把给定图像的直方图分布改变成“均匀”分布直方图分布。<br>算法步骤：<br>(1)根据图像灰度计算灰度密度函数PDF.<br>(2)计算积累分布函数CDF。(cumulative distribution function)<br>(3)将CDF归一化到原图取值范围[0,255]。<br>(4)将CDF四舍五入取整，得到灰度转换函数SK=T(CK)。<br>(5)把原图像素点值为rk的变换为sk。</p><p>PDF的算法：gk = EQ(fk) = (ni/n) = pf(fi) ，ni表示第K个灰度级的像素点个数。n表示图像的像素点总数。<br>CDF的算法：<img src="/img/20190708191632161.png" alt="CDF的算法">。</p><p>灰度转化函数：sk=255*ck/k</p><h2 id="3、直方图均衡化算法实现"><a href="#3、直方图均衡化算法实现" class="headerlink" title="3、直方图均衡化算法实现"></a>3、直方图均衡化算法实现</h2><h3 id="3-1、OpenCV实现"><a href="#3-1、OpenCV实现" class="headerlink" title="3.1、OpenCV实现"></a>3.1、OpenCV实现</h3><pre><code class="c">#include &quot;opencv2/highgui/highgui.hpp&quot;#include &quot;opencv2/imgproc/imgproc.hpp&quot;#include &lt;iostream&gt;#include &lt;stdio.h&gt;#define SIGLE_CHANNEL 1using namespace cv;using namespace std;/**  @function main */int main( int argc, char** argv ){  Mat src, dst;  int i;  char* source_window = &quot;Source image&quot;;  char* equalized_window = &quot;Equalized Image&quot;;  /// 加载源图像  src = imread( argv[1], 1 );  if( !src.data )    { cout&lt;&lt;&quot;Usage: ./Histogram_Demo &lt;path_to_image&gt;&quot;&lt;&lt;endl;      return -1;}#if SIGLE_CHANNEL  /// 转为灰度图  cvtColor( src, src, CV_BGR2GRAY );  /// 应用直方图均衡化  equalizeHist( src, dst );#else  std::vector&lt;Mat&gt;splitBGR(src.channels());  split(src, splitBGR);//图像通道分离  for (i = 0; i &lt; src.channels(); i++)  {    equalizeHist(splitBGR[i], splitBGR[i]);//图像灰度均衡化  }  merge(splitBGR, dst);#endif  /// 显示结果  namedWindow( source_window, CV_WINDOW_AUTOSIZE );  namedWindow( equalized_window, CV_WINDOW_AUTOSIZE );  imshow( source_window, src );  imshow( equalized_window, dst );  /// 等待用户按键退出程序  waitKey(0);  return 0;}</code></pre><p>效果图如下：<br>（1）灰度图<br><img src="/img/2019081020574734-.png" alt="灰度图"></p><p>（2）彩色图<br><img src="/img/20190810205958379-.png" alt="彩色图"></p><h3 id="3-2、C实现"><a href="#3-2、C实现" class="headerlink" title="3.2、C实现"></a>3.2、C实现</h3><pre><code class="c">// 计算图像直方图void Hist(const uint8 *image, int width, int height, int pitch, int hist[]){    memset((void*)hist, 0, 256 * sizeof(int));    for(int ver = 0; ver &lt; height; ++ver) {        for(int hor = 0; hor &lt; width; ++hor) {            int offset = ver * pitch + hor;            ++hist[*(image+offset)];        }    }}// 求直方图均衡化的映射表void MapTable(int hist[], uint8 map_table[], int num){    int sum = 0;    for(int i = 0; i &lt; 256; ++i) {        sum += hist[i];        map_table[i] = int(255 * sum / num + 0.5);    }}void EqualizeHist(const uint8 *src, uint8 *dst, int width, int height, int pitch){    int hist[256] = {0};    uint8 map_table[256] = {0};    Hist(src, width, height, pitch, hist);    MapTable(hist, map_table, width * height);    for(int ver = 0; ver &lt; height; ++ver) {        for(int hor = 0; hor &lt; width; ++hor) {            int offset = ver * pitch + hor;            *(dst + offset) = map_table[*(src + offset)];        }    }}</code></pre><p>效果图如下：<br><img src="/img/20190810215106327-.png" alt="效果图1"></p><p><img src="/img/20190810215154848-.png" alt="效果图2"></p><hr><h2 id="THE-END"><a href="#THE-END" class="headerlink" title=" THE  END! "></a><font color="red"> <strong>THE  END!</strong> </font></h2>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 图像处理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CV </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《新物种爆炸》读书笔记</title>
      <link href="/2019/06/29/%E3%80%90Books%E7%B3%BB%E5%88%97%E3%80%912019%E5%B9%B4%E7%AC%AC%E4%B8%89%E6%9C%AC%E4%B9%A6%EF%BC%9A%E3%80%8A%E6%96%B0%E7%89%A9%E7%A7%8D%E7%88%86%E7%82%B8%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
      <url>/2019/06/29/%E3%80%90Books%E7%B3%BB%E5%88%97%E3%80%912019%E5%B9%B4%E7%AC%AC%E4%B8%89%E6%9C%AC%E4%B9%A6%EF%BC%9A%E3%80%8A%E6%96%B0%E7%89%A9%E7%A7%8D%E7%88%86%E7%82%B8%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>&ensp; &ensp;  2019年初，立下了2019年的奋斗目标和方向。第二条：读好书，读完6本书，做好读书笔记。前两本书读了感情励志类的故事和小说，第三本读了下面的这本书，读的很吃力（很困），书中涉及到了很多新概念和新事物，对现在这个时代的技术发展做了很多独到的剖析，很有洞察力。或许这种商业思维方面的书需要多次阅读的，每次读应该都有不同的感受和发现吧。</p><p><img src="/img/20190629201202620-.png" alt="《新物种爆炸--认知升级时代的新商业思维》"></p><h2 id="1、读书笔记"><a href="#1、读书笔记" class="headerlink" title="1、读书笔记"></a>1、读书笔记</h2><p>&lt;1&gt;. “场景流”体现的不再是在具象、静态的场景里被规划，而是在更加流动的时空细节中生长，用更加丰富的要素重组带来极致的感受体验。</p><p>&lt;2&gt;. “场景流”意味着更加情景化、动态化，意味着时间审美大于确定的空间审美。新情境会带来用户情绪的全新涌现和全新需求，情感片段在时空中的流动会生成新的符号标签。</p><p>&lt;3&gt;. 消费选择、休闲方式和室内摆设也是社会地位的陷阱。在当下，你选择怎样的消费场景，就代表你具有怎样的审美品位和所处的社会地位。</p><p>&lt;4&gt;.“体验”不应该继续在静态场景里被策划，而应该被更加丰富的要素来重组。未来，更多的新产品与新社区都将是以场景体验为出发点的设计产物。</p><p>&lt;5&gt;.场景流的设计核心是体验，是以人的动线为逻辑，以连接质量为前提，以情感输出为要素、以社群沉淀为结果的商业模型。</p><p>&lt;6&gt;. 设计与设计力的区别在于：设计师商业工具，是如何通过合理、愉悦、人性化的设计让产品实现商业价值的最大化；设计力则是创造性的商业思维和方法，是包括产品设计、文化设计、空间设计、用户体验设计、商业模式设计在内的丰富、多重、结构性的商业能力。作为新物种商业基因，设计力需要进化出全新的连接方式与话语体系。</p><p>&lt;7&gt;.体验升级指向精神消费时代对用户的情绪诉求和文化诉求的满足，核心是捕捉用户的心智信号，构建超越期待的体验场景，与用户建立基于文化认同的情感连接，本质是创造不确定性，完成用户的预期管理设计。</p><p>&lt;8&gt;.将用户未被充分表达的诉求，小众但稳固的亚文化表达、潜流涌动的生活方式等，经由设计力范式进行创意性构建，用足够独特的场景组合进行承接，用新的意义进行恰如其分的输出，用心的商业模式完成承载，以此诞生真正符合新消费精神的新品类、新品牌，正式设计力的演绎路径和方法论价值。</p><p>&lt;9&gt;.新一轮消费升级中，美学消费成为新的商业机会。但美学消费的本质不是感官经济，而是意义经济，它追求的是美之于内心的意义所在，因而体验升级是新消费精神的核心，指向的是审美文化与连接效率，本质在于能否以超越期待的体验形成与用户的情感连接。</p><p>&lt;10&gt;. 商业新物种的进化过程中，必须具备持续的动力机制，这个动力必然来自内容力，它是新物种表现长久生命力的关键所在。在打造内容力的过程中，所有的内容产品、传播路径、连接机制必须从内在逻辑服从顶层的文化属性。止呕文化统领才能形成内容见的意义互洽，激发内容的解构效应，并最终构成文化认同的唯一性辨识，这便是文化设计的核心所在。</p><p>&lt;11&gt;. 立足用户追求自我的精神表达，个体崛起时代商业规则的逆转，传统商业模式必然面临颠覆。在底层逻辑的改变中，同一维度中的“更好”已无法跨越曲线持续增长，升维打击或降维攻击的“不同”才是突围关键，代表着设计力的颠覆式创新。</p><p>&lt;12&gt;. 在设计力的驱动机制中，更多时候不是对用户的追随，而是引领和反哺，是通过设计成果反向促进用户认知的完整升级，以此定义新的消费精神，新品类、新品牌也因此被创造。但不可回避的是，设计力反向作用的逆向打法，注定是需要持续造浪的过程，必须依靠持续的势能叠加，才有可能撬动用户的固有认知，引发消费精神的革新。</p><p>&lt;13&gt;. 消费升级推动的就是从功能消费到精神消费的升级，解决用户在精神诉求上的痛点成为产品升级的核心。</p><p>&lt;14&gt;. “一切商业皆内容”越来越成为共同认知，内容入口的抢夺日趋白热化，混合内容代表的正是更高内容力要求，它是持续创造多元化特质内容，让其相互渗透，相互融合形成新内容，从而生发新意义立体感和纵深感的过程。最终在动态的，流动性的内容生态中，新意义不再依靠内容开发者，而具备内容的自组织、自传播、自生长能力，这种混合内容机制成为实现更高效连接的内驱力，代表着更高势能的负成本连接能力，也终将发育成充满新想象的商业新物种。</p><p>&lt;15&gt;. 万物互联的重要特征是，人格在物化，而物品、商品尤其资本却在人格化。人格的物化，目的在于连接带来的情感替代。物的人格化，则是使目标消费群体可以与物进行情感的连接、互动，以产生群体间的共情。</p><hr><h2 id="THE-END"><a href="#THE-END" class="headerlink" title=" THE  END! "></a><font color="red"> <strong>THE  END!</strong> </font></h2>]]></content>
      
      
      <categories>
          
          <category> 读书 </category>
          
          <category> 读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Books </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>大冰《我不》读书笔记和读后感</title>
      <link href="/2019/06/22/%E3%80%90Books%E7%B3%BB%E5%88%97%E3%80%912019%E5%B9%B4%E7%AC%AC%E4%BA%8C%E6%9C%AC%E4%B9%A6%EF%BC%9A%E5%A4%A7%E5%86%B0%E3%80%8A%E6%88%91%E4%B8%8D%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E5%92%8C%E8%AF%BB%E5%90%8E%E6%84%9F/"/>
      <url>/2019/06/22/%E3%80%90Books%E7%B3%BB%E5%88%97%E3%80%912019%E5%B9%B4%E7%AC%AC%E4%BA%8C%E6%9C%AC%E4%B9%A6%EF%BC%9A%E5%A4%A7%E5%86%B0%E3%80%8A%E6%88%91%E4%B8%8D%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E5%92%8C%E8%AF%BB%E5%90%8E%E6%84%9F/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>    2019年初，立下了2019年的奋斗目标和方向。第二条：读好书，读完6本书，做好读书笔记。 第二本书继续读了大冰哥哥的《我不》，每每读书中的故事，总是能被故事中的那一个一个鲜活鲜活的生命所感触，或许是感触他们那艰难的命运，或许是感触他们那与命运抗争的努力，或许是感触他们那无与伦比精彩的生活。<br>        <img src="/img/20190623102842883-.png" alt="《我不》封面"><br>图片来自 <a href="https://baike.so.com/doc/7188322-28201480.html" target="_blank" rel="noopener">百度百科</a>。</p><h2 id="1、读书笔记"><a href="#1、读书笔记" class="headerlink" title="1、读书笔记"></a>1、读书笔记</h2><ul><li>星光不问赶路人，时光不负有心人。这个世界上真的有人在过着你想要的生活，而那些人大都曾隐忍过你尚未经历的挫折。</li><li>婆娑境里，所有当下动人的故事，全都不是第一次发生</li><li>人间道是向死而生的，一路生长一路告别，反反复复地擦肩而过。圆缺无常，八风凛冽。少有永恒，只有永别。</li><li>世事大都走的抛物线，大凡出人头地，总要欲扬先抑，你要做的，不过是种因待果，不过是业里修身，不过是晴天雨天坦然面对。</li><li>如果没有失去过，你又怎会永远记住我。</li><li>需求决定关系，没有需求保持友好。如此这般，方能致远。不想当你最好的朋友，也不会做你最差的朋友。只想不远不近地保持距离，看看有没有可能不走散。乃至，成为陪你走到最后的朋友。</li><li>走过的路越多，越喜欢宅着；见过的人越多，越喜欢孩子。</li><li>和平视同样重要的是平衡，无论是人生规划还是人际关系，平衡才是第一。</li><li>有些人一旦走了，就是没了。<br>世上罕有能陪你走完一生一世的父亲和母亲。 但人性贪侥幸，爱掩耳盗铃，总认为那一天无比遥远，遥远得像是不存在的。于大部分人而言，总要到一定年级才能学会环视，才能猝不及防地发现那一天早已近在眼前，静静地在你身旁立着。</li><li>有些相遇，像是注定的一般，世事之间总有些稀奇古怪的关联。</li><li>那些动人的故事，大都始于平淡，蕴于普通。却又伏藏在人性关隘处，示现在命运绝境中。</li><li>人无癖不可与交,以其无深情也<br>人无疵不可与交,以其无真气也。<br>人无痴不可与交,以其无深情也。<br>人无趣不可与交,以其无真气也。</li></ul><h2 id="2、读后感"><a href="#2、读后感" class="headerlink" title="2、读后感"></a>2、读后感</h2><p>大冰的书，已经读过两本了，好像是读一本故事集，看到故事中那鲜活的一个一个生命，他们和你我一样，都努力的生活在这个世界上。生而为人，活而不易。藏地的白玛是多么努力的生活着，承担着自己的责任，有着自己的人生使命；广西的小蓝，多么好的姑娘，多么努力的与命运抗争，与蠢子的爱情令人艳羡；成都姑娘莉莉，在异国他乡自己一人努力打拼，终于拥有了自己的事业和爱情。这些鲜活的生命都在和命运抗争，都在和命运说“我不”，都要活出自己。</p><p>而我呢？我的人生使命是什么？我该如何活出真正的自己呢？</p><p>&ensp; &ensp; &ensp;  &ensp;  &ensp;  &ensp;  &ensp;  &ensp;  &ensp;  &ensp;  &ensp;  &ensp;  &ensp;  &ensp;  &ensp;  &ensp;  &ensp;  &ensp;  &ensp;  &ensp;  &ensp;  &ensp;  &ensp;  &ensp;  &ensp;  &ensp;  &ensp;  &ensp;  &ensp;  &ensp;  &ensp;  &ensp;  &ensp;  &ensp;    写于2019年6月22日 杭州滨江</p><hr><h2 id="THE-END"><a href="#THE-END" class="headerlink" title="THE END!"></a><font color="red">THE END!</font></h2>]]></content>
      
      
      <categories>
          
          <category> 读书 </category>
          
          <category> 读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Books </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>毕业两年的总结和思考20190602</title>
      <link href="/2019/06/02/%E3%80%90Think%E7%B3%BB%E5%88%97%E3%80%91%E5%B7%A5%E4%BD%9C%E4%B8%A4%E5%B9%B4%E7%9A%84%E6%80%BB%E7%BB%93%E5%92%8C%E6%80%9D%E8%80%8320190602/"/>
      <url>/2019/06/02/%E3%80%90Think%E7%B3%BB%E5%88%97%E3%80%91%E5%B7%A5%E4%BD%9C%E4%B8%A4%E5%B9%B4%E7%9A%84%E6%80%BB%E7%BB%93%E5%92%8C%E6%80%9D%E8%80%8320190602/</url>
      
        <content type="html"><![CDATA[<p>在电脑面前，手指踌躇许久，不知从何写起。回想起这些年在外打拼的经历，一晃就要10年了，从2010年考上大学离开济南开始算起，4年大学在枣庄，在这里学习了电子信息的知识，学到了自主学习的方法，学会了解决问题的方法，在这里遇到了初恋的她，在这里也交了几个还在联系的朋友，在这里考研，在这里通宵，在这里去图书馆，在这里。。。。。。好多回忆慢慢涌出脑海。3年读研在宁波，这一次来到了江南，在这里学习了视频编码的知识，在这里学到了研究的方法，在这里认识了师兄师妹，在这里第一次当代课老师，在这里体验了江南水乡，在这里结束了我的学生生涯。3年工作在杭州，转瞬间来杭州也2年了，在这里开始了我的实习和第一份工作（编解码算法工程师），在这里去了多次去西湖和北高峰，在这里钱塘江夜跑，在这里杭州小分队多次聚餐，在这里工作中解决bugs，在这里有一份很难开始的感情。。。。。。不知道为什么，对杭州似乎并没有太多的回忆。也许从最初我只是把这座城市作为驿站，并没有想留下来，所以在面对那份很难开始的感情时也很难说服自己，还是遵从自己的内心吧。这10年，从枣庄到宁波再到杭州，3座城市，度过了人生中的黄金10年，20岁到30岁，在外取经的10年让我成长很多，成熟很多。但是在感情上，依然不够成熟，感觉自己就是个感情的小白，一直很难和一个陌生的人开始一份感情，或许我很难对别人打开心扉，或许我很难相信别人，或许我所期待的爱情还没有到来。</p><p>看到一句很有意思的话，一个人最好的状态就是有事做，有人爱，有所期待。有事做就是工作和事业吧，有人爱就是亲情，友情和爱情吧，有所期待就是自己的目标和愿望。工作事业上，我也在不断学习技术，进行职业规划，确定事业的方向；感情上，不管是亲情、友情还是爱情，都是需要经营需要付出的，好好珍惜身边人就好；目标和愿望呢，也许现在比较期待的是回济南吧，回到自己的家乡和故乡，重新开始自己新的生活，拥有自己的一套房子，适时再买一辆代步的车子，好好工作，努力赚钱，孝敬父母，过着拼搏而又舒适的生活，也许这就是我所期待的生活吧。</p><p>2017到2019年，工作两年了，明年就是三年了，在大华，在技术和对工作的认识上都有很多了提高和转变，好好积累新的知识，好好做好这半年多的工作，给自己的第一份工作画上圆满的句号。好了，就写这么多吧。</p><h2 id="THE-END"><a href="#THE-END" class="headerlink" title="THE END!"></a><font color="red"><strong>THE END!</strong></font></h2>]]></content>
      
      
      <categories>
          
          <category> 生活 </category>
          
          <category> 规划 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Think </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图像去噪算法研究（去噪+锐化）</title>
      <link href="/2019/05/29/%E3%80%90CV%E7%B3%BB%E5%88%97%E3%80%91%E5%9B%BE%E5%83%8F%E5%8E%BB%E5%99%AA%E7%AE%97%E6%B3%95%E7%A0%94%E7%A9%B6%EF%BC%88%E5%8E%BB%E5%99%AA+%E9%94%90%E5%8C%96%EF%BC%89/"/>
      <url>/2019/05/29/%E3%80%90CV%E7%B3%BB%E5%88%97%E3%80%91%E5%9B%BE%E5%83%8F%E5%8E%BB%E5%99%AA%E7%AE%97%E6%B3%95%E7%A0%94%E7%A9%B6%EF%BC%88%E5%8E%BB%E5%99%AA+%E9%94%90%E5%8C%96%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>Tags：图像处理—-图像去噪和图像锐化算法系列</p><p>[TOC]</p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>&ensp; &ensp;  图像增强是图像处理和计算机视觉中的一个重要的研究课题，主要作为图像预处理或者后处理，使处理后的图像更加清晰，以便于后面的图像分析和理解。本文主要概述图像增强中的图像去噪和图像锐化方向的主要方法及不同算法的本质理解。</p><p>图像增强算法的主要方向：<br>1、图像去噪<br>2、锐化<br>3、低照度增强<br>4、去雾<br>5、去运动模糊<br>6、超分辨率重建</p><h2 id="0、参考"><a href="#0、参考" class="headerlink" title="0、参考"></a>0、参考</h2><p><a href="https://blog.csdn.net/Trent1985/article/details/80509232" target="_blank" rel="noopener">图像保边滤波算法集锦系列</a><br><a href="https://www.cnblogs.com/Imageshop" target="_blank" rel="noopener">只(挚)爱图像处理</a></p><h2 id="1、图像去噪算法方法概述"><a href="#1、图像去噪算法方法概述" class="headerlink" title="1、图像去噪算法方法概述"></a>1、图像去噪算法方法概述</h2><h3 id="1-0、综述"><a href="#1-0、综述" class="headerlink" title="1.0、综述"></a>1.0、综述</h3><p>综述：<br><a href="https://www.researchgate.net/profile/Mukesh_Motwani/publication/265380752_Survey_of_Image_Denoising/links/540b426b0cf2df04e74c2f3d/Survey-of-Image-Denoising.pdf" target="_blank" rel="noopener">Survey-of-Image-Denoising.pdf</a><br><a href="https://blog.csdn.net/weixin_41284599/article/details/88744907" target="_blank" rel="noopener">图像去噪算法综述</a><br><a href="https://blog.csdn.net/eric_e/article/details/79504444" target="_blank" rel="noopener">图像去噪算法简介</a></p><h3 id="1-1、空域方法"><a href="#1-1、空域方法" class="headerlink" title="1.1、空域方法"></a>1.1、空域方法</h3><h4 id="1-1-1、方框滤波-均值滤波"><a href="#1-1-1、方框滤波-均值滤波" class="headerlink" title="1.1.1、方框滤波/均值滤波"></a><font color="blue">1.1.1、方框滤波/均值滤波</font></h4><p><strong>方框滤波/均值滤波</strong>：</p><ul><li><p>本质理解：<br>（1）线性局部滤波，通过邻域平均滤波，属于各向同性滤波，邻域像素点的权重都是一样的，对噪声和边缘细节区域都会同等对待，这样就导致了图像模糊。<br>（2）均值滤波从频率域角度来看，相当于一个低通滤波器，因此滤波会去除高频分量，去除噪声的同时也模糊了边缘和细节部分。</p></li><li><p>算法原理：<br>用每个像素和它邻域像素计算出来的平均值来替换图像中的每个像素。<br>均值滤波有两个参数：迭代次数和模板大小。迭代次数越多，模板尺寸越大，滤波效果越明显。</p></li><li><p>优缺点：<br>针对高斯噪声滤波效果较好，但存在边缘细节模糊的问题。</p></li><li><p>算法复杂度：<br>计算相对简单，时间复杂度：O(N^2),其中N表示图像大小，r表示邻域半径。</p></li></ul><h4 id="1-1-2、高斯滤波"><a href="#1-1-2、高斯滤波" class="headerlink" title="1.1.2、高斯滤波"></a><font color="blue">1.1.2、高斯滤波</font></h4><p><strong>高斯滤波：</strong></p><ul><li><p>本质理解<br>（1）邻域加权平均，相比均值滤波，多了一个高斯核函数用于衡量邻域像素点的权重，考虑邻域像素空间距离。属于各向同性滤波，对噪声和边缘细节区域都会同等对待，这样就导致了图像模糊。<br>（2）高斯滤波与均值滤波一样，都是线性局部滤波，但是考虑了像素空间分布，跟目标像素越近，权重越大；跟目标像素越远，权重越小。因此相对于均值滤波，高斯滤波的平滑效果更加柔和，对边缘的保留也更好，但是仍然存在边缘细节模糊的现象。</p></li><li><p>算法原理：<br>每个像素和邻域像素与高斯卷积核进行相乘来替换图像中的每个像素点。<br>高斯滤波的参数：模板大小核标准差。模板尺寸越大，标准差越大，滤波效果越明显。</p></li><li><p>优缺点：<br>考虑了像素空间分布（空间距离/空间邻近性），针对高斯噪声效果很好，但存在边缘细节模糊现象。</p></li><li><p>算法复杂度：<br>计算相对简单，比均值滤波复杂度要高。时间复杂度：O(N^2),其中N表示图像大小，r表示邻域半径。</p></li><li><p>更多参考：<br><a href="https://blog.csdn.net/yongjiankuang/article/details/79462851" target="_blank" rel="noopener">高斯滤波c语言实现</a><br><a href="https://blog.csdn.net/qq_19272431/article/details/78912752" target="_blank" rel="noopener">高斯滤波原理及C语言实现</a></p></li></ul><h4 id="1-1-3、中值滤波"><a href="#1-1-3、中值滤波" class="headerlink" title="1.1.3、中值滤波"></a><font color="blue">1.1.3、中值滤波</font></h4><p><strong>中值滤波：</strong>   </p><ul><li><p>本质理解：<br>（1）局部非线性滤波，采用邻域像素的中值来替换目标像素点，利用了噪声点分布的特点（主要利用中值不受分布序列极大值和极小值的影响的特点，所以中值点极有可能是非噪声点），对于椒盐噪声的滤波效果很好，但是对于高斯噪声滤波效果不好，并且存在边缘模糊现象。</p></li><li><p>算法原理：<br>将每个像素与周围邻域像素排序之后，取中值来替换图像中的每个目标像素点。</p></li><li><p>优缺点：<br>对椒盐噪声滤波效果较好，但是对高斯噪声滤波效果不好。由于噪声点也可能是边缘细节区域，因此也存在边缘细节模糊的问题，导致图像模糊。</p></li><li><p>算法复杂度：<br>计算相对简单。</p></li></ul><h4 id="1-1-4、自适应维纳滤波"><a href="#1-1-4、自适应维纳滤波" class="headerlink" title="1.1.4、自适应维纳滤波"></a><font color="blue">1.1.4、自适应维纳滤波</font></h4><ul><li><p>本质理解：<br>（1）最优线性滤波，基于最小均方误差的最优线性滤波器，这种滤波器使得滤波后的图像与原始图中之间的均方误差最小。<br>（2）利用图像或噪声的统计特性，基于最小均方误差准则求解最优解。</p></li><li><p>算法原理：<br>基于最小均方误差的最优线性滤波器，这种滤波器使得滤波后的图像与原始图中之间的均方误差最小。</p></li><li><p>优缺点：<br>需要知道原始信号和噪声的统计特性，对高斯噪声滤波效果较好，对图像细节有一定的保留，但是计算复杂度很高。</p></li><li><p>算法复杂度：<br>时间复杂度较高。</p></li><li><p>更多参考：<br><a href="https://www.cnblogs.com/guluxuanyuan/p/4062176.html" target="_blank" rel="noopener">LMS自适应维纳滤波器</a></p></li></ul><h4 id="1-1-5、双边滤波-Bilateral-Filter"><a href="#1-1-5、双边滤波-Bilateral-Filter" class="headerlink" title="1.1.5、双边滤波(Bilateral Filter)"></a><font color="blue">1.1.5、双边滤波(Bilateral Filter)</font></h4><p>详见：<a href="https://blog.csdn.net/SoaringLee_fighting/article/details/90744901" target="_blank" rel="noopener">【CV系列】图像保边去噪算法：双边滤波算法详解及其实现</a></p><p><strong>双边滤波：</strong></p><ul><li>本质理解：<br>（1）在高斯滤波的基础上增加了像素值相似性，综合考虑了像素空间相似性和亮度值相似性，采用加权平均滤波，也是属于各向同性滤波，具有一定的边缘保持效果，但是对于边缘和细节区域也会有模糊的问题。<br>（2）由公式可知，像素灰度值和空间距离共同决定了最终的滤波结果。当邻域像素点与中心像素点距离越远，或者邻域像素点与中心像素点的的差值越大时，权重越小，反之，权重越大。<br>（3）双边滤波本质上是将图像中相近和相似的邻域像素的加权平均值来替换目标像素点，由于考虑了像素间相似性，边缘可以较好的保持。</li></ul><ul><li><p>算法原理：<br>同高斯滤波一样也是采用加权平均的方式，不过权重不同，    权重如下：<br><img src="/img/20190611152004421.png" alt="双边滤波权重"></p></li><li><p>优缺点：<br>优点：（1）保边去噪（2）简单直观 （3）非迭代<br>缺点：（1）复杂度较高；（2）会出现梯度失真，梯度反转，常表现为halo（光晕现象）。这是因为当一个像素点周围的相似像素很少时，其高斯加权平均是很不稳定的。如下图所示：<br><img src="/img/20190611153211369.png" alt="halo光晕现象"></p></li><li><p>算法复杂度：<br>复杂度较高，时间复杂度：O(sigma^2),其中sigma表示空域高斯核函数的标准差。</p></li></ul><ul><li>更多参考：<br><a href="https://ieeexplore.ieee.org/document/8187212" target="_blank" rel="noopener">Bilateral Filtering: Theory and Applications</a><br><a href="https://blog.csdn.net/piaoxuezhong/article/details/78302920" target="_blank" rel="noopener">Bilateral Filters（双边滤波算法）原理及实现</a><br><a href="https://www.cnblogs.com/huty/p/8518478.html" target="_blank" rel="noopener">【VS开发】【图像处理】双边滤波器bilateral filter</a><br><a href="https://www.cnblogs.com/qiqibaby/p/5296681.html" target="_blank" rel="noopener">图像处理之双边滤波介绍与源码实现</a><br><a href="https://www.cnblogs.com/Imageshop/p/3406823.html" target="_blank" rel="noopener">o(1)复杂度之双边滤波算法的原理、流程、实现及效果。</a></li></ul><h4 id="1-1-6、非局部均值滤波（NLM）"><a href="#1-1-6、非局部均值滤波（NLM）" class="headerlink" title="1.1.6、非局部均值滤波（NLM）"></a><font color="blue">1.1.6、非局部均值滤波（NLM）</font></h4><ul><li><p>算法原理<br>参考：<a href="https://blog.csdn.net/Trent1985/article/details/82900592" target="_blank" rel="noopener">图像保边滤波算法集锦–非局部均值NLM滤波器</a></p></li><li><p>本质理解<br>利用了图像块的自相似性，考虑邻域像素值相似性，也考虑了图像块的几何配置，通过搜索窗口中像素值的加权平均进行滤波，跟目标像素越相近的，权重越大。</p></li><li><p>优缺点：<br>在去噪滤波的同时能够很好的保持边缘细节部分，对高斯噪声滤波效果很好，但是复杂度很高。</p></li></ul><ul><li>更多参考：<br><a href="http://www.ipol.im/pub/art/2011/bcm_nlm/article.pdf" target="_blank" rel="noopener">NLM</a><br><a href="https://sci-hub.tw/10.1109/cvpr.2005.38" target="_blank" rel="noopener">NLM_cvpr.2005.38</a><br><a href="https://blog.csdn.net/jaych/article/details/54562593" target="_blank" rel="noopener">【图像算法】NLM降噪</a></li></ul><h4 id="1-1-7、导向滤波"><a href="#1-1-7、导向滤波" class="headerlink" title="1.1.7、导向滤波"></a><font color="blue">1.1.7、导向滤波</font></h4><p>详见：  <a href="https://blog.csdn.net/SoaringLee_fighting/article/details/90384351" target="_blank" rel="noopener">【CV系列】图像保边去噪算法：导向滤波</a></p><h4 id="1-1-8、meanshift滤波："><a href="#1-1-8、meanshift滤波：" class="headerlink" title="1.1.8、meanshift滤波："></a><font color="blue">1.1.8、meanshift滤波：</font></h4><p><a href="https://yq.aliyun.com/articles/47948#" target="_blank" rel="noopener">图像处理——Mean Shift滤波(边缘保留的低通滤波)</a><br><a href="https://blog.csdn.net/Trent1985/article/details/80736629" target="_blank" rel="noopener">图像保边滤波算法集锦–MeanShift滤波算法与实现</a></p><h4 id="1-1-9-加权最小二乘法的保边缘平滑滤波器（WLS）"><a href="#1-1-9-加权最小二乘法的保边缘平滑滤波器（WLS）" class="headerlink" title="1.1.9  加权最小二乘法的保边缘平滑滤波器（WLS）"></a><font color="blue">1.1.9  加权最小二乘法的保边缘平滑滤波器（WLS）</font></h4><p><a href="https://blog.csdn.net/bluecol/article/details/48576253" target="_blank" rel="noopener">基于加权最小二乘法的保边缘平滑滤波器（WLS）</a><br><a href="https://www.cse.huji.ac.il/~danix/epd/Edge-Preserving" target="_blank" rel="noopener">Decompositions for Multi-Scale Tone and Detail Manipulation</a></p><h4 id="1-1-10-专利：一种快速保边滤波方法（EPM）"><a href="#1-1-10-专利：一种快速保边滤波方法（EPM）" class="headerlink" title="1.1.10 专利：一种快速保边滤波方法（EPM）"></a><font color="blue">1.1.10 专利：一种快速保边滤波方法（EPM）</font></h4><ul><li><p>算法原理<br>参考：<a href="https://blog.csdn.net/Trent1985/article/details/80802144" target="_blank" rel="noopener">图像保边滤波算法集锦–EPM滤波算法与实现</a><br>核函数：<br><img src="/img/20190612112820446.png" alt="核函数公式"></p><p>推导过程：<br><img src="/img/20190612112845820.png" alt="推导过程"><br>分析：<br>（1）若边缘细节等图像变化比较的区域（即sigma^2远大于epsion），则Q接近于1，此时不具有滤波效果；<br>（2）若图像平坦区域（即sigma^2远小于epsion）,则Q接近于miu，此时具有近似均值滤波的效果。</p></li><li><p>算法本质理解：<br>核函数类似于导向滤波的核函数，该算法也是利用局部均值方差信息进行保边去噪。但是由于该算法相比导向滤波少了三次均值计算和一次方差计算，所以复杂度要低很多。</p></li></ul><ul><li>更多参考：<br><a href="http://cprs.patentstar.com.cn/Search/Detail?ANE=8BFA4CCA8HAA9EHD7BFA6ECA9DGDBGIA9EHG6FAA9GHH5DCA" target="_blank" rel="noopener">一种图像快速保边滤波方法 [发明]</a></li></ul><h4 id="1-1-11-智能模糊（PS-Smart-Blur）"><a href="#1-1-11-智能模糊（PS-Smart-Blur）" class="headerlink" title="1.1.11 智能模糊（PS Smart Blur）"></a><font color="blue">1.1.11 智能模糊（PS Smart Blur）</font></h4><p>详见：<a href="https://blog.csdn.net/SoaringLee_fighting/article/details/90812798" target="_blank" rel="noopener">【CV系列】图像保边去噪算法：Smart Blur算法与实现(PS2018 Smart Blur)</a></p><p>这个滤波器的算法实现如下：</p><p>1，Smart Blur有两个参数：Radius和Threshold</p><p>Radius是邻域半径，Threshold是当前像素与周围像素的阈值差，范围为[0,255]</p><p>2，假设当前像素点为P(x,y)，滤波结果为D，以P为中心，Radius为邻域半径，计算邻域范围内符合条件A的像素点像素值和的均值，即为M；</p><p>条件A：像素X的值在区间[P-Threshold,P+Threshold]内</p><p>3，滤波结果值D=M；</p><p>用公式表示如下：<br><img src="/img/20190610203530467.png" alt="智能模糊"></p><p><strong>算法主要思想：</strong><br>邻域平均，所采用的邻域像素点是与目标像素点差值小于一定阈值，即采用与目标像素相近的像素进行邻域平均（利用了像素值相似性）。</p><p><strong>SmartBlur算法</strong>相比均值滤波的改进之处是邻域像素点采用与目标像素点相近的，这样对边缘细节具有一定的保护作用。与双边滤波中的值域高斯核函数加权的思路有相似之处。</p><h4 id="1-1-12-表面模糊（PS-Surface-Blur）"><a href="#1-1-12-表面模糊（PS-Surface-Blur）" class="headerlink" title=" 1.1.12 表面模糊（PS Surface Blur）"></a><font color="blue"> 1.1.12 表面模糊（PS Surface Blur）</font></h4><p>表面模糊是PS中的一个重要的包边滤波器，算法原理很简单，公式如下：<br><img src="/img/20190610203047572.png" alt="表面模糊"><br><strong>算法主要思想：</strong><br>还是计算目标像素一定邻域范围内的不同像素的加权平均，与目标像素差异越小的邻域像素权重越大，与目标像素差异越大的邻域像素权重越小，利用了像素值相似性来实现保边滤波。</p><h3 id="1-2、频域方法"><a href="#1-2、频域方法" class="headerlink" title="1.2、频域方法"></a>1.2、频域方法</h3><p>参考Paper：<br><a href="http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.684.492&rep=rep1&type=pdf" target="_blank" rel="noopener">Wavelet Transform Based Image Denoise Using Threshold Approaches</a><br><a href="https://ieeexplore.ieee.org/document/7148557" target="_blank" rel="noopener">New method of noise removal in images using curvelet transform</a><br><a href="https://ieeexplore.ieee.org/document/6568140" target="_blank" rel="noopener">Wavelet-based denoising: A brief review</a><br><a href="https://ieeexplore.ieee.org/abstract/document/4414526" target="_blank" rel="noopener">Image Denoise Based on Soft-Threshold and Edge Enhancement</a><br><a href="https://ieeexplore.ieee.org/document/1532303" target="_blank" rel="noopener">Feature-based wavelet shrinkage algorithm for image denoising</a></p><h4 id="1-2-1、DCT去噪："><a href="#1-2-1、DCT去噪：" class="headerlink" title="1.2.1、DCT去噪："></a><font color="blue">1.2.1、DCT去噪：</font></h4><p>当前频域去噪中效果较好并且实时的DCT去噪算法：<br><a href="https://blog.csdn.net/SoaringLee_fighting/article/details/90477209" target="_blank" rel="noopener">【CV系列】Image denoise： RDCT and RRDCT</a></p><p>更多参考：<br><a href="https://blog.csdn.net/fish_mai/article/details/52884985" target="_blank" rel="noopener">优化IPOL网站中基于DCT（离散余弦变换）的图像去噪算法</a><br><a href="https://www.cnblogs.com/Imageshop/p/9584024.html" target="_blank" rel="noopener">SSE图像算法优化系列二十一：基于DCT变换图像去噪算法的进一步优化（100W像素30ms）。</a></p><h4 id="1-2-2、DWT小波阈值去噪："><a href="#1-2-2、DWT小波阈值去噪：" class="headerlink" title="1.2.2、DWT小波阈值去噪："></a><font color="blue">1.2.2、DWT小波阈值去噪：</font></h4><p><a href="https://blog.csdn.net/zhang0558/article/details/76019832" target="_blank" rel="noopener">小波变换和小波阈值法去噪</a><br><a href="https://www.ee.iitb.ac.in/~icvgip/PAPERS/202.pdf" target="_blank" rel="noopener">Image Denoising using Wavelet Thresholding </a><br><a href="https://ieeexplore.ieee.org/abstract/document/803428" target="_blank" rel="noopener">Low-complexity image denoising based on statistical modeling of wavelet coefficients</a></p><h3 id="1-3、联合空域和频域的方法"><a href="#1-3、联合空域和频域的方法" class="headerlink" title="1.3、联合空域和频域的方法"></a>1.3、联合空域和频域的方法</h3><p><font color="blue"> <strong>三维块匹配滤波BM3D</strong></font></p><ul><li>算法原理：</li><li>BM3D的去噪过程如下：<br><img src="/img/20190611201326401.png" alt="BM3D去噪"></li><li>算法本质理解：<br>在非局部滤波的基础上，采用分块处理的思想进行更精细的块匹配并分组处理，充分利用图像内部结构的自相似性原理，并且对三维分组块进行变换域处理，结合空域和频域进行联合滤波，在降噪滤波的同时能够很好的保持边缘细节。</li></ul><ul><li>优缺点：<br>算法去噪效果很好，可以保边去噪，但是复杂度非常高，无法实现实时处理，很难满足实际应用的要求。</li></ul><ul><li>更多参考：<br><a href="https://blog.csdn.net/liyingjiang22/article/details/51611464" target="_blank" rel="noopener">BM3D图像去噪算法</a><br><a href="https://blog.csdn.net/hit1524468/article/details/80216922" target="_blank" rel="noopener">图像去噪序列——BM3D图像去噪模型实现</a><br><a href="http://www.cs.tut.fi/~foi/GCF-BM3D/" target="_blank" rel="noopener">BM3D项目主页</a><br><a href="http://www.cs.tut.fi/~foi/GCF-BM3D/BM3D_TIP_2007.pdf" target="_blank" rel="noopener"> BM3D下载1</a><br><a href="http://www.ipol.im/pub/art/2012/l-bm3d/" target="_blank" rel="noopener"> BM3D下载2</a><br><a href="https://blog.csdn.net/github_28260175/article/details/81101457" target="_blank" rel="noopener">BM3D(Block-Matching and 3D filtering)读后感</a></li></ul><h3 id="1-4、基于偏微分方程的方法（PDE）"><a href="#1-4、基于偏微分方程的方法（PDE）" class="headerlink" title="1.4、基于偏微分方程的方法（PDE）"></a>1.4、基于偏微分方程的方法（PDE）</h3><p>参考：<a href="http://www.wanfangdata.com.cn/details/detail.do?_type=degree&id=D622736" target="_blank" rel="noopener">基于偏微分方程的图像去噪算法</a></p><h3 id="1-5、深度学习类方法"><a href="#1-5、深度学习类方法" class="headerlink" title="1.5、深度学习类方法"></a>1.5、深度学习类方法</h3><p>深度学习类去噪:<br><a href="https://blog.csdn.net/edogawachia/article/details/78643190" target="_blank" rel="noopener">深度学习图像去噪发展概述</a><br><a href="https://blog.csdn.net/gwplovekimi/article/details/85043579" target="_blank" rel="noopener">基于深度学习的图像去噪暨SRMD论文阅读笔记</a><br><a href="https://twin.sci-hub.tw/6727/85460c8f1aab11b9a81c217535818872/cai2017.pdf#view=FitH" target="_blank" rel="noopener">Image denoising method based on a deep convolution neural network_ IETIP2017.pdf</a></p><hr><hr><h2 id="2、图像锐化算法方法概述"><a href="#2、图像锐化算法方法概述" class="headerlink" title="2、图像锐化算法方法概述"></a>2、图像锐化算法方法概述</h2><p>图像锐化算法主要有微分法（空域）、USM非锐化掩膜和高通滤波法（频域）三大类方法。</p><h3 id="2-1-微分法（空域）"><a href="#2-1-微分法（空域）" class="headerlink" title="2.1 微分法（空域）"></a><font color="blue">2.1 微分法（空域）</font></h3><p>微分法主要有梯度算子和拉普拉斯算子。</p><ul><li><strong>梯度算子</strong><br>梯度是一阶偏导数，可以用一阶差分近似表示。<br>gx = f(x+1,y)-f(x,y)<br>gy =f (x,y+1)-f(x,y)<br>grad(f) = |gx| + |gy|</li></ul><p><strong>特点：</strong> 计算简单，一阶微分提取渐变细节，边缘较粗，增强效果一般。</p><ul><li><p><strong>拉普拉斯算子</strong><br>拉普拉斯算子是二阶微分，是各向同性的微分算子，具有旋转不变性。<br>A. 求梯度：使用拉普拉斯算子，根据3x3加权矩阵，计算滤波后8邻域的梯度值。<br>B. 边缘增强：滤波后图像的每个像素点加上对应梯度值。</p><p> <strong>特点：</strong> 增强效果较好，对细线有较强的响应，提取突变边缘和细边缘，对噪声等孤立点比较敏感。</p></li></ul><ul><li>更多参考：<br><a href="https://www.cnblogs.com/raorao1994/p/8651276.html" target="_blank" rel="noopener">Laplace(拉普拉斯)算子</a><br><a href="https://blog.csdn.net/wh8514/article/details/80377436" target="_blank" rel="noopener">拉普拉斯锐化详解</a><br><a href="https://www.cnblogs.com/fydeblog/p/6748411.html" target="_blank" rel="noopener">数字图像处理之锐化处理</a><br><a href="https://www.cppentry.com/bencandy.php?fid=49&id=4218" target="_blank" rel="noopener">5.5.2 拉普拉斯掩模锐化（1）</a><br><a href="https://blog.csdn.net/zb1165048017/article/details/49330171" target="_blank" rel="noopener">拉普拉斯锐化图像</a><br><a href="https://blog.csdn.net/qq_20602929/article/details/51213314" target="_blank" rel="noopener">图像锐化</a><br><a href="http://www.mayiwenku.com/p-5663450.html" target="_blank" rel="noopener">图像锐化算法研究</a><br><a href="https://www.zhihu.com/question/26822364" target="_blank" rel="noopener">为什么 空间二阶导（拉普拉斯算子）这么重要？</a></li></ul><ul><li><strong>5x5加权矩阵锐化</strong><br>参考：<a href="https://blog.csdn.net/ebowtang/article/details/38961399" target="_blank" rel="noopener">数字图像处理，图像锐化算法的C++实现</a></li></ul><h3 id="2-2-USM非锐化掩膜"><a href="#2-2-USM非锐化掩膜" class="headerlink" title="2.2 USM非锐化掩膜"></a><font color="blue">2.2 USM非锐化掩膜</font></h3><p>USM非锐化掩膜方法是指先提取低频图像，然后用原图减去低频得到高频。这种方法称为非锐化掩模（unsharpen mask），我们常使用低通滤波器（高斯、双边）对图像进行滤波，这种方法滤波器很好控制（包括大小和强弱），从而可以控制高频分量的强弱。</p><p> 比如 <strong>典型的Photoshop USM锐化</strong>：<br> （1）用滤波后的图像中每个像素减去滤波前的原始像素，得到diff；<br> （2）如果diff的绝对值大于0，则把滤波后的图像中每个像素加上对应的diff/2(对应数量取为50，阈值取为0)。</p><p><strong>分析：</strong><br> PS中的USM锐化算法有三个参数：半径Radius、数量Amount和阈值Threshold。其中，半径表示滤波器模板尺寸，数量表示锐化程度，阈值表示达到何种程度的像素才需要增强。半径越大，数量参数越大，锐化效果越明显。<br><font color="red">实际效果表明，这种方式锐化效果比传统锐化方法（比如laplace锐化）能获得更好的调节效果。</font></p><p><strong>PS USM锐化算法实现：</strong></p><pre><code class="c">/************************************************************************/ @Function: USMSharpenOneChannel/ @Usage: Image sharpening using similiar photoshop unsharp mask algorithm for one channel/ @Param: src(IN): source input image(noise image)/      dst(IN&amp;OUT)：IN: filter image OUT: output sharpen image/      width(IN): image image/      height(IN): image height/ @Modified: 2019.5/************************************************************************/int USMSharpenOneChannel(unsigned char *src, unsigned char *dst, int width, int height){    int i, j, diff;    int iValue, iThresh = 0;    int iAmount = 80;    for(i = 0; i &lt; height; i++)    {               for(j = 0; j &lt; width; j++)               {                      diff = src[i*width+j] -  dst[i*width+j];                      if(abs(diff) &gt; iThresh)                       {                             iValue = src[i*width+j] + iAmount*diff/100;                             dst[i*width+j] = (unsigned char)((((unsigned short)iValue)|((short)(255-iValue)&gt;&gt;15))&amp;~iValue&gt;&gt;15);                        }               }       }    return 0;}</code></pre><p><strong>PS USM锐化算法效果图如下：</strong></p><p>灰度图（单通道）处理效果：<br><img src="/img/20190703220140173-.png" alt="灰度图处理效果"><br>彩色图（三通道）处理效果：<br><img src="/img/20190703222157862-.png" alt="彩色图处理效果"><br>说明：通过PS USM锐化之后，图像整体变得更加清晰，并且边缘细节区域对比度提高。</p><p>另一种USM锐化算法的实现：<a href="https://blog.csdn.net/jia20003/article/details/51864796" target="_blank" rel="noopener">图像处理之USM锐化</a></p><p>算法效果：<br><img src="/img/2019071322533644-.png" alt="USM锐化效果"></p><p> <strong>更多参考：</strong><br><a href="https://www.cnblogs.com/Imageshop/archive/2013/05/19/3086388.html" target="_blank" rel="noopener">Unsharp Mask(USM)锐化算法的的原理及其实现。</a><br><a href="https://blog.csdn.net/helimin12345/article/details/82634355" target="_blank" rel="noopener">图像锐化算法-sharpen</a><br>USM改进：<a href="https://blog.csdn.net/Trent1985/article/details/82588186" target="_blank" rel="noopener">数字图像算法研究—PS USM锐化算法详解</a><br>另一种USM锐化算法的实现：<a href="https://blog.csdn.net/jia20003/article/details/51864796" target="_blank" rel="noopener">图像处理之USM锐化</a></p><h3 id="2-3-高通滤波法（频域）"><a href="#2-3-高通滤波法（频域）" class="headerlink" title="2.3 高通滤波法（频域）"></a><font color="blue">2.3 高通滤波法（频域）</font></h3><p>由于图像边缘细节部分对应于高频分量，因此图像锐化可以通过频域高通滤波的方法，关键在于选择合适的高通滤波器。<br>常用高通滤波器有：理想高通滤波器、巴特沃斯高通滤波器、指数高通滤波器和高斯滤波器。</p><p><strong>Sharpen paper：</strong><br><a href="http://www.mayiwenku.com/p-5663450.html" target="_blank" rel="noopener">http://www.mayiwenku.com/p-5663450.html</a><br><a href="https://ieeexplore.ieee.org/document/8167116" target="_blank" rel="noopener">https://ieeexplore.ieee.org/document/8167116</a><br><a href="https://ieeexplore.ieee.org/document/766864" target="_blank" rel="noopener">https://ieeexplore.ieee.org/document/766864</a><br><a href="https://ieeexplore.ieee.org/document/1673453" target="_blank" rel="noopener">https://ieeexplore.ieee.org/document/1673453</a></p><hr><h2 id="THE-END"><a href="#THE-END" class="headerlink" title="THE  END!"></a><font color="red"><strong>THE  END!</strong></font></h2>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 图像处理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CV </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图像低照度增强算法研究</title>
      <link href="/2019/05/22/%E3%80%90CV%E7%B3%BB%E5%88%97%E3%80%91%E5%9B%BE%E5%83%8F%E4%BD%8E%E7%85%A7%E5%BA%A6%E5%A2%9E%E5%BC%BA%E7%AE%97%E6%B3%95%E7%A0%94%E7%A9%B6/"/>
      <url>/2019/05/22/%E3%80%90CV%E7%B3%BB%E5%88%97%E3%80%91%E5%9B%BE%E5%83%8F%E4%BD%8E%E7%85%A7%E5%BA%A6%E5%A2%9E%E5%BC%BA%E7%AE%97%E6%B3%95%E7%A0%94%E7%A9%B6/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>&ensp; &ensp;   图像传感器在光照不足的环境下成像，会造成视频图像噪声大、对比度低、大量细节信息无法表现等问题，这些不足严重影响人们对视频图像内容的判读和理解。因此图像低照度增强研究是非常必要的。</p><h2 id="1、参考"><a href="#1、参考" class="headerlink" title="1、参考"></a>1、参考</h2><p><a href="https://blog.csdn.net/piaoxuezhong/article/details/78441241" target="_blank" rel="noopener">低照度图像修复方法总结</a><br><a href="https://blog.csdn.net/grafx/article/details/53233508" target="_blank" rel="noopener">低照度图像增强（附步骤及源码）</a><br><a href="https://www.spiedigitallibrary.org/journals/Optical-Engineering/volume-49/issue-12/120501/Image-based-fusion-for-video-enhancement-of-night-time-surveillance/10.1117/1.3520553.full?SSO=1" target="_blank" rel="noopener">Image-based fusion for video enhancement of night-time surveillance</a><br><a href="https://ieeexplore.ieee.org/abstract/document/5366207" target="_blank" rel="noopener">Fog Removal from Video Sequences Using Contrast Limited Adaptive Histogram Equalization</a><br><a href="https://www.sciencedirect.com/science/article/pii/S1051200413001309" target="_blank" rel="noopener">Automatic contrast enhancement of low-light images based on local statistics of wavelet coefficients</a><br><a href="https://ieeexplore.ieee.org/abstract/document/6460559" target="_blank" rel="noopener">Enhancement and noise reduction of very low light level images</a><br><a href="https://ieeexplore.ieee.org/abstract/document/7351501" target="_blank" rel="noopener">A low-light image enhancement method for both denoising and contrast enlarging</a><br><a href="https://link.springer.com/chapter/10.1007/978-3-319-11758-4_10" target="_blank" rel="noopener">Low Light Image Enhancement via Sparse Representations</a><br><a href="https://www.cnblogs.com/Imageshop/p/9460334.html" target="_blank" rel="noopener">SSE图像算法优化系列二十：一种快速简单而又有效的低照度图像恢复算法</a></p><h2 id="2、研究学者"><a href="#2、研究学者" class="headerlink" title="2、研究学者"></a>2、研究学者</h2><p><a href="https://www.researchgate.net/profile/Zhenqiang_Ying" target="_blank" rel="noopener">https://www.researchgate.net/profile/Zhenqiang_Ying</a></p><h2 id="3、算法评价准则"><a href="#3、算法评价准则" class="headerlink" title="3、算法评价准则"></a>3、算法评价准则</h2><p>代码集合：<a href="https://github.com/baidut/OpenCE" target="_blank" rel="noopener">https://github.com/baidut/OpenCE</a></p><p>算法评价：增强后图像主客观质量</p><ul><li>主观质量：MOS</li><li>客观质量<ul><li>颜色失真评价：Mean DeltaE</li><li>亮度失真评价：LOE(Light Order Error)</li></ul></li></ul><h2 id="4、一种简单有效的低照度增强算法（Photoshop出品）"><a href="#4、一种简单有效的低照度增强算法（Photoshop出品）" class="headerlink" title="4、一种简单有效的低照度增强算法（Photoshop出品）"></a>4、一种简单有效的低照度增强算法（Photoshop出品）</h2><p>参考自：<a href="https://blog.csdn.net/CVAIDL/article/details/82853722" target="_blank" rel="noopener">https://blog.csdn.net/CVAIDL/article/details/82853722</a><br>Photoshop算法：<br>1、将绿色通道反色后作为系数值，分别与各个通道相乘，得到新图层；<br>2、将新图层与原图做一次滤色混合，f(a, b) = 1 - (1 - a)*(1 - b)；<br>3、将处理后的图像与新图层进行多次滤色混合，增强效果会更加明显。</p><p><strong>算法实现（C++&amp;OpenCV）:</strong></p><pre><code class="c">#include &lt;iostream&gt;#include &lt;cv.h&gt;#include &lt;highgui.h&gt;using namespace cv;using namespace std;#define BLUE     0#define GREEN    1#define RED     2#ifndef SCREEN_XY#define SCREEN_XY(x, y)  (255 - ((255 - (x))*(255 - (y)) &gt;&gt; 8))#endifint main(int argc, char *argv[]){    char imgfile[256] = &quot;1.jpg&quot;;    Mat src = imread(imgfile, CV_LOAD_IMAGE_COLOR);    //输入参数检查    if(TRUE == src.empty())    {      printf(&quot;[LLE_PS_DEMO] error: input is null!!\n&quot;);      return -1;    }    namedWindow(&quot;src&quot;, CV_WINDOW_NORMAL);    imshow(&quot;src&quot;, src);    int size = src.cols * src.rows;    uchar r = 0, g = 0, b = 0, g_alpha = 0;    uchar *pSrcData = src.data;    for (int i = 0; i &lt; size; i++, pSrcData += 3)    {        g_alpha = 255 - pSrcData[GREEN];  //将绿色通道分量反色        //新图层        b = pSrcData[BLUE]*g_alpha  &gt;&gt; 8;        g = pSrcData[GREEN]*g_alpha &gt;&gt; 8;        r = pSrcData[RED]*g_alpha   &gt;&gt; 8;         //原始图像与新图层进行滤色操作        pSrcData[BLUE]  = SCREEN_XY(pSrcData[BLUE],  b);        pSrcData[GREEN] = SCREEN_XY(pSrcData[GREEN], g);        pSrcData[RED]   = SCREEN_XY(pSrcData[RED],   r);        //进行二次滤色操作        pSrcData[BLUE]  = SCREEN_XY(pSrcData[BLUE],  b);        pSrcData[GREEN] = SCREEN_XY(pSrcData[GREEN], g);        pSrcData[RED]   = SCREEN_XY(pSrcData[RED],   r);    }     namedWindow(&quot;dst&quot;, CV_WINDOW_NORMAL);    imshow(&quot;dst&quot;, src);     imwrite(&quot;dst_1.jpg&quot;, src);    waitKey();    return 0;}</code></pre><p><strong>效果图如下：</strong><br><img src="/img/20190531232402408-.png" alt="低照度增强效果图"></p><blockquote><p>说明：上述效果看起来不是很明显，可能是与所使用的测试图片有关系。不过这种方法的增强效果应该是一般的，不过计算简单。</p></blockquote><h2 id="5、概述"><a href="#5、概述" class="headerlink" title="5、概述"></a>5、概述</h2><p><a href="http://www.wanfangdata.com.cn/details/detail.do?_type=perio&id=ccgxjmjxxyxb201603013" target="_blank" rel="noopener">低照度视频图像增强算法综述</a></p><h2 id="6、低照度增强主要方法"><a href="#6、低照度增强主要方法" class="headerlink" title="6、低照度增强主要方法"></a>6、低照度增强主要方法</h2><h3 id="6-1、基于直方图均衡化"><a href="#6-1、基于直方图均衡化" class="headerlink" title="6.1、基于直方图均衡化"></a>6.1、基于直方图均衡化</h3><p>DHE:  Dynamic Histogram Equalization<br><strong><a href="https://sci-hub.tw/10.1109/tce.2007.381734" target="_blank" rel="noopener">https://sci-hub.tw/10.1109/tce.2007.381734</a></strong></p><p>BPDHE:  Brightness Preversing Dynamic Histogram Equalization<br><strong><a href="https://sci-hub.tw/10.1109/tce.2007.4429280" target="_blank" rel="noopener">https://sci-hub.tw/10.1109/tce.2007.4429280</a></strong></p><p>CLAHE: Contrast Limited Adaptive Histogram Equalization<br><strong><a href="https://sci-hub.tw/10.1016/b978-0-12-336156-1.50061-6" target="_blank" rel="noopener">https://sci-hub.tw/10.1016/b978-0-12-336156-1.50061-6</a></strong><br><a href="https://www.cnblogs.com/Imageshop/archive/2013/04/07/3006334.html" target="_blank" rel="noopener">https://www.cnblogs.com/Imageshop/archive/2013/04/07/3006334.html</a></p><p>WAHE: Weighted adaptive histogram equalization</p><p>DHECI：？</p><p>CVC: Contextual and Variational Contrast Enhancement<br><strong><a href="https://sci-hub.tw/10.1109/tip.2011.2157513" target="_blank" rel="noopener">https://sci-hub.tw/10.1109/tip.2011.2157513</a></strong></p><p>LDR: Low Dyamaic Range</p><p><strong>基于OpenCV的实现：</strong><br><a href="http://www.opencv.org.cn/opencvdoc/2.3.2/html/doc/tutorials/imgproc/histograms/histogram_equalization/histogram_equalization.html" target="_blank" rel="noopener">http://www.opencv.org.cn/opencvdoc/2.3.2/html/doc/tutorials/imgproc/histograms/histogram_equalization/histogram_equalization.html</a></p><pre><code class="c">#include &quot;opencv2/highgui/highgui.hpp&quot;#include &quot;opencv2/imgproc/imgproc.hpp&quot;#include &lt;iostream&gt;#include &lt;stdio.h&gt;#define SIGLE_CHANNEL 1using namespace cv;using namespace std;/**  @function main */int main( int argc, char** argv ){  Mat src, dst;  int i;  char* source_window = &quot;Source image&quot;;  char* equalized_window = &quot;Equalized Image&quot;;  /// 加载源图像  src = imread( argv[1], 1 );  if( !src.data )    { cout&lt;&lt;&quot;Usage: ./Histogram_Demo &lt;path_to_image&gt;&quot;&lt;&lt;endl;      return -1;}#if SIGLE_CHANNEL  /// 转为灰度图  cvtColor( src, src, CV_BGR2GRAY );  /// 应用直方图均衡化  equalizeHist( src, dst );#else  std::vector&lt;Mat&gt;splitBGR(src.channels());  split(src, splitBGR);//图像通道分离  for (i = 0; i &lt; src.channels(); i++)  {    equalizeHist(splitBGR[i], splitBGR[i]);//图像灰度均衡化  }  merge(splitBGR, dst);#endif  /// 显示结果  namedWindow( source_window, CV_WINDOW_AUTOSIZE );  namedWindow( equalized_window, CV_WINDOW_AUTOSIZE );  imshow( source_window, src );  imshow( equalized_window, dst );  /// 等待用户按键退出程序  waitKey(0);  return 0;}</code></pre><h3 id="6-2、基于色调映射TM"><a href="#6-2、基于色调映射TM" class="headerlink" title="6.2、基于色调映射TM"></a>6.2、基于色调映射TM</h3><p>TM类的算法基本为去噪算法与色调映射算法结合的模式，该类算法结构适用于变化的场景，算法灵活性比较好，适宜扩展。但是算法复杂度比较高，算法实时性较低。<br><a href="https://sci-hub.tw/10.1145/1073204.1073272" target="_blank" rel="noopener">https://sci-hub.tw/10.1145/1073204.1073272</a><br><a href="http://www.doc88.com/p-5919931154338.html" target="_blank" rel="noopener">http://www.doc88.com/p-5919931154338.html</a></p><h3 id="6-3、基于背景融合"><a href="#6-3、基于背景融合" class="headerlink" title="6.3、基于背景融合"></a>6.3、基于背景融合</h3><h3 id="6-4、基于Retinex理论（模型类）"><a href="#6-4、基于Retinex理论（模型类）" class="headerlink" title="6.4、基于Retinex理论（模型类）"></a>6.4、基于Retinex理论（模型类）</h3><p><a href="https://ieeexplore.ieee.org/ielaam/83/7763897/7782813-aam.pdf" target="_blank" rel="noopener">LIME: Low-light Image Enhancement viaIllumination Map Estimation</a><br>LECARM: <a href="https://sci-hub.tw/10.1109/iccvw.2017.356" target="_blank" rel="noopener">https://sci-hub.tw/10.1109/iccvw.2017.356</a></p><p>LECARM: Ying的这篇论文里的研究将Retinex理论转换成作者自己的BTF+CRF模型，最后将低照度增强问题转换成求最优解问题，不得不感叹数学的伟大啊。这个研究的效果比LIME要好，但耗时比LIME要低。<br>文章的主要思路和步骤包括：</p><blockquote><p>1、光照变换函数的引入<br>2、CRF和Retinex理论的融合<br>3、求最优解<br>4、进行低照度增强</p></blockquote><h3 id="6-5、基于深度学习"><a href="#6-5、基于深度学习" class="headerlink" title="6.5、基于深度学习"></a>6.5、基于深度学习</h3><hr><h2 id="THE-END"><a href="#THE-END" class="headerlink" title="THE END! "></a><font color="red">THE END! </font></h2>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 图像处理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CV </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C工程中灵活的参数解析方式</title>
      <link href="/2019/05/13/%E3%80%90C%E7%B3%BB%E5%88%97%E3%80%91C%E5%B7%A5%E7%A8%8B%E4%B8%AD%E7%81%B5%E6%B4%BB%E7%9A%84%E5%8F%82%E6%95%B0%E8%A7%A3%E6%9E%90%E6%96%B9%E5%BC%8F/"/>
      <url>/2019/05/13/%E3%80%90C%E7%B3%BB%E5%88%97%E3%80%91C%E5%B7%A5%E7%A8%8B%E4%B8%AD%E7%81%B5%E6%B4%BB%E7%9A%84%E5%8F%82%E6%95%B0%E8%A7%A3%E6%9E%90%E6%96%B9%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>&ensp; &ensp; 在工程实践中，通常我们在命令行传递参数时，会直接通过argv的方式将入参一一传递进去，这种方式简单且固定，不具扩展性，并且在大的工程中参数传递数目较多时，会出现漏传参数导致出现段错误等问题。本文主要提供了一种灵活的参数解析方式，推荐使用这种方式。</p><h2 id="1、-参考"><a href="#1、-参考" class="headerlink" title="1、 参考"></a>1、 参考</h2><p><a href="http://www.cplusplus.com/reference/cstring/strcmp/" target="_blank" rel="noopener">strcmp_reference</a><br><a href="http://www.cplusplus.com/reference/cstring/strncmp/" target="_blank" rel="noopener">strncmp_reference</a></p><h2 id="2、-strcmp和strncmp使用方法"><a href="#2、-strcmp和strncmp使用方法" class="headerlink" title="2、 strcmp和strncmp使用方法"></a>2、 strcmp和strncmp使用方法</h2><pre><code class="c">int strcmp ( const char * str1, const char * str2 );</code></pre><p>Compare two strings<br>Compares the C string str1 to the C string str2.</p><p>This function starts comparing the first character of each string. If they are equal to each other, it continues with the following pairs until the characters differ or until a terminating null-character is reached.</p><p>This function performs a binary comparison of the characters. For a function that takes into account locale-specific rules, see strcoll.</p><table><thead><tr><th>return value</th><th>indicates</th></tr></thead><tbody><tr><td>&lt;0</td><td>the first character that does not match has a lower value in ptr1 than in ptr2</td></tr><tr><td>0</td><td>the contents of both strings are equal</td></tr><tr><td>&gt;0</td><td>the first character that does not match has a greater value in ptr1 than in ptr2</td></tr></tbody></table><pre><code class="c">int strncmp ( const char * str1, const char * str2, size_t num );</code></pre><p>Compare characters of two strings<br>Compares up to num characters of the C string str1 to those of the C string str2.<br>This function starts comparing the first character of each string. If they are equal to each other, it continues with the following pairs until the characters differ, until a terminating null-character is reached, or until num characters match in both strings, whichever happens first.</p><h2 id="3、-灵活的参数解析方式"><a href="#3、-灵活的参数解析方式" class="headerlink" title="3、 灵活的参数解析方式"></a>3、 灵活的参数解析方式</h2><p>主要是通过字符串函数strcmp和strncmp进行参数的解析。</p><h3 id="3-1-【Base-Level】："><a href="#3-1-【Base-Level】：" class="headerlink" title="3.1 【Base Level】："></a>3.1 <strong>【Base Level】：</strong></h3><pre><code class="c">if(argc &gt; 1){   int i = 0;   for(i = 1; i &lt; argc; ++i)   {      if(!strcmp(argv[i], &quot;-h&quot;) || !strcmp(argv[i], &quot;-help&quot;))      {          print_help(argv[0]);      }      else if(!strcmp(argv[i], &quot;-s&quot;))      {          width = atoi(argv[++i]);          height = atoi(argv[++i]);      }   }}</code></pre><h3 id="3-2-【Pro-Level】："><a href="#3-2-【Pro-Level】：" class="headerlink" title="3.2  【Pro Level】："></a>3.2  <strong>【Pro Level】：</strong></h3><pre><code class="c">if(argc &gt; 1){   int i = 0;   f   for(i = 1; i &lt; argc; ++i)   {      char *s = argv[i];      if(s[0] == &#39;-&#39;)      {            char *f;            switch(s[1])            {              case &#39;p&#39;:                 f = argv[++i];                 if(!strcmp(f, &quot;noiframe&quot;))                    dumpi = 0;                 if(!strcmp(f, &quot;nopframe&quot;))                    dumpp = 0;                 if(!strcmp(f, &quot;nobframe&quot;))                    dumpb = 0;                   break;                 case &#39;i&#39;:                     input = argv[++i];                     break;                 case &#39;o&#39;:                     output = argv[++i];                     break;                 case &#39;-&#39;:                    if(!strcmp(s+2, &quot;display&quot;))                    {                      display = 1;                    }                  break;         }      }   }}</code></pre><h3 id="3-3-【Pro-Level】："><a href="#3-3-【Pro-Level】：" class="headerlink" title="3.3  【Pro+ Level】："></a>3.3  <strong>【Pro+ Level】：</strong></h3><p>通过strncmp指定解析字符的长度。</p><pre><code class="c">if(argc &gt; 1){   int i = 0;   for(i = 1; i &lt; argc; ++i)   {      if(!strncmp(argv[i], &quot;-h&quot;, 2) || !strncmp(argv[i], &quot;-help&quot;, 5))      {          print_help(argv[0]);      }      else if(!strncmp(argv[i], &quot;-s&quot;, 2))      {          width = atoi(argv[++i]);          height = atoi(argv[++i]);      }      else if(!strcmp(argv[i], &quot;-ss&quot;, 3))      {          length = atoi(argv[++i]);      }   }}</code></pre><hr><h2 id="THE-END"><a href="#THE-END" class="headerlink" title="THE END!"></a><font color="red">THE END!</font></h2>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>不同系统文件共享(挂载)方法</title>
      <link href="/2019/03/18/%E3%80%90Tools%E7%B3%BB%E5%88%97%E3%80%91%E4%B8%8D%E5%90%8C%E7%B3%BB%E7%BB%9F%E6%96%87%E4%BB%B6%E5%85%B1%E4%BA%AB(%E6%8C%82%E8%BD%BD)%E6%96%B9%E6%B3%95/"/>
      <url>/2019/03/18/%E3%80%90Tools%E7%B3%BB%E5%88%97%E3%80%91%E4%B8%8D%E5%90%8C%E7%B3%BB%E7%BB%9F%E6%96%87%E4%BB%B6%E5%85%B1%E4%BA%AB(%E6%8C%82%E8%BD%BD)%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>&ensp; &ensp; 通常在嵌入式设备上运行程序，由于某些资源存储比较大，而嵌入式设备存储较小，因此需要将本地目录挂载到设备上，以实现文件共享。本文旨在分析常用的几种不同系统的文件共享方法。</p><h2 id="1、参考"><a href="#1、参考" class="headerlink" title="1、参考"></a>1、参考</h2><p><a href="https://blog.csdn.net/SoaringLee_fighting/article/details/78776946" target="_blank" rel="noopener">mount+nfs:虚拟机通过nfs服务将虚拟机上的目录挂在到本地目录</a><br><a href="https://blog.csdn.net/SoaringLee_fighting/article/details/73480362" target="_blank" rel="noopener">如何利用mount命令挂载另一台服务器上的目录</a><br><a href="https://blog.csdn.net/weixin_43283381/article/details/82851097" target="_blank" rel="noopener">NAS、CIFS、NFS之间的关系</a><br><a href="https://blog.51cto.com/13355576/2047735" target="_blank" rel="noopener">cifs协议与samba服务</a></p><h2 id="2、共享协议-CIFS和NFS，以及存储NAS"><a href="#2、共享协议-CIFS和NFS，以及存储NAS" class="headerlink" title="2、共享协议 CIFS和NFS，以及存储NAS"></a>2、共享协议 CIFS和NFS，以及存储NAS</h2><p>NAS，网络附加存储，中心词“存储”，是的，它是一个存储设备。比如我装个openfiler或freenas系统，再加几块硬盘，对外提供NAS功能，那么这个openfiler或freenas服务器就变成了很简单的“NAS设备”。当然，如果是对于小公司来说，一个openfiler做NAS设备足够了。</p><p>而CIFS，是微软提出的，全称叫<strong>通用internet文件共享</strong>，它是一种协议。NFS，网络文件共享，也是一种协议。那两者之间有什么区别呢？一句话，<strong>CIFS用于UNIX和windows间共享，而NFS用于UNIX和UNIX之间共享。</strong></p><p>所以，NAS是一个设备，一个功能。而CIFS/NFS是一种协议。可以在NAS上启用CIFS/NFS协议，这样，用户就能使用CIFS/NFS协议进行访问了。</p><h2 id="3、两种文件共享方式"><a href="#3、两种文件共享方式" class="headerlink" title="3、两种文件共享方式"></a>3、两种文件共享方式</h2><h3 id="3-1、NFS挂载"><a href="#3-1、NFS挂载" class="headerlink" title="3.1、NFS挂载"></a>3.1、NFS挂载</h3><p><strong>使用工具：</strong><a href="https://blog.csdn.net/SoaringLee_fighting/article/details/79677565" target="_blank" rel="noopener">haneWIN NFS Server 1.2.10 注册机（亲测有效）</a></p><p><strong>NFS功能：</strong> 在Windows电脑上启用NFS服务器， 本地电脑作为NFS服务器，虚拟机中的Ubuntu系统作为NFS客户机。将本地电脑上目录作为共享目录挂载到虚拟机Ubuntu系统的挂载点上。</p><p><strong>挂载方法：</strong><br>(1). 打开nfssrv.exe，输入—-》编辑输出表文件exports<br>(2). 在弹出来的exports文件中，输入：挂载目录  -name：挂载目录别名  -public  -alldirs<br>举个例子：</p><pre><code>E:\Work\share  -name:test_nfs  -public -alldirs</code></pre><p>(3).登陆到设备端，在设备端命令窗口中执行：mount -t nfs -o nolock,tcp 本地电脑IP:/(2)步骤设置的别名 设备上的挂载点<br>举个例子：</p><pre><code>mount -t nfs -o nolock,tcp 192.168.10.121:/test_nfs /mnt/test/</code></pre><h3 id="3-2、CIFS挂载"><a href="#3-2、CIFS挂载" class="headerlink" title="3.2、CIFS挂载"></a>3.2、CIFS挂载</h3><p><strong>使用工具：</strong> 需要在Linux系统中安装cifs。</p><p><strong>CIFS功能：</strong> CIFS用于UNIX和windows间文件共享。</p><p><strong>挂载方法：</strong><br>(1). 准备windows共享文件夹;<br>(2). mount挂载操作<br>sudo mount -t cifs -o username=登录windows共享文件夹用户名,password=登录windows共享文件夹密码 //windows共享主机IP地址/windows共享文件夹名称 /Ubuntu下的一个目录</p><p>举个例子：</p><pre><code>sudo mount -t cifs -o username=Administrator,password=登录windows共享文件夹密码,sec=ntlm,rw,dir_mode=0777,file_mode=0777  //192.168.10.121/share  /home/mnt</code></pre><p>(3). 去挂载（卸载）方法：</p><pre><code>sudo umount /Ubuntu下的一个目录</code></pre><p>参考：<a href="https://blog.csdn.net/wanfengzhong/article/details/52550074" target="_blank" rel="noopener">https://blog.csdn.net/wanfengzhong/article/details/52550074</a></p><h2 id="4、更多参考"><a href="#4、更多参考" class="headerlink" title="4、更多参考"></a>4、更多参考</h2><p><a href="http://www.jinbuguo.com/man/mount.cifs.html" target="_blank" rel="noopener">mount.cifs 中文手册</a></p><hr><h2 id="THE-END"><a href="#THE-END" class="headerlink" title="THE END!"></a><font color="red"><strong>THE END!</strong></font></h2>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mount </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>跨平台统一时间函数SDK及用法</title>
      <link href="/2019/03/05/%E3%80%90PE%E7%B3%BB%E5%88%97%E3%80%91%E4%B9%8B%E8%B7%A8%E5%B9%B3%E5%8F%B0%E7%BB%9F%E4%B8%80%E6%97%B6%E9%97%B4%E5%87%BD%E6%95%B0SDK%E5%8F%8A%E7%94%A8%E6%B3%95/"/>
      <url>/2019/03/05/%E3%80%90PE%E7%B3%BB%E5%88%97%E3%80%91%E4%B9%8B%E8%B7%A8%E5%B9%B3%E5%8F%B0%E7%BB%9F%E4%B8%80%E6%97%B6%E9%97%B4%E5%87%BD%E6%95%B0SDK%E5%8F%8A%E7%94%A8%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>&ensp; &ensp; 前面讲述过Linux平台下时间统计函数的用法，见<a href="https://blog.csdn.net/SoaringLee_fighting/article/details/65627573" target="_blank" rel="noopener">linux下时间有关的函数和结构体</a>和<a href="https://blog.csdn.net/SoaringLee_fighting/article/details/70919381" target="_blank" rel="noopener">Linux下时间函数：struct timeval结构体</a>。<br>&ensp; &ensp; 本文旨在梳理讲述Windows平台下时间统计函数的使用方法以及<font color="red">跨平台统一时间函数SDK。</font></p><h2 id="1、参考"><a href="#1、参考" class="headerlink" title="1、参考"></a>1、参考</h2><p><a href="https://blog.csdn.net/buzaikoulan/article/details/45152689" target="_blank" rel="noopener">windows下统计时间的函数</a><br><a href="https://blog.csdn.net/hellokandy/article/details/51330028" target="_blank" rel="noopener">Windows 计算程序运行时间（高精度计时）</a><br><a href="https://blog.csdn.net/HQ354974212/article/details/79390107" target="_blank" rel="noopener">Windows 各种计算时间函数总结</a><br><a href="https://blog.csdn.net/luo_aiyang/article/details/80845786" target="_blank" rel="noopener">Windows下获取当前时间函数汇总</a><br><a href="https://blog.csdn.net/listener51/article/details/53044290" target="_blank" rel="noopener">windows/linux 获取本地时间（精确到微妙）</a></p><h2 id="2、Windows平台下时间统计函数使用方法"><a href="#2、Windows平台下时间统计函数使用方法" class="headerlink" title="2、Windows平台下时间统计函数使用方法"></a>2、Windows平台下时间统计函数使用方法</h2><h3 id="2-1、方法一：QueryPerformaceCounter"><a href="#2-1、方法一：QueryPerformaceCounter" class="headerlink" title="2.1、方法一：QueryPerformaceCounter()"></a>2.1、方法一：QueryPerformaceCounter()</h3><p>头文件：#include &lt;windows.h&gt;</p><p> &ensp;  如果需要更高的时间精度（比如说服务器程序的耗时统计），可以在开始计时统计前先调用QueryPerformanceFrequency()函数获得机器内部计时器的时钟频率，接着在需要严格计时的事件发生前和发生之后分别调用QueryPerformanceCounter()，利用两次获得的计数之差和时钟频率，就可以计算出事件经历的精确时间（精度可以达到微秒级别）。</p><p><strong>用法如下：</strong></p><pre><code class="c">#include &lt;stdio.h&gt;#include &lt;io.h&gt;#include &lt;windows.h&gt;   //for GetTickCount function#include &lt;Mmsystem.h&gt; //for timeGetTime function#include &lt;time.h&gt;  // for time function#pragma comment(lib, &quot;Winmm.lib&quot;)  //for timeGetTime functionint main(){    int  N = 10000;    double start_t,end_t,cost;    LARGE_INTEGER begin;    LARGE_INTEGER end;    LARGE_INTEGER frequence;    double duartion;//     method1:用timeGetTime()来计时，单位为ms//     DWORD  dwBegin, dwEnd, dwBegin1, dwEnd1;//     dwBegin = timeGetTime();//     Sleep(N);//     dwEnd = timeGetTime();//     printf(&quot;timeGetTime Time: %d\n&quot;, dwEnd - dwBegin);//method2:用GetTickCount()来计时，单位为ms//     dwBegin1 = GetTickCount();//     Sleep(N);//     dwEnd1 = GetTickCount();//     printf(&quot;GetTickCount Time: %d\n&quot;, dwEnd - dwBegin);//method3:用time()来计时,单位为秒//     time_t begin,end;//     begin = time(NULL);//     Sleep(N);//     end = time(NULL);//     printf(&quot;time: %d\n&quot;, end - begin);//method4:用clock()来计时,单位为ms//     start_t=clock();  //     Sleep(10);  //     end_t=clock();  //     cost=end_t-start_t;  //     printf(&quot;clock time: %d\n&quot;,cost);      QueryPerformanceFrequency(&amp;frequence);    QueryPerformanceCounter(&amp;begin);    Sleep(1234);    QueryPerformanceCounter(&amp;end);    duartion = (double)(end.QuadPart - begin.QuadPart) / (frequence.QuadPart);    printf(&quot;QueryPerformaceCounter time: %1.3f s\n&quot;,duartion); //单位为秒，精度为微秒(1000000/cpu主频)    system(&quot;pause&quot;);}</code></pre><p><strong><font color="red">精度分析：精度较高，<font color="red">1微妙</font></font></strong></p><h3 id="2-2、方法二：clock"><a href="#2-2、方法二：clock" class="headerlink" title="2.2、方法二：clock()"></a>2.2、方法二：clock()</h3><p>头文件：#include &lt;time.h&gt;  </p><p>clock()是C/C++中的计时函数，而与其相关的数据类型是clock_t。在MSDN中，查得对clock函数定义如下：</p><pre><code class="cv">clock_t clock(void) ;</code></pre><p>简单而言，就是该程序从启动到函数调用占用CPU的时间。这个函数返回从“开启这个程序进程”到“程序中调用clock()函数”时之间的CPU时钟计时单元（clock tick）数，在MSDN中称之为挂钟时间（wal-clock）；若挂钟时间不可取，则返回-1。其中clock_t是用来保存时间的数据类型。</p><p><strong>用法如下：</strong></p><pre><code class="c">#include &lt;time.h&gt;  #include &lt;stdio.h&gt;  int main()  {      double start,end,cost;      start=clock();      sleep(1);      end=clock();      cost=end-start;      printf(&quot;%f\n&quot;,cost);      return 0;  }</code></pre><p><strong><font color="red">精度分析： 1ms</font></strong></p><h3 id="2-3、方法三：timeGetTime"><a href="#2-3、方法三：timeGetTime" class="headerlink" title="2.3、方法三：timeGetTime()"></a>2.3、方法三：timeGetTime()</h3><p>头文件：#include &lt;Mmsystem.h&gt;            </p><p>引用库：#pragma comment(lib, “Winmm.lib”)  </p><pre><code class="c">DWORD timeGetTime(VOID);    //毫秒为单位</code></pre><p>作用： 返回从系统启动到调用函数时所经过的毫秒数。注意，这个值是32位的，会在0到2^32之间循环，约49.71天。<br><strong>用法如下：</strong></p><pre><code class="c">#include &lt;stdio.h&gt;#include &lt;windows.h&gt;#include &lt;Mmsystem.h&gt;#pragma comment(lib, &quot;Winmm.lib&quot;)int main(){    int  N = 3;    //用timeGetTime()来计时  毫秒    DWORD  dwBegin, dwEnd;    dwBegin = timeGetTime();    Sleep(N);    dwEnd = timeGetTime();    printf(&quot;%d\n&quot;, dwEnd - dwBegin);    system(&quot;pause&quot;);}</code></pre><p><strong><font color="red">精度分析：1ms</font></strong></p><h3 id="2-4、方法四：GetTickCount"><a href="#2-4、方法四：GetTickCount" class="headerlink" title="2.4、方法四：GetTickCount()"></a>2.4、方法四：GetTickCount()</h3><p>GetTickcount函数：它返回从操作系统启动到当前所经过的毫秒数，它的返回值是DWORD。常常用来判断某个方法执行的时间，其函数原型是：</p><pre><code class="c">DWORD GetTickCount(void)</code></pre><p>返回值以32位的双字类型DWORD存储，因此可以存储的最大值是(2^32-1) ms约为49.71天，因此若系统运行时间超过49.71天时，这个数就会归0，MSDN中也明确的提到了:”Retrieves the number of milliseconds that have elapsed since the system was started, up to 49.7 days.”。因此，如果是编写服务器端程序，此处一定要万分注意，避免引起意外的状况。</p><p>特别注意：这个函数并非实时发送，而是由系统每18ms发送一次，因此其最小精度为18ms。当需要有小于18ms的精度计算时，应使用StopWatch方法进行。</p><p><strong>用法如下：</strong></p><pre><code class="c">#include &lt;stdio.h&gt;#include &lt;windows.h&gt;#include &lt;Mmsystem.h&gt;#pragma comment(lib, &quot;Winmm.lib&quot;)int main(){    int  N = 5;    //用timeGetTime()来计时  毫秒    DWORD  dwBegin, dwEnd, dwBegin1, dwEnd1;    dwBegin = timeGetTime();    Sleep(N);    dwEnd = timeGetTime();    printf(&quot;timeGetTime: %d\n&quot;, dwEnd - dwBegin);    dwBegin1 = GetTickCount();    Sleep(N);    dwEnd1 = GetTickCount();    printf(&quot;GetTickCount: %d\n&quot;, dwEnd - dwBegin);    system(&quot;pause&quot;);}</code></pre><p><strong><font color="red">精度分析： 15~18ms</font></strong></p><h3 id="2-5、方法五：time"><a href="#2-5、方法五：time" class="headerlink" title="2.5、方法五：time()"></a>2.5、方法五：time()</h3><p>头文件：#include &lt;time.h&gt;</p><pre><code class="c">time_t    time(time_t *timer);    //  秒为单位</code></pre><p>返回以格林尼治时间（GMT）为标准，从1970年1月1日00:00:00到现在的此时此刻所经过的秒数。</p><p>time_t实际是个long长整型typedef     long    time_t;</p><p><strong>用法如下：</strong></p><pre><code class="c">#include &lt;stdio.h&gt;#include &lt;time.h&gt;  // for time functionint main(){    int  N = 10000;//method3:用time()来计时,单位为秒    time_t begin,end;    begin = time(NULL);    Sleep(N);    end = time(NULL);    printf(&quot;time: %d\n&quot;, end - begin);    system(&quot;pause&quot;);}</code></pre><p><strong><font color="red">精度分析： 1s 精度最低</font></strong></p><h2 id="3、补充知识"><a href="#3、补充知识" class="headerlink" title="3、补充知识"></a>3、补充知识</h2><p>UTC（世界标准时间），Calendar Time（日历时间），epoch（时间点），clock tick（时钟计时单元）<br>参考自：<a href="https://blog.csdn.net/luo_aiyang/article/details/80845786" target="_blank" rel="noopener">Windows下获取当前时间函数汇总</a></p><h2 id="4、跨平台统一时间函数SDK"><a href="#4、跨平台统一时间函数SDK" class="headerlink" title="4、跨平台统一时间函数SDK"></a>4、跨平台统一时间函数SDK</h2><p>说明：该SDK可用于Windows平台和Linux平台上的功能函数时间统计。</p><h3 id="os-time-sdk-h"><a href="#os-time-sdk-h" class="headerlink" title="os_time_sdk.h"></a>os_time_sdk.h</h3><pre><code class="c">#ifndef _OS_TIME_SDK_H_#define _OS_TIME_SDK_H_#ifdef __cplusplusextern &quot;C&quot;{#endif#if defined(WIN32) || defined(UNDER_CE) || defined(WIN64)#include &lt;windows.h&gt;#include &lt;io.h&gt;typedef struct _os_timer{   LARGE_INTEGER lpFrequency;   LARGE_INTEGER tStart;   LARGE_INTEGER tEnd;}os_timer;#elif defined(__GNUC__)#include &lt;unistd.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;sys/time.h&gt;typedef struct _os_timer{  struct timeval tStart;  struct timeval tEnd;}os_timer;#endifint os_sdk_inittimer(os_timer *pTimer);int os_sdk_starttimer(os_timer *pTimer);int os_sdk_stoptimer(os_timer *pTimer);int os_sdk_sleep(int msecs);int is_file_exist(char *path);#ifdef __cplusplus};#endif#endif</code></pre><h3 id="os-time-sdk-c"><a href="#os-time-sdk-c" class="headerlink" title="os_time_sdk.c"></a>os_time_sdk.c</h3><pre><code class="c">#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;memory.h&gt;#include &quot;os_time_sdk.h&quot;#if defined(WIN32) || defined(UNDER_CE) || defined(WIN64)int os_sdk_inittimer(os_timer *pTimer){   QueryPerformanceFrequence(&amp;pTimer-&gt;lpFrequency);   return 0;}int os_sdk_starttimer(os_timer *pTimer){   QueryPerformanceCounter(&amp;pTimer-&gt;tStart);   return 0;}int os_sdk_stoptimer(os_timer *pTimer){   QueryPerformanceCounter(&amp;pTimer-&gt;tEnd);   return (int)((pTimer-&gt;tEnd.QuadPart - pTimer-&gt;tStart.QuadPart)*1000/(pTimer-&gt;lpFrequency.QuadPart));}int os_sdk_sleep(int msecs){   Sleep(msecs);   return 0;}int is_file_exist(char *path){   return (_access(path, 0) == -1)? 0 : 1;}#elif defined(__GNUC__)int os_sdk_inittimer(os_timer *pTimer){   return 0;}int os_sdk_starttimer(os_timer *pTimer){   gettimeofday(&amp;pTimer-&gt;tStart, NULL);   return 0;}int os_sdk_stoptimer(os_timer *pTimer){  gettimeofdayy(&amp;pTimer-&gt;tEnd, NULL);  return (pTimer-&gt;tEnd.tv_sec - pTimer-&gt;tStart.tv_sec)*1000 + (pTimer-&gt;tEnd.tv_usec - pTimer-&gt;tStart.tv_usec)/1000;}int os_sdk_sleep(int msecs){  usleep(msecs*1000);  return 0;}int is_file_exist(char *path){  return (access(path , 0) == -1) ? 0 : -1;}#endif</code></pre><h2 id="5、windows-linux-获取本地时间（精确到微妙）"><a href="#5、windows-linux-获取本地时间（精确到微妙）" class="headerlink" title="5、windows/linux 获取本地时间（精确到微妙）"></a>5、windows/linux 获取本地时间（精确到微妙）</h2><p>参考自：<a href="https://blog.csdn.net/listener51/article/details/53044290" target="_blank" rel="noopener">windows/linux 获取本地时间（精确到微妙）</a></p><h3 id="5-1、windows下获取本地时间的方法"><a href="#5-1、windows下获取本地时间的方法" class="headerlink" title="5.1、windows下获取本地时间的方法"></a>5.1、windows下获取本地时间的方法</h3><pre><code class="c">#if defined(WIN32) || defined(UNDER_CE) || defined(WIN64)#include&lt;time.h&gt;#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;windows.h&gt;void getstimeval(){        long time;        SYSTEMTIME sys;        unsigned int us;        LARGE_INTEGER tick;        LARGE_INTEGER timestamp;        QueryPerformanceFrequency(&amp;tick);        QueryPerformanceCounter(timestamp);        us=(timestamp.QuadPart % tick.QuadPart)*1E6/tick.QuadPart;        GetLocalTime(&amp;sys);        printf(&quot;%04d-%02d-%02d %02d:%02d:%02d.%06d\n&quot;,sys.wYear, sys.wMonth, sys.wDay, \        sys.wHour, sys.wMinute, sys.wSecond, us);}#endif</code></pre><h3 id="5-2、linux下获取本地时间的方法"><a href="#5-2、linux下获取本地时间的方法" class="headerlink" title="5.2、linux下获取本地时间的方法"></a>5.2、linux下获取本地时间的方法</h3><pre><code class="c">#if defined(__GUNC__)#include&lt;sys/time.h&gt;#include&lt;time.h&gt;#include&lt;stdio.h&gt;#include&lt;string.h&gt;void getstimeval(){        char buf[28];        struct timeval tv;        struct tm      tm;        size_t         len = 28;        gettimeofday(&amp;tv, NULL);        localtime_r(&amp;tv.tv_sec, &amp;tm);        strftime(buf, len, &quot;%Y-%m-%d %H:%M:%S&quot;, &amp;tm);        len = strlen(buf);        sprintf(buf + len, &quot;.%06.6d&quot;, (int)(tv.tv_usec));        printf(&quot;%s\n&quot;,buf);}#endif</code></pre><hr><h2 id="THE-END"><a href="#THE-END" class="headerlink" title="THE END! "></a><font color="red">THE END! </font></h2>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 工程化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> sample </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我奋斗了18年才和你坐在一起喝咖啡</title>
      <link href="/2019/02/10/%E3%80%90Life%E7%B3%BB%E5%88%97%E3%80%91%E6%88%91%E5%A5%8B%E6%96%97%E4%BA%8618%E5%B9%B4%E6%89%8D%E5%92%8C%E4%BD%A0%E5%9D%90%E5%9C%A8%E4%B8%80%E8%B5%B7%E5%96%9D%E5%92%96%E5%95%A1/"/>
      <url>/2019/02/10/%E3%80%90Life%E7%B3%BB%E5%88%97%E3%80%91%E6%88%91%E5%A5%8B%E6%96%97%E4%BA%8618%E5%B9%B4%E6%89%8D%E5%92%8C%E4%BD%A0%E5%9D%90%E5%9C%A8%E4%B8%80%E8%B5%B7%E5%96%9D%E5%92%96%E5%95%A1/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><p>转载自：<a href="https://blog.csdn.net/crcr/article/details/6632863#comments" target="_blank" rel="noopener">https://blog.csdn.net/crcr/article/details/6632863#comments</a></p><p>我的白领朋友们，如果我是一个初中没毕业就来沪打工的民工，你会和我坐在“星巴克”一起喝咖啡吗？不会，肯定不会。比较我们的成长历程，你会发现，为了一些在你看来唾手可得的东西，我却需要付出巨大的努力。   </p><p>从我出生的一刻起，我的身份就与你有了天壤之别，因为我只能报农村户口，而你是城市户口。如果我长大以后一直保持农村户口，那么我就无法在城市中找到一份正式工作，无法享受养老保险、医疗保险。你可能会问我：“为什么非要到城市来？农村不很好吗？空气新鲜，又不像城市这么拥挤。”可是农村没有好的医疗条件，去年SARS好像让大家一夜之间发现农村的医疗保健体系竟然如此落后，物质供应也不丰富，因为农民挣的钱少，贵一点儿的东西就买不起，所以商贩也不会进太多货。春节联欢晚会的小品中买得起等离子彩电的农民毕竟是个别现象，绝大多数农民还在为基本的生存而奋斗，于是我要进城，要通过自己的奋斗获得你生下来就拥有的大城市户口。</p><p>考上大学是我跳出农门的惟一机会。我要刻苦学习，小学升初中，初中升高中，高中考大学，我在独木桥上奋勇搏杀，眼看着周围的同学一批批落马，前面的道路越来越窄，我这个佼佼者心里不知是喜是忧。激烈的竞争让我不敢疏忽，除了学习功课，我无暇顾及业余爱好，学校也没有这些发展个人特长的课程。进入高中的第一天，校长就告诉我们这三年只有一个目标——高考。于是我披星戴月，早上5∶30起床，晚上11∶00睡觉，就连中秋节的晚上，我还在路灯下背政治题。</p><p>而你的升学压力要小得多，竞争不是那么激烈，功课也不是很沉重，你可以有充足的时间去发展个人爱好，去读课外读物，去球场挥汗如雨，去野外享受蓝天白云。如果你不想那么辛苦去参加高考，只要成绩不是太差，你可以在高三时有机会获得保送名额，哪怕成绩忒差，也会被“扫”进一所本地三流大学，而那所三流大学我可能也要考到很高的分数才能进去，因为按地区分配的名额中留给上海本地的名额太多了。</p><p>我们的考卷一样我们的分数线却不一样，但是当我们都获得录取通知书的时候，所交的学费是一样的。每人每年6000元，四年下来光学费就要2.4万元，再加上住宿费每人每年1500元，还有书本教材费每年1000元、生活费每年4000元（只吃学校食堂），四年总共5万元。2003年上海某大学以“新建的松江校区环境优良”为由，将学费提高到每人每年1万元，这就意味着仅学费一项四年就要4万元，再加上其他费用，总共6.6万元。6.6万元对于一个上海城市家庭来说也许算不上沉重的负担，可是对于一个农村的家庭，这简直是一辈子的积蓄。我的家乡在东部沿海开放省份，是一个农业大省，相比西部内陆省份应该说经济水平还算比较好，但一年辛苦劳作也剩不了几个钱。以供养两个孩子的四口之家为例，除去各种日常必需开支，一个家庭每年最多积蓄3000元，那么6.6万元上大学的费用意味着22年的积蓄！前提是任何一个家庭成员都不能生大病，而且另一个孩子无论学习成绩多么优秀，都必须剥夺他上大学的权利，因为家里只能提供这么多钱。我属于比较幸运的，东拼西凑加上助学贷款终于交齐了第一年的学费，看着那些握着录取通知书愁苦不堪全家几近绝望的同学，我的心中真的不是滋味。教育产业化时代的大学招收的不仅是成绩优秀的同学，而且还要有富裕的家长。</p><p>我终于可以如愿以偿地在大学校园里汲取知识的养分！努力学习获得奖学金，假期打工挣点生活费，我实在不忍心多拿父母一分钱，那每一分钱都是一滴汗珠掉在地上摔成八瓣挣来的血汗钱啊！</p><p>来到上海这个大都市，我发现与我的同学相比我真是土得掉渣。我不会作画，不会演奏乐器，不认识港台明星，没看过武侠小说，不认得MP3，不知道什么是walkman，为了弄明白营销管理课上讲的“仓储式超市”的概念，我在“麦德隆”好奇地看了一天，我从来没见过如此丰富的商品。</p><p>我没摸过计算机，为此我花了半年时间泡在学校机房里学习你在中学里就学会的基础知识和操作技能。我的英语是聋子英语、哑巴英语，我的发音中国人和外国人都听不懂，这也不能怪我，我们家乡没有外教，老师自己都读不准，怎么可能教会学生如何正确发音？基础没打好，我只能再花一年时间矫正我的发音。我真的很羡慕大城市的同学多才多艺，知识面那么广，而我只会读书，我的学生时代只有学习、考试、升学，因为只有考上大学，我才能来到你们中间，才能与你们一起学习，所有的一切都必须服从这个目标。</p><p>我可以忍受城市同学的嘲笑，可以几个星期不吃一份荤菜，可以周六周日全天泡在图书馆和自习室，可以在周末自习回来的路上羡慕地看着校园舞厅里的成双成对，可以在寂寞无聊的深夜在操场上一圈圈地奔跑。我想有一天我毕业的时候，我能在这个大都市挣一份工资的时候，我会和你这个生长在都市里的同龄人一样——做一个上海公民，而我的父母也会为我骄傲，因为他们的孩子在大上海工作！</p><p>终于毕业了，在上海工作难找，回到家乡更没有什么就业机会。能幸运地在上海找到工作的应届本科生只有每月2000元左右的工资水平，也许你认为这点钱应该够你零花的了，可是对我来说，我还要租房，还要交水电煤电话费还要还助学贷款，还想给家里寄点钱让弟妹继续读书，剩下的钱只够我每顿吃盖浇饭，我还是不能与你坐在“星巴克”一起喝咖啡！</p><p>如今的我在上海读完了硕士，现在有一份年薪七八万的工作。我奋斗了18年，现在终于可以与你坐在一起喝咖啡。我已经融入到这个国际化大都市中了，与周围的白领朋友没有什么差别。可是我无法忘记奋斗历程中那些艰苦的岁月，无法忘记那些曾经的同学和他们永远无法实现的夙愿。于是我以第一人称的方式写下了上面的文字，这些是最典型的中小城市和农村平民子弟奋斗历程的写照。每每看到正在同命运抗争的学子，我的心里总是会有一种沉重的责任感。</p><p>写这篇文章不是为了怨天尤人，这个世界上公平是相对的，这并不可怕，但是对不公平视而不见是非常可怕的。我在上海读硕士的时候，曾经讨论过一个维达纸业的营销案例，我的一位当时曾有三年工作经验，现任一家中外合资公司人事行政经理的同学，提出一个方案：应该让维达纸业开发高档面巾纸产品推向9亿农民市场。我惊讶于她提出这个方案的勇气，当时我问她是否知道农民兄弟吃过饭后如何处理面部油腻，她疑惑地看着我，我用手背在两侧嘴角抹了两下，对如此不雅的动作她投以鄙夷神色。</p><p>在一次宏观经济学课上，我的另一同学大肆批判下岗工人和辍学务工务农的少年：“80%是由于他们自己不努力，年轻的时候不学会一门专长，所以现在下岗活该！那些学生可以一边读书一边打工嘛，据说有很多学生一个暑假就能赚几千元，学费还用愁吗？”我的这位同学太不了解贫困地区农村了。</p><p>我是70年代中期出生的人，我的同龄人正在逐渐成为社会的中流砥柱，我们的行为将影响社会和经济的发展。把这篇文章送给那些在优越环境中成长起来的年轻人和很久以前曾经吃过苦现在已经淡忘的人，关注社会下层，为了这个世界更公平些，我们应该做些力所能及的事情，让社会责任感驻留我们的头脑。</p>]]></content>
      
      
      <categories>
          
          <category> 生活 </category>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Life </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>大冰《好吗好的》读书笔记和读后感</title>
      <link href="/2019/02/10/%E3%80%90Books%E7%B3%BB%E5%88%97%E3%80%912019%E5%B9%B4%E7%AC%AC%E4%B8%80%E6%9C%AC%E4%B9%A6%EF%BC%9A%E5%A4%A7%E5%86%B0%E3%80%8A%E5%A5%BD%E5%90%97%E5%A5%BD%E7%9A%84%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E5%92%8C%E8%AF%BB%E5%90%8E%E6%84%9F/"/>
      <url>/2019/02/10/%E3%80%90Books%E7%B3%BB%E5%88%97%E3%80%912019%E5%B9%B4%E7%AC%AC%E4%B8%80%E6%9C%AC%E4%B9%A6%EF%BC%9A%E5%A4%A7%E5%86%B0%E3%80%8A%E5%A5%BD%E5%90%97%E5%A5%BD%E7%9A%84%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E5%92%8C%E8%AF%BB%E5%90%8E%E6%84%9F/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><img src="/img/read_good_books.png" alt="2019年读书计划"><br>&ensp; &ensp;  2019年初，立下了2019年的奋斗目标和方向。<strong>第二条：读好书，读完6本书，做好读书笔记。</strong> 2018年底和2019年春节断断续续地读完了大冰的《好吗好的》，谨以此作为“读书笔记Books”系列的开篇。<br><img src="/img/haomahaode.png" alt="《好吗好的》封面"></p><h2 id="1、读书笔记"><a href="#1、读书笔记" class="headerlink" title="1、读书笔记"></a>1、读书笔记</h2><h3 id="1-1、封面"><a href="#1-1、封面" class="headerlink" title="1.1、封面"></a>1.1、封面</h3><ul><li>平行世界，多元生活，愿你我既可以朝九晚五，又可以浪迹天涯</li><li>缘浅缘深，缘聚缘散，惜缘随缘莫攀缘</li><li>请相信，这个世界上真的有人在过着你想要的生活</li><li>故事长满天涯海角，包括你和你的故乡</li><li>这本书讲述的是真实的江湖故事，或许会让你看到那些你永远无法去体会的生活，见识那些可能你永远无法结交的人</li><li>不论你年方几何，我都希望这本书于你而言，是一次寻找自我的孤独旅程，亦是一场发现同类的奇妙过程。</li><li>那些曾经温暖过我的，希望亦能温暖你，希望读完这本书的你，能善意地面对这个世界，乃至善意地直面自己，愿你我可以带着微薄的行李和丰盛的自己在世间流浪</li><li>平行世界，多元生活，愿你我既可以朝九晚五，又可以浪迹天涯</li><li>好吗好的</li></ul><h3 id="1-2、夺命大乌苏"><a href="#1-2、夺命大乌苏" class="headerlink" title="1.2、夺命大乌苏"></a>1.2、夺命大乌苏</h3><ul><li>故事长满天涯海角，包括你和你的故乡</li><li><font color="red">回不回头，都留下乡愁。乡愁最虐心，乡愁也最无情，最容易拾起，也最容易丢。苦才是乡愁，不苦则丢。</font></li><li>每一代人有每一代人的乡愁。每一代人有每一代人的新疆。<br>新疆新疆，那里的人们和你我又有撒两样？<br>你有酒，他们也有酒，你有故事，他们也有故事。<br>一样的红尘颠沛，一样的爱恨别离，一样的七情六欲，一样的希望或失望、笃定或迷茫。<br>干吗以正嗣自持，而把新疆当远房？<br>何故以中轴自居，而把新疆当远方？<br>我擦，凭撒？<br>这个时代哪儿还有什么边塞？谁说动人的故事，只配发生在北上广？</li></ul><h3 id="1-3、叔叔再见"><a href="#1-3、叔叔再见" class="headerlink" title="1.3、叔叔再见"></a>1.3、叔叔再见</h3><ul><li>玛蒂尔达：人生总是如此艰难吗，还是只是小时候是这样？<br>莱昂：总是如此。<br>莱昂：不要总说“好的”。好吗？<br>玛蒂尔达：好的。</li><li>我在路上走着，遇到了你，大家微笑点头，结伴一程。<br><font color="red">缘生缘浅，缘聚缘散，该分手时分手，该重逢时重逢。<br>惜缘即可，不必攀缘。<br>随缘即可，无须强求。<br>若有缘再聚，给个微笑就好。<br>若无缘重逢，别忘了我就行。<br>我从不奢望咱们的关系比水更淡薄，比酒更香浓。<br>人生微凉时，有一段共同的回忆可以取暖，已是足够。</font></li></ul><h3 id="1-4、旁人笑我疯癫"><a href="#1-4、旁人笑我疯癫" class="headerlink" title="1.4、旁人笑我疯癫"></a>1.4、旁人笑我疯癫</h3><ul><li><p>这个世界很有趣，有些人忙着做事，有些人忙着做梦，有些人忙着做戏。还有一些人不慌不忙，既做事又做梦，又在人生这场戏里做自己，做来做去做成传奇。</p></li><li><p>哪种传奇？</p><ol><li>平行世界，多元生活</li><li>既可以朝九晚五，又能够浪迹天涯</li><li>有梦为马，随处可栖</li></ol></li><li><p>于这种人而言，多元而平衡的人生方为王道，偏执而单一的社会定位、身份标签，不过是个哧溜屁，这种人从不会给自己设立标准答案，他把人生看做一项多项选择题，在他的生活中，ABCD每个答案都成立。</p></li><li><p>他不屑于只当什么社会的螺丝钉，很多时候他既是螺丝钉还是螺丝帽，同时是把螺丝刀。</p></li><li><p>他不回把世俗成功当作唯一的追求，也懒得一门心思地清高出世，于他而言，出世与入世之间的平衡才有意义。</p></li><li><p>铁成说：世界上几十亿人，起码有几万种生活方式，难道只有一种生活方式才是正确的吗？</p></li><li><p>当那些无话可说，渐渐变成无话可说。我的老朋友，你是否理解我的频频举杯，或偶尔的沉默</p></li><li><p>自由、自我、自在的状态并非一蹴而就，世上哪儿来那么多捷径。人只能靠自己去成全自己，真正对自己负责任的人懂得如何让自己变得完整。</p></li><li><p><font color="red">起点并不决定终点，出身并不决定金身，一辈子这么长，再平庸的人也会遭遇不平凡的人生际遇，你怎么知道你就一定没出息。</font></p></li></ul><h3 id="1-5、寻人启事"><a href="#1-5、寻人启事" class="headerlink" title="1.5、寻人启事"></a>1.5、寻人启事</h3><ul><li>看得懂的，都不是命运。说得清的，都不叫爱情。</li><li>忘得了的，都不是遗憾。听得见的，都不是伤心。</li><li>躲得开的，都不是缘分。猜得透的，都不叫人生。</li><li>和情怀无关，也并非悲悯，结个小善缘而已。</li><li>小就是不深不浅，善就是天性使然，缘就是聚合离散。</li><li><font color="red"> 每个人是每个人的过客，鸟与礁，绿洲与骆驼。</font></li><li>小屋和年夜饭，礁石而已，一年一度浮出海面生起篝火，只能提供短暂的温暖和停歇。</li><li>五大人生建议，哈哈：<ol><li>喜欢就买</li><li>不行就分</li><li>重启试试</li><li>多喝热水</li><li>果断表白</li></ol></li><li>三大神回复，哈哈：<ol><li>关你屁事！</li><li>关我屁事！</li><li>你懂个屁！</li></ol></li><li><font color="red">这是个阶级固化的时代，底层年轻人难以找到上行通道，大部分耗尽整个青春，追求的不过是生存，小部分解决了基本的温饱体面，却也不得不被“安全感”三个字套上缰绳，劳碌奔波。 机会是有的，却是少的，忽悠是有的，却大多不过望梅止渴。。。。。。</font></li><li>但是孩子你听我说：资源和资源配置权的匮乏并不意味着一个人的情感追求也必须匮乏，换言之，你有没有出息和你配不配拥有爱情，蛋关系没有。</li><li>任何情况下都别指望女生对你主动，高级灵长类动物的生物本能决定了雌性生物的矜持本性，漫长的史前岁月里，雌性动物选择配偶时，矜持是淘汰弱者怂货的不二法宝，只有那些强悍自信，能打能杀会觅食，同时擅长啪啪啪的雄性，才能获得最优先的生殖交配权。 </li><li>从生物学角度来讲，生命的意义不过是传递基因信息……   </li><li>世间哪儿来那么多的重逢？擦肩而过往往就是永远错过。   </li><li>冥冥之中似乎有一种促狭的力量，总在暗暗把人的命运操控，想要的得不到，喜欢的都失去，得到的都不过如此，而越是小心翼翼捧着的，越要帮你打翻在地。。。。。</li></ul><h3 id="1-6、台北爸爸"><a href="#1-6、台北爸爸" class="headerlink" title="1.6、台北爸爸"></a>1.6、台北爸爸</h3><ul><li>你真以为你是爸爸啊，或许他也是个孩子。他和你一样，也需要长大。或许你这条小生命的存在，意义非常重大：你给了他一个机会，帮他长大。</li><li>其实真实的人生本就琐碎，如何去桥接、过渡、贯穿，看你自己的喽。</li><li>每个人都是编剧，每个人都是导演，每个人都是主演，一定的年纪后，每个人也都是自己的观众。</li><li>你又不是看着别人活，你又不是活给别人看的。</li><li><font color="red">人活一辈子，心仪的东西一定会遭遇很多，阿宏的理论很简单：很多充满诱惑的东西貌似一开口恳求，就可以轻易获得，可那些充满诱惑的东西往往是最危险的。另外，一个男人处世，有必要在梳理行为模式时，把“求人”二字放在首位吗？</font></li></ul><h3 id="1-7、新疆姑娘"><a href="#1-7、新疆姑娘" class="headerlink" title="1.7、新疆姑娘"></a>1.7、新疆姑娘</h3><ul><li>她说：如果未曾失去过，你又怎会永远记住我。</li></ul><h3 id="1-8、最后一个义工"><a href="#1-8、最后一个义工" class="headerlink" title="1.8、最后一个义工"></a>1.8、最后一个义工</h3><ul><li>钱不钱的和俗不俗蛋关系没有。<br>从某个角度来说，我认可果子那句话—-没资格谈论理想时，先好好挣钱。<br>靠理想活着牛B，靠手艺挣钱吃法也不丢脸。<br>歧路或坦途，船总要有根龙骨，人总要有个信念。</li><li>每个人都有一首惊世骇俗的歌在等着他，只不过找到这首歌，需要米饭和时间。</li><li>不要因为自己搞艺术就盲目鄙视金钱，再高大上的精神追求也需要物质基础的支撑，靠本事吃饭不丢人，留下就认真工作，一边等理想慢慢清晰，一边好好挣钱。</li><li><font color="red">这个世界，看你笑话的人永远比在乎你的人多。</font></li><li>但做事总比不做强，如果一时还没有资格去谈论理想，那就先认真工作，好好挣钱。</li></ul><h3 id="1-9、姐姐"><a href="#1-9、姐姐" class="headerlink" title="1.9、姐姐"></a>1.9、姐姐</h3><ul><li>五毒俱全的姑娘最动人：<br>独立的价值观，独立的思辨能力，独特的生活方式，独特的人格魅力，爱读书。</li><li>一门心思的浪迹天涯，和一门心思的朝九晚五又有什么区别呢？鸡蛋从东篮子放到西篮子而已。谁说生活不如意、学业受打击、爱情不美满、考研考不上，就必须要把旅行这种方式作为解决上述问题的唯一出口呢？<br>旅行不过是生活的一个菜单而已，和正常的吃饭、睡觉，乃至于成年之后的性生活一样，是你人生的一个必然构成部分而已。<br>旅行是维C或B，每个人都需要，但如果谁说维生素C是帮治百病的万能金丹，那谁就是在扯淡。<br><font color="red">吃饭都知道膳食营养合理搭配，为什么面对生活时就偏执了呢？就忘记合理搭配了呢？</font>一切偏执不负责的旅行，都是在对自己的人生耍流氓，最终除了空虚什么也得不到，不经解决不了之前的心病，反会滋生新的疑难杂症</li><li>越是真正的旅行者越懂得去平衡生活。</li><li>越是理智的旅行者越明白去平视生活。</li><li>越是资深的旅行者，越不会煽动人盲目辞职退学去流浪，只把旅行当生活。</li><li>没有办法的时候，坦然受之就是最好的办法。</li><li>知足即般若，天下的好事哪能一个人全都占了。钱嘛，够花就好，有饭吃有床睡，有非常好的女朋友陪，已经是很大的福报了。</li><li>或许有人会说，大部分人的一生不都是这样过来的吗……<br>又会说：大部分人都不能跳出这个人生规律的哦……<br>还会说：大部分人能力有限，一生经营好一种活法已经很难了，同时多几种活法谈何容易……<br>凭什么只能当一颗社会的螺丝钉？为什么不能既当螺丝钉，又当螺丝帽，同时是把螺丝刀。<br>大部分人不等于所有人，重要的也不是能不能，而是想不想。<br>真要是想了，能力值怎么的也能自我营造。<br>所谓的难，不过是你还没有真正的想去要。<br>“想”这个字没错，想也不犯法，有人想当一条腿的高脚椅，也有人相当4条腿的小板凳。有大部分把单一的世俗成功当做人生奋斗目标，也有少部分人想在既定的目标外多寻找几个目标。<br>世人皆把金鸡独立当惯例，我却笃信多几条腿的人生才稳当。<br>任何一个文明健全的社会都应该是多元价值观并行的，同理，任何一个心智健全、人格健全的个体单位的自然人，面对“生活”二字时，是天然享有多项生活选择权的。<br>单一轴心的生活没有错，多项选择的生活也没有错呀。为什么一个人不能趁着年轻，凭借自身的能力，多营造出几个世界呢——每个世界都有一份独立的收入来源，每个世界都有一群不一样的朋友，乃至每个世界都能拥有一份不一样的生活。同时，每个独立世界之间并非寄生关系，而是平行关系，平行之中的多元平衡，是为：平行世界，多元生活。</li><li><font color="red">何为正道？<br>上了大学选择了一份专业，将来就只能靠这一份专业安身立命养家糊口？<br>十八九岁懵懂时选择的那份专业，能定得了你一生的基调？<br>干了一个职业就一辈子只干那个职业？朝九晚五一份工作干到老就是正道？只有五险一金按月领死工资才是正道？</font></li><li>只要你对得起舞台，舞台就会对得起你。我喜欢这句话，年龄越长越发现这句话适用于每一种工作，每一方舞台，乃至任何一个平行世界。</li></ul><h3 id="1-10、去最冷的地方，写最暖的故事"><a href="#1-10、去最冷的地方，写最暖的故事" class="headerlink" title="1.10、去最冷的地方，写最暖的故事"></a>1.10、去最冷的地方，写最暖的故事</h3><ul><li>善意能消戾，善意能得缘，善意能带业往生，善意能回头是岸。</li><li>善意能够帮人捕捉并建立起独特的幸福感。</li><li><font color="red">健全的人生理应是多元的人生、多项选择的人生——先认真体验，再负责地选择。没有任何一种生活方式是天然带有原罪的。但任何一种长期单一模式的生活，都是在对自己犯罪。明知有多项选择的权利却不去主张，那更是错上加错。一门心思地朝九晚五去上班，买了车买了房又如何？一门心思地辞职退学去流浪，从南极到北极有如何？</font></li><li>人的幸福确实不能仅从物质福利中获得满足，但良好的物质条件无疑为精神生活提供了良好条件，为什么要不屑于平衡好二者的关系呢？</li><li>那为什么还要走呢？<br>因为生命应该用来体验和发现，到死之前，我们都是需要发育的孩子。<br>因为尝试和选择这四个字，是年轻的你理所应当的权利。<br>因为疼痛总比苍白好，总比遗憾好，总比无病呻吟的平淡是真要好得多的多。<br>因为对年轻人而言，没有比认认真真地去“犯错”更酷更有意义的事情了。</li></ul><h2 id="2、读后感"><a href="#2、读后感" class="headerlink" title="2、读后感"></a>2、读后感</h2><p>&ensp; &ensp; 读《夺命大乌苏》一节，才知道了新疆除了羊肉串和馕，还有切糕和大盘鸡。没有去过新疆西藏大西北，自然也没吃过大西北的特产，也没见过那里独特的风土人情，突然有种想去新疆的冲动，尝尝新疆的夺命大乌苏。故事中杨奋、马史各自有自己的故事，各自有自己的乡愁。杨奋在书稿中问：世界这么美丽，为什么我们却留在了新疆？他自问自答道：因为这是一个有骨有肉的家，因为我们是新疆的孩子呀。我觉得这是最好的答案，也是对乡愁最贴切的回答。<br>&ensp; &ensp; 大冰所倡导的多元生活的理念与时下流行的“Slash”青年的生活方式有些类似，我也非常赞同多元生活的理念。每个人的人生都是应该丰富多彩的，选择单一的生活方式也会经历这种生活方式下带来的精彩，但是其他生活方式的精彩就会错过了。但遗憾的是，大部分人都在过着单一的生活，过着朝九晚五的生活，这是正确的生活方式，但或许我们还可以选择过一种其他的生活方式?<br>&ensp; &ensp; 看到这篇博文的你，不知道是否有自己希望过的另一种生活方式呢？可以留言在评论区。<br>&ensp; &ensp;&ensp; &ensp;&ensp; &ensp;&ensp; &ensp;&ensp; &ensp;&ensp; &ensp;&ensp; &ensp;&ensp; &ensp;&ensp; &ensp;&ensp; &ensp;&ensp; &ensp;&ensp; &ensp;&ensp; &ensp;&ensp; &ensp;&ensp; &ensp;&ensp; &ensp;&ensp; &ensp;&ensp; &ensp;&ensp; &ensp;&ensp; &ensp;&ensp; 写于2019年春节正月初六</p><hr><h2 id="THE-END"><a href="#THE-END" class="headerlink" title=" THE END!"></a><font color="red"> THE END!</font></h2>]]></content>
      
      
      <categories>
          
          <category> 读书 </category>
          
          <category> 读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Books </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SDK编码器开发框架与海思媒体处理平台架构</title>
      <link href="/2019/01/02/%E3%80%90HISI%E7%B3%BB%E5%88%97%E3%80%91%E4%B9%8BSDK%E7%BC%96%E7%A0%81%E5%99%A8%E5%BC%80%E5%8F%91%E6%A1%86%E6%9E%B6%E4%B8%8E%E6%B5%B7%E6%80%9D%E5%AA%92%E4%BD%93%E5%A4%84%E7%90%86%E5%B9%B3%E5%8F%B0%E6%9E%B6%E6%9E%84/"/>
      <url>/2019/01/02/%E3%80%90HISI%E7%B3%BB%E5%88%97%E3%80%91%E4%B9%8BSDK%E7%BC%96%E7%A0%81%E5%99%A8%E5%BC%80%E5%8F%91%E6%A1%86%E6%9E%B6%E4%B8%8E%E6%B5%B7%E6%80%9D%E5%AA%92%E4%BD%93%E5%A4%84%E7%90%86%E5%B9%B3%E5%8F%B0%E6%9E%B6%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="1、-前言"><a href="#1、-前言" class="headerlink" title="1、 前言"></a>1、 前言</h2><p>&ensp;&ensp; 本文介绍hisi35xx系列，例如HI3519V101编码器开发的大体流程框架，重点分析HISI硬件H264/H265编码器的编码流程和框架。<br>Hi35xx系列芯片作为高清/超高清安防监控主流芯片，现在已经广泛应用于安防监控产品中。本文重点分析：</p><ul><li>海思媒体处理平台架构</li><li>系统架构</li></ul><h2 id="2、HISI-硬件编码器开发框架"><a href="#2、HISI-硬件编码器开发框架" class="headerlink" title="2、HISI 硬件编码器开发框架"></a>2、HISI 硬件编码器开发框架</h2><h3 id="2-1、系统层初始化"><a href="#2-1、系统层初始化" class="headerlink" title="2.1、系统层初始化"></a>2.1、系统层初始化</h3><pre><code class="c">HI_MPI_SYS_GetVersion    :获取MPP的版本号HI_MPI_SYS_Exit            :去初始化MPP系统HI_MPP_VB_Exit            :去初始化MPP视频缓存池HI_MPI_VB_SetConfig        :设置MPP视频缓存池属性HI_MPI_VB_Init            :初始化MPP视频缓存池HI_MPI_SYS_SetConfig    :配置系统控制参数HI_MPI_SYS_Init            :初始化MPP系统</code></pre><h3 id="2-2、编码层初始化"><a href="#2-2、编码层初始化" class="headerlink" title="2.2、编码层初始化"></a>2.2、编码层初始化</h3><p>在创建编码通道之前，需要设置静态属性，包括编码器属性、码率控制属性和GOP模式属性。</p><pre><code class="c">HI_MPI_VENC_CreatChn        :创建编码通道HI_MPI_VENC_StartRecvFrame  :开启编码通道接收输入图像</code></pre><h3 id="2-3、编码层Buffer的设置"><a href="#2-3、编码层Buffer的设置" class="headerlink" title="2.3、编码层Buffer的设置"></a>2.3、编码层Buffer的设置</h3><p>通过缓存块的方式设置YUV Buffer:</p><pre><code class="c">HI_MPI_VB_GetBlock          :获取一个缓存块HI_MPI_VB_Handle2PhysAddr :获取一个缓存块的物理地址HI_MPI_SYS_MmapCache      :存储带Cache映射接口HI_MPI_VB_Handle2PoolId      :获取一个缓存块所在缓存池的ID</code></pre><h3 id="2-4、编码"><a href="#2-4、编码" class="headerlink" title="2.4、编码"></a>2.4、编码</h3><pre><code class="c">HI_MPI_VENC_GetChnAttr    :获取编码通道的编码属性。 HI_MPI_VENC_SetChnAttr 设置编码通道的编码属性HI_MPI_VENC_GetRcParam    :获取通道码率控制高级参数。 HI_MPI_VENC_SetRcParam  设置编码通道码率控制高级参数HI_MPI_SYS_MmzFlushCache:刷新cache里的内容到内存并且使cache里的内容无效HI_MPI_VENC_SendFrame    :支持用户发送原始图像进行编码HI_MPI_VENC_SendFrameEx    :支持用户发送原始图像及该图的QPMAP表信息进行编码HI_MPI_VENC_GetStream    :获取编码码流</code></pre><h3 id="2-5、资源释放、关闭通道"><a href="#2-5、资源释放、关闭通道" class="headerlink" title="2.5、资源释放、关闭通道"></a>2.5、资源释放、关闭通道</h3><pre><code class="c">HI_MPI_SYS_Munmap        ：存储反映射接口HI_MPI_VB_ReleaseBlock    : 释放一个已经获取的缓存块HI_MPI_SYS_MmzFree        : 在用户态释放MMZ内存HI_MPI_VENC_StopRecvFrame:停止编码通道接收输入图像HI_MPI_VENC_DestroyChn   :销毁编码通道HI_MPI_SYS_Exit             :去初始化MPP系统HI_MPP_VB_Exit             :去初始化MPP视频缓存池</code></pre><h2 id="3、HISI开发经验"><a href="#3、HISI开发经验" class="headerlink" title="3、HISI开发经验"></a>3、HISI开发经验</h2><p>由于hisi每一款芯片对各编码协议（如H264/H265/JPEG/MOTION-JPEG）的支持情况不一，有些函数只适用于某几个编码协议，有些函数只适用于某一个编码协议，因此在构建编码器框架时，编码协议类型及编码通道号应在整个框架中传递。</p><h2 id="4、参考和文档下载"><a href="#4、参考和文档下载" class="headerlink" title="4、参考和文档下载"></a>4、参考和文档下载</h2><p>HISI MPP文档：<a href="https://download.csdn.net/download/wjx2000/10878917" target="_blank" rel="noopener">https://download.csdn.net/download/wjx2000/10878917</a><br>SDK编码器开发框架参考：<a href="https://blog.csdn.net/listener51/article/details/85344531" target="_blank" rel="noopener">https://blog.csdn.net/listener51/article/details/85344531</a></p><h2 id="5、参考"><a href="#5、参考" class="headerlink" title="5、参考"></a>5、参考</h2><p><a href="https://blog.csdn.net/qq_17308321/article/details/79741432" target="_blank" rel="noopener">Hi35XXX海思媒体处理平台架构介绍</a><br><a href="https://blog.csdn.net/superHubin/article/details/80751140" target="_blank" rel="noopener">海思MPP业务MMZ内存优化介绍</a><br><a href="https://www.cnblogs.com/chay/p/10413790.html" target="_blank" rel="noopener">海思hi35xx 开发学习(1):海思媒体处理平台架构</a></p><h2 id="6、系统架构"><a href="#6、系统架构" class="headerlink" title="6、系统架构"></a>6、系统架构</h2><p><img src="/img/20190309153520916.png" alt="系统架构"></p><h2 id="7、海思媒体处理平台架构"><a href="#7、海思媒体处理平台架构" class="headerlink" title="7、海思媒体处理平台架构"></a>7、海思媒体处理平台架构</h2><p><img src="/img/20190309151940490.png" alt="海思媒体处理平台架构"></p><p><strong>主要分为:</strong></p><ul><li>视频输入（VI）：VI 模块捕获视频图像，可对其做剪切、去噪等处理，并输出多路不同分辨率的图像数据。</li><li>视频处理（VPSS）：VPSS 模块接收 VI 和解码模块发送过来的图像，可对图像进行图像增强、锐化等处理，并实现同源输出多路不同分辨率的图像数据用于编码、预览或抓拍。</li><li>视频编码（VENC）：编码模块接收 VI 捕获并经 VPSS 处理后输出的图像数据，可叠加用户通过 Region模块设置的 OSD 图像，然后按不同协议进行编码并输出相应码流。</li><li>视频解码（VDEC）：解码模块对编码后的视频码流进行解码，并将解析后的图像数据送 VPSS 进行图像处理，再送 VO 显示。可对 H.265/H.264/JPEG 格式的视频码流进行解码。</li><li>视频输出(VO) ：VO 模块接收 VPSS 处理后的输出图像，可进行播放控制等处理，最后按用户配置的输出协议输出给外围视频设备。</li><li>视频拼接(AVS) ：AVS 接收多路 VI 采集的图像，进行拼接合成全景图像。</li><li>音频输入(AI) ：AI 模块捕获音频数据，然后 AENC 模块支持按多种音频协议对其进行编码，最后输出音频码流。</li><li>音频输出(AO)、音频编码（AENC）、音频解码（ADEC）：用户从网络或外围存储设备获取的音频码流可直接送给 ADEC 模块，ADEC 支持解码多种不同的音频格式码流，解码后数据送给 AO 模块即可播放声音。</li><li>区域管理（REGION）模块。</li></ul><hr><h2 id="THE-END"><a href="#THE-END" class="headerlink" title=" THE  END! "></a><font color="red"> <strong>THE  END!</strong> </font></h2>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 编解码 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Codecs </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python程序变成可执行程序的方法</title>
      <link href="/2018/12/25/%E3%80%90Python%E7%B3%BB%E5%88%97%E3%80%91Python%E7%A8%8B%E5%BA%8F%E5%8F%98%E6%88%90%E5%8F%AF%E6%89%A7%E8%A1%8C%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%96%B9%E6%B3%95/"/>
      <url>/2018/12/25/%E3%80%90Python%E7%B3%BB%E5%88%97%E3%80%91Python%E7%A8%8B%E5%BA%8F%E5%8F%98%E6%88%90%E5%8F%AF%E6%89%A7%E8%A1%8C%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><p>将Python程序变成可执行程序的方法：</p><h2 id="1、步骤一"><a href="#1、步骤一" class="headerlink" title="1、步骤一"></a>1、步骤一</h2><p>1、需要使用pyInstall工具将Python程序变成可执行程序，该工具的使用需要在windows下安装pywin32-218.win32-py2.7.exe工具，<br>下载地址：<a href="https://sourceforge.net/projects/pywin32/files/pywin32/" target="_blank" rel="noopener">https://sourceforge.net/projects/pywin32/files/pywin32/</a> or <a href="https://sourceforge.net/projects/pywin32/files/pywin32/Build%20217/；" target="_blank" rel="noopener">https://sourceforge.net/projects/pywin32/files/pywin32/Build%20217/；</a></p><h2 id="2、步骤二"><a href="#2、步骤二" class="headerlink" title="2、步骤二"></a>2、步骤二</h2><p>2、下载pyInstaller工具，下载路径：<a href="https://sourceforge.net/projects/pyinstaller/files/" target="_blank" rel="noopener">https://sourceforge.net/projects/pyinstaller/files/</a></p><h2 id="3、步骤三"><a href="#3、步骤三" class="headerlink" title="3、步骤三"></a>3、步骤三</h2><p>3、使用方法：</p><pre><code>python pyinstaller.py  --console  --onefile  test.py </code></pre><h2 id="THE-END"><a href="#THE-END" class="headerlink" title=" THE END!"></a><font color="red"> THE END!</font></h2>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MinGW的使用方法和编译</title>
      <link href="/2018/12/21/%E3%80%90%E7%BC%96%E8%AF%91%E5%B7%A5%E5%85%B7%E3%80%91MinGW%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95%E5%92%8C%E7%BC%96%E8%AF%91/"/>
      <url>/2018/12/21/%E3%80%90%E7%BC%96%E8%AF%91%E5%B7%A5%E5%85%B7%E3%80%91MinGW%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95%E5%92%8C%E7%BC%96%E8%AF%91/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="1、参考"><a href="#1、参考" class="headerlink" title="1、参考"></a>1、参考</h2><p><a href="https://www.xuebuyuan.com/2144776.html" target="_blank" rel="noopener">https://www.xuebuyuan.com/2144776.html</a><br><a href="https://blog.csdn.net/k1988/article/details/4375382" target="_blank" rel="noopener">https://blog.csdn.net/k1988/article/details/4375382</a><br><a href="http://www.360doc.com/content/17/1203/15/8728596_709509894.shtml#" target="_blank" rel="noopener">http://www.360doc.com/content/17/1203/15/8728596_709509894.shtml#</a></p><h2 id="2、下载和安装"><a href="#2、下载和安装" class="headerlink" title="2、下载和安装"></a>2、下载和安装</h2><p>官方网址：<a href="http://www.mingw.org/" target="_blank" rel="noopener">http://www.mingw.org/</a><br>mingw-w64下载：<a href="http://www.mingw-w64.org/doku.php" target="_blank" rel="noopener">http://www.mingw-w64.org/doku.php</a><br>SourceForge下载: <a href="https://sourceforge.net/projects/mingw/files/" target="_blank" rel="noopener">https://sourceforge.net/projects/mingw/files/</a></p><h2 id="3、MinGW介绍"><a href="#3、MinGW介绍" class="headerlink" title="3、MinGW介绍"></a>3、MinGW介绍</h2><p><strong>MinGW:</strong></p><blockquote><p>Mininist GNU for Windows, A native Windows port of the GNU Compiler Collection (GCC).</p></blockquote><p>MinGW 提供了一套简单方便的Windows下的基于GCC 的程序开发环境。MinGW 收集了一系列免费的Windows 使用的头文件和库文件；同时整合了GNU ( <a href="http://www.gnu.org/" target="_blank" rel="noopener">http://www.gnu.org/</a> )的工具集，特别是GNU 程序开发工具，如经典gcc, g++, make等。MinGW是完全免费的自由软件，它在Windows平台上模拟了Linux下GCC的开发环境，为C++的跨平台开发提供了良好基础支持，为了在Windows下工作的程序员熟悉Linux下的C++工程组织提供了条件。</p><blockquote><p>MinGW provides a complete Open Source programming tool set which is suitable for the development of native MS-Windows applications, and which do not depend on any 3rd-party C-Runtime DLLs. (It does depend on a number of DLLs provided by Microsoft themselves, as components of the operating system; most notable among these is MSVCRT.DLL, the Microsoft C runtime library. Additionally, threaded applications must ship with a freely distributable thread support DLL, provided as part of MinGW itself).</p></blockquote><blockquote><p>MSYS, a contraction of “Minimal SYStem”, is a Bourne Shell command line interpreter system. Offered as an alternative to Microsoft’s cmd.exe, this provides a general purpose command line environment, which is particularly suited to use with MinGW, for porting of many Open Source applications to the MS-Windows platform; a light-weight fork of Cygwin-1.3, it includes a small selection of Unix tools, chosen to facilitate that objective.</p></blockquote><h2 id="4、MinGW使用方法和编译"><a href="#4、MinGW使用方法和编译" class="headerlink" title="4、MinGW使用方法和编译"></a>4、MinGW使用方法和编译</h2><p>进入 MinGW\msys\1.0\msys.bat，启动minGW命令行环境。如下图所示：<br>此时，就可以使用MinGW中的make和gcc工具进行程序编译了！</p><p><img src="/img/20181221200329711.png" alt="MinGW使用方法和编译"></p><hr><h2 id="THE-END！"><a href="#THE-END！" class="headerlink" title=" THE  END！"></a><font color="red"> <strong>THE  END！</strong></font></h2>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
          <category> 编译工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MinGW </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Cygwin的使用方法和编译</title>
      <link href="/2018/12/21/%E3%80%90%E7%BC%96%E8%AF%91%E5%B7%A5%E5%85%B7%E3%80%91Cygwin%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95%E5%92%8C%E7%BC%96%E8%AF%91/"/>
      <url>/2018/12/21/%E3%80%90%E7%BC%96%E8%AF%91%E5%B7%A5%E5%85%B7%E3%80%91Cygwin%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95%E5%92%8C%E7%BC%96%E8%AF%91/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="1、下载和安装"><a href="#1、下载和安装" class="headerlink" title="1、下载和安装"></a>1、下载和安装</h2><p>主页：<a href="http://www.cygwin.com/" target="_blank" rel="noopener">http://www.cygwin.com/</a><br>下载：<a href="https://cygwin.com/install.html" target="_blank" rel="noopener">https://cygwin.com/install.html</a></p><h2 id="2、Cygwin介绍"><a href="#2、Cygwin介绍" class="headerlink" title="2、Cygwin介绍"></a>2、Cygwin介绍</h2><p>Cygwin is:</p><ul><li>a large collection of GNU and Open Source tools which provide functionality similar to a Linux distribution on Windows.</li><li>a DLL (cygwin1.dll) which provides substantial POSIX API functionality.</li></ul><p>CygWin类似于MinGW，是一个在windows平台上运行的类UNIX模拟环境，可以在Cygwin下面运行几乎所有linux命令。</p><h2 id="3、使用方法"><a href="#3、使用方法" class="headerlink" title="3、使用方法"></a>3、使用方法</h2><p>使用很简单，运行脚本Cygwin.bat，即可启动Cygwin命令行环境，如下图所示：<br><img src="/img/20181221212902699.png" alt="Cygwin命令行环境"></p><p>另外还发现一个有趣的功能：<br>在Cygwin环境下输入cmd，可以切换到window cmd环境下，然后输入exit，可以再次回到Cygwin环境：<br><img src="/img/20181221213050639.png" alt="window cmd环境"></p><hr><h2 id="THE-END"><a href="#THE-END" class="headerlink" title="THE END!"></a><font color="red"><strong>THE END!</strong></font></h2>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
          <category> 编译工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cygwin </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>搭建支持C99源代码编译的vs2010工程的方法(附MinGW下Windows GNU makefile的编写)</title>
      <link href="/2018/12/10/%E3%80%90PE%E7%B3%BB%E5%88%97%E3%80%91%E6%90%AD%E5%BB%BA%E6%94%AF%E6%8C%81C99%E6%BA%90%E4%BB%A3%E7%A0%81%E7%BC%96%E8%AF%91%E7%9A%84vs2010%E5%B7%A5%E7%A8%8B%E7%9A%84%E6%96%B9%E6%B3%95/"/>
      <url>/2018/12/10/%E3%80%90PE%E7%B3%BB%E5%88%97%E3%80%91%E6%90%AD%E5%BB%BA%E6%94%AF%E6%8C%81C99%E6%BA%90%E4%BB%A3%E7%A0%81%E7%BC%96%E8%AF%91%E7%9A%84vs2010%E5%B7%A5%E7%A8%8B%E7%9A%84%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="1、前言"><a href="#1、前言" class="headerlink" title="1、前言"></a>1、前言</h2><p>&ensp; &ensp; 最近在编译一份开源代码时，由于VS对最新标准C实现<strong>C99</strong>的支持性差，在搭建编译环境过程中遇到了一些问题，特记录于此。<br>&ensp; &ensp;  现在很多开源代码（比如x264,ffmpeg）中的C代码都采用c99规范，Linux gcc编译器对c99目前也不是完全支持，但可以通过指定参数-std=c99或-std=gnu99来使用c99规范；VS对c99的支持性就更差了，目前vs2010,vs2012都不支持c99规范，从vs2013开始才部分支持c99规范。因此，问题来了：<br><font color="red">如果我们需要vs2010版本编译的可执行文件或库怎么办呢？</font><br>目前主要有一种解决方案：<br> <strong>采用c99toc89转换工具进行预处理然后送入编译器进行编译。</strong> 具体方法在3小节中讲述 。</p><h2 id="2、参考"><a href="#2、参考" class="headerlink" title="2、参考"></a>2、参考</h2><p><a href="https://blog.csdn.net/SoaringLee_fighting/article/details/84072813" target="_blank" rel="noopener">C99与C89区别以及转换方法</a><br><a href="https://blog.csdn.net/SoaringLee_fighting/article/details/84282140" target="_blank" rel="noopener">C编译标准-std=的设置方法以及工程头文件包含设置</a><br><a href="https://blog.csdn.net/SoaringLee_fighting/article/details/83308984" target="_blank" rel="noopener">C99中stdint.h和inttype.h头文件的使用方法及获取路径</a></p><h2 id="3、搭建支持C99源代码编译的vs2010工程的方法"><a href="#3、搭建支持C99源代码编译的vs2010工程的方法" class="headerlink" title="3、搭建支持C99源代码编译的vs2010工程的方法"></a>3、搭建支持C99源代码编译的vs2010工程的方法</h2><p>采用c99toc89工具：Tool to convert C99 code to MSVC-compatible C89</p><pre><code class="c">Usage: c99wrap $CC $CFLAGS source</code></pre><h3 id="3-1、vs2010工程中使用自定义生成工具搭建（这种方式便于调试分析）"><a href="#3-1、vs2010工程中使用自定义生成工具搭建（这种方式便于调试分析）" class="headerlink" title="3.1、vs2010工程中使用自定义生成工具搭建（这种方式便于调试分析）"></a>3.1、vs2010工程中使用自定义生成工具搭建（这种方式便于调试分析）</h3><p>将工程中所有c文件和cpp文件设置自定义生成工具如下：</p><pre><code class="c">c99wrap cl /c /Fo &quot;Debug\%(Filename).obj&quot; %(FullPath)</code></pre><p>输出设置为：</p><pre><code class="c">Debug\%(Filename).obj;%(Outputs)</code></pre><blockquote><p>注意：<font color="red"> 当前测试发现，在纯VS环境下，使用c99wrap转换工具后编译c99代码仍然会报错！<br>原因： c99wrap.exe工具参数配置有问题导致(c99wrap工具参数解析采用’-c’的形式！)，<br>正确的参数配置如下：</font></p></blockquote><pre><code class="c">c99wrap cl -c -Fo &quot;Debug\%(Filename).obj&quot; %(FullPath)Debug\%(Filename).obj;%(Outputs)</code></pre><p><strong>举个栗子：</strong></p><p>c99toc89_test.project//demo.c:</p><pre><code class="c">#include &lt;stdio.h&gt;int add(int a, int b){   int sum = 0;   for(int i = 0; i&lt; 10; i++)   {      sum += a + b;   }   return sum;}int main(int argc, char* argv[]){  int ret;  ret = sum(5,  5);  return ret;}</code></pre><p>上述代码中for语句采用了c99语法中的for语句内进行变量声明。</p><p><strong>编译结果如下图所示：</strong><br>vs2010下需要使用c99toc89工具先转换一下：<br><img src="/img/20181212234544411.png" alt="转换结果"></p><p>vs2013下可以直接编译通过：<br><img src="/img/20181211225657408.png" alt="编译结果"></p><h3 id="3-2、MinGW环境中利用C99wrap采用编译脚本生成vs2010版本的可执行文件（脚本编译）"><a href="#3-2、MinGW环境中利用C99wrap采用编译脚本生成vs2010版本的可执行文件（脚本编译）" class="headerlink" title="3.2、MinGW环境中利用C99wrap采用编译脚本生成vs2010版本的可执行文件（脚本编译）"></a>3.2、MinGW环境中利用C99wrap采用编译脚本生成vs2010版本的可执行文件（脚本编译）</h3><p>强烈建议采用最新版本的c99wrap(V1.0.3)，对C99基本完全支持。</p><p>下载地址：<a href="https://github.com/libav/c99-to-c89/releases/tag/release-1.0.3" target="_blank" rel="noopener">https://github.com/libav/c99-to-c89/releases/tag/release-1.0.3</a></p><h4 id="3-2-1-编译环境"><a href="#3-2-1-编译环境" class="headerlink" title="3.2.1 编译环境"></a>3.2.1 编译环境</h4><ol><li>首先在启动MinGW环境之前，修改以下脚本（路径：MinGW/msys/1.0/msys.bat），并更名为msys_vs2010_win32/64.bat；<br>在该脚本的最开始添加下面的语句，启动VS运行环境。<pre><code class="bat">rem 对于win32:call &quot;C:\Program Files (x86)\Microsoft Visual Studio 10.0\VC\bin\vcvars32.bat&quot;rem 对于x64:call &quot;C:\Program Files (x86)\Microsoft Visual Studio 10.0\VC\bin\amd64\vcvars64.bat&quot;</code></pre></li><li>启动MinGW环境，运行msys_vs2010_win32.bat或msys_vs2010_win64.bat。</li></ol><h4 id="3-2-2-编译脚本："><a href="#3-2-2-编译脚本：" class="headerlink" title="3.2.2 编译脚本："></a>3.2.2 编译脚本：</h4><p><strong>platform.rules:</strong></p><pre><code class="makefile">OS = $(shell uname)CFLAGS += $(EXTRA_CFLAGS)ifeq($(findstring MINGW, $(OS)),MINGW)CC= c99wrap clCPP= c99wrap clAR= libLD= c99wrap linkASM= yasmifeq($(PLATFORM), x86_32)    CFLAGS += -DWIN32 -DARCH_X86_32 -O2    SFLAGS += -f win32 -DPREFIX    RC = RC -DWIN32endififeq($(PLATFORM), x86_64)    CFLAGS += -DWIN64 -DARCH_X86_64 -O2    SFLAGS += -f x64 -DPREFIX    RC = RC -DWIN64endifendif</code></pre><p><strong>Makefile_lib:</strong></p><pre><code class="makefile">include platform.rulesSRC_DIR = ./srcSRCS := $(wildcard $(SRC_IDR)/*c)OBJS := $(subst .c,.o, $(SRCS))TARGET= libxxx.lib dllxxx.dllDEFS = xxxx.def   #模块定义文件defIMPLIB= dllxxx.lib  #引导库VER = xxx.verPDB_NAME = libxxx.pdbOUT = -outLIBRARY_STATIC = $(OUT):$(filter %.lib, $TARGET))LIBRARY_SHARD = $(OUT):$(filter %.dll, $TARGET))all: $(TARGET)$(filter %.lib, $(TARGET)) : $(OBJS)    $(AR) ＄(LIBRARY_STATIC) $(OBJS)$(filter %.dll, $(TARGET)) : $(OBJS)    makedef $(VER) $(OBJS) &gt; $(DEFS)    $(RC) -fo enc_dll.res enc_dll.rc    $(LD) -dll -def:$(DEFS) -implib: $(IMPLIB) $(LIBRARY_SHARD) $(OBJS) enc_dll.res $(OUTPDB)%.o:%.c    $(CC)  -I.  -I$(SRC_DIR)  $(CFLAGS) $&lt; -o $@%.o:%asm    $(ASM) $(SFLAGS) $&lt; -o $@clean:    rm -f $(OBJS) $(TARGET) $(IMPLIB) $(PDB_NAME)</code></pre><p><strong>Makefile_demo:</strong></p><pre><code class="makefile">include platform.rulesSRC_DEMO_DIR = ../../../demovpath %.c $(SRC_DEMO_DIR)vpath %.h $(SRC_DEMO_DIR)SRCS := $(wildcard $(SRC_DEMO_DIR )/*c)C_OBJS := $(subst .c,.o, $(SRCS))OBJS := $(filter-out ../../demo/osal.o, $(C_OBJS))TARGET= $(BIN_DIR)/xxx.exeLIBXXX := $(LIB_DIR)/libxxx.libOUT = -outCFLAGS += -I $(SRC_DEMO_DIR ) -I../../../include _DWIN32LDFLAGS := -libpath:$(LIB_DIR)all: clean $(LIBXXX) $(TARGET) $(TARGET):$(OBJS)     $(LD) $(LDFLAGS) -PDB:$(BIN_DIR)/demo.pdb -debug -out $@ $(LIBXXX) $(OBJS) &gt; out%.o:%.c:    $(CC) $(CLFAGS) -c -Fo $@ $&lt;$(LIBXXX):    make -C ../lib -f Makfile_libclean:    rm -rf $(C_OBJS) $(TARGET)    make -C ../liib -f Makfile_lib clean</code></pre><h4 id="3-2-3-编译方法"><a href="#3-2-3-编译方法" class="headerlink" title="3.2.3 编译方法"></a>3.2.3 编译方法</h4><pre><code>cd build/demomake -f Makefile_democd build/libmake -f Makefile_lib</code></pre><h4 id="3-2-4-扩展知识"><a href="#3-2-4-扩展知识" class="headerlink" title="3.2.4 扩展知识"></a>3.2.4 扩展知识</h4><ul><li><p>makedef：库符号导出利用了MinGW bin中自带的makedef工具，使用方法很简单，VER文件格式如下：</p><pre><code class="c">LIBXXX {  global: XX_MPEG_*  local: *;};</code></pre></li><li><p>filter与filter-out</p><pre><code class="makefile">$(filter ^lib, $(OBJS))   #从$(OBJS)中找到以lib开头的文件$(filter-out test.o, $(OBJS))   #从$(OBJS)中滤除掉test.o文件</code></pre></li></ul><h2 id="4、采用GnuWin32工具进行windows下gnu-makefile编写"><a href="#4、采用GnuWin32工具进行windows下gnu-makefile编写" class="headerlink" title="4、采用GnuWin32工具进行windows下gnu makefile编写"></a>4、采用GnuWin32工具进行windows下gnu makefile编写</h2><p>参考：<br><a href="https://soaringleefighting.github.io/2018/06/22/%E3%80%90PETools%E7%B3%BB%E5%88%97%E3%80%91GnuWin32%E4%BD%BF%E7%94%A8%E4%BB%A5%E5%8F%8Awindows%E4%B8%8Bgnu%20makefile%E7%BC%96%E5%86%99/">GnuWin32使用以及windows下gnu makefile编写</a></p><hr><h2 id="THE-END"><a href="#THE-END" class="headerlink" title=" THE  END! "></a><font color="red"> THE  END! </font></h2>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 工程化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
            <tag> makefile </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2018/12/08/%E3%80%90Tools%E7%B3%BB%E5%88%97%E3%80%91hello-world/"/>
      <url>/2018/12/08/%E3%80%90Tools%E7%B3%BB%E5%88%97%E3%80%91hello-world/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre><code class="bash">$ hexo new &quot;My New Post&quot;</code></pre><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre><code class="bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre><code class="bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre><code class="bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vim编辑器快捷键使用方法</title>
      <link href="/2018/12/08/%E3%80%90Tools%E7%B3%BB%E5%88%97%E3%80%91vim%E7%BC%96%E8%BE%91%E5%99%A8%E5%BF%AB%E6%8D%B7%E9%94%AE%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/"/>
      <url>/2018/12/08/%E3%80%90Tools%E7%B3%BB%E5%88%97%E3%80%91vim%E7%BC%96%E8%BE%91%E5%99%A8%E5%BF%AB%E6%8D%B7%E9%94%AE%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="1、参考"><a href="#1、参考" class="headerlink" title="1、参考"></a>1、参考</h2><p><a href="https://www.cnblogs.com/sench/p/8482212.html" target="_blank" rel="noopener">vim选中多行复制粘贴</a><br><a href="https://blog.csdn.net/summy_j/article/details/75104748" target="_blank" rel="noopener">vim多行注释与取消</a><br><a href="https://www.cnblogs.com/markleaf/p/7808817.html" target="_blank" rel="noopener">VIM常用快捷键</a><br><a href="https://blog.csdn.net/qq_30214939/article/details/73012738" target="_blank" rel="noopener">【Linux】最全的vim快捷键</a><br><a href="https://www.cnblogs.com/zdj8023/p/10807061.html" target="_blank" rel="noopener">vim替换命令</a></p><h2 id="2、vim快捷键"><a href="#2、vim快捷键" class="headerlink" title="2、vim快捷键"></a>2、vim快捷键</h2><h3 id="2-1-选中多行进行复制粘贴"><a href="#2-1-选中多行进行复制粘贴" class="headerlink" title="2.1 选中多行进行复制粘贴"></a>2.1 选中多行进行复制粘贴</h3><pre><code>1、按v进入可视模式，移动光标选中需要复制的行；2、使用y复制选中块到缓冲区（剪切选中块使用d）；3、将光标移动到粘贴的位置，按p即可。</code></pre><h3 id="2-2-选中多行进行注释或取消注释"><a href="#2-2-选中多行进行注释或取消注释" class="headerlink" title="2.2 选中多行进行注释或取消注释"></a>2.2 选中多行进行注释或取消注释</h3><pre><code>1、在命令行模式下，将光标固定在第一列，按Ctrl+V快捷键进入VB可视化模式；2、上下移动光标，选择你想要注释的行；3、选择好之后，按**大写的**I键进入insert模式，输入注释符“//”或“#”；4、最后按ESC键(两次)，选择的多行已经注释；5、取消注释： 取消多行注释时首先需要光标选中注释符，并选好行数之后。只需按d键（小写），注释就会取消掉了。</code></pre><h3 id="2-3-选中多行进行删除多行或删除列"><a href="#2-3-选中多行进行删除多行或删除列" class="headerlink" title="2.3 选中多行进行删除多行或删除列"></a>2.3 选中多行进行删除多行或删除列</h3><pre><code>1、光标定位到要操作的地方。2、CTRL+V 进入“Visual Block”模式，选取这一列操作多少行。3、d 删除。</code></pre><h3 id="2-4-插入列"><a href="#2-4-插入列" class="headerlink" title="2.4 插入列"></a>2.4 插入列</h3><pre><code>插入操作的步骤和选中多行进行注释的步骤大致相同：1、光标定位到要操作的地方。2、CTRL+v 进入“可视 块”模式，选取这一列操作多少行。3、SHIFT+i(I) 输入要插入的内容。4、ESC 按两次，会在每行的选定的区域出现插入的内容</code></pre><h3 id="2-5-查找"><a href="#2-5-查找" class="headerlink" title="2.5 查找"></a>2.5 查找</h3><pre><code>/something: 在后面的文本中查找something。?something: 在前面的文本中查找something。/pattern/+number: 将光标停在包含pattern的行后面第number行上。/pattern/-number: 将光标停在包含pattern的行前面第number行上。n: 向后查找下一个。N: 向前查找下一个。</code></pre><h3 id="2-6-替换"><a href="#2-6-替换" class="headerlink" title="2.6 替换"></a>2.6 替换</h3><pre><code>:s/old/new - 用new替换当前行第一个old。:s/old/new/g - 用new替换当前行所有的old。:n1,n2s/old/new/g - 用new替换文件n1行到n2行所有的old。:%s/old/new/g - 用new替换文件中所有的old。:%s/^/xxx/g - 在每一行的行首插入xxx，^表示行首。:%s/$/xxx/g - 在每一行的行尾插入xxx，$表示行尾。所有替换命令末尾加上c，每个替换都将需要用户确认。 如：%s/old/new/gc，加上i则忽略大小写(ignore)。</code></pre><p>详细说明如下：<br>在VIM中进行文本替换：</p><pre><code>1.  替换当前行中的内容：    :s/from/to/    （s即substitude）    :s/from/to/     ：  将当前行中的第一个from，替换成to。如果当前行含有多个                        from，则只会替换其中的第一个。    :s/from/to/g    ：  将当前行中的所有from都替换成to。    :s/from/to/gc   ：  将当前行中的所有from都替换成to，但是每一次替换之前都                        会询问请求用户确认此操作。    注意：这里的from和to都可以是任何字符串，其中from还可以是正则表达式。2.  替换某一行的内容：      :33s/from/to/g    :.s/from/to/g   ：  在当前行进行替换操作。    :33s/from/to/g  ：  在第33行进行替换操作。    :$s/from/to/g   ：  在最后一行进行替换操作。3.  替换某些行的内容：      :10,20s/from/to/g    :10,20s/from/to/g   ：  对第10行到第20行的内容进行替换。    :1,$s/from/to/g     ：  对第一行到最后一行的内容进行替换（即全部文本）。    :1,.s/from/to/g     ：  对第一行到当前行的内容进行替换。    :.,$s/from/to/g     ：  对当前行到最后一行的内容进行替换。    :&#39;a,&#39;bs/from/to/g   ：  对标记a和b之间的行（含a和b所在的行）进行替换。                            其中a和b是之前用m命令所做的标记。4.  替换所有行的内容：      :%s/from/to/g    :%s/from/to/g   ：  对所有行的内容进行替换。5.  替换命令的完整形式：    :[range]s/from/to/[flags]    5.1 s/from/to/        把from指定的字符串替换成to指定的字符串，from可以是正则表达式。    5.2 [range]        有以下一些表示方法：        不写range   ：  默认为光标所在的行。        .           ：  光标所在的行。        1           ：  第一行。        $           ：  最后一行。        33          ：  第33行。        &#39;a          ：  标记a所在的行（之前要使用ma做过标记）。        .+1         ：  当前光标所在行的下面一行。        $-1         ：  倒数第二行。（这里说明我们可以对某一行加减某个数值来                        取得相对的行）。        22,33       ：  第22～33行。        1,$         ：  第1行 到 最后一行。        1,.         ：  第1行 到 当前行。        .,$         ：  当前行 到 最后一行。        &#39;a,&#39;b       ：  标记a所在的行 到标记b所在的行。        %           ：  所有行（与 1,$ 等价）。        ?chapter?   ：  从当前位置向上搜索，找到的第一个chapter所在的行。（                        其中chapter可以是任何字符串或者正则表达式。        /chapter/   ：  从当前位置向下搜索，找到的第一个chapter所在的行。（                        其中chapter可以是任何字符串或者正则表达式。        注意，上面的所有用于range的表示方法都可以通过 +、- 操作来设置相对偏        移量。    5.3 [flags]        这里可用的flags有：        无      ：  只对指定范围内的第一个匹配项进行替换。        g       ：  对指定范围内的所有匹配项进行替换。        c       ：  在替换前请求用户确认。        e       ：  忽略执行过程中的错误。        注意：上面的所有flags都可以组合起来使用，比如 gc 表示对指定范围内的        所有匹配项进行替换，并且在每一次替换之前都会请用户确认。</code></pre><hr><h2 id="THE-END"><a href="#THE-END" class="headerlink" title=" THE END! "></a><font color="red"> <strong>THE END!</strong> </font></h2>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
          <category> Linux工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux平台静-动态库中强符号修改工具</title>
      <link href="/2018/11/29/%E3%80%90Tools%E7%B3%BB%E5%88%97%E3%80%91Linux%E5%B9%B3%E5%8F%B0%E9%9D%99-%E5%8A%A8%E6%80%81%E5%BA%93%E4%B8%AD%E5%BC%BA%E7%AC%A6%E5%8F%B7%E4%BF%AE%E6%94%B9%E5%B7%A5%E5%85%B7/"/>
      <url>/2018/11/29/%E3%80%90Tools%E7%B3%BB%E5%88%97%E3%80%91Linux%E5%B9%B3%E5%8F%B0%E9%9D%99-%E5%8A%A8%E6%80%81%E5%BA%93%E4%B8%AD%E5%BC%BA%E7%AC%A6%E5%8F%B7%E4%BF%AE%E6%94%B9%E5%B7%A5%E5%85%B7/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="1、前言"><a href="#1、前言" class="headerlink" title="1、前言"></a>1、前言</h2><p>&ensp; &ensp;  通常在一个大的项目中，可能需要很多不同的库，如果在不同的库中含有相同的符号，就会导致链接出现问题。为了解决不同库中函数符号的冲突，可以在函数符号前面加上前缀以作区分。</p><h2 id="2、nm命令和sed命令用法"><a href="#2、nm命令和sed命令用法" class="headerlink" title="2、nm命令和sed命令用法"></a>2、nm命令和sed命令用法</h2><p>nm命令：查看目标文件中的符号。<br>sed命令：流编辑器，sed命令功能非常强大，尤其是处理字符串流。参考：<a href="https://blog.csdn.net/SoaringLee_fighting/article/details/80912868" target="_blank" rel="noopener">强大的流编辑器sed用法</a></p><p>强符号：全局变量、全局函数<br>弱符号与强符号：</p><p>对于C++来说，弱符号通常来源于<strong>未初始化的全局变量</strong>。而默认情况下，编译器将函数和初始化了的全局变量作为强符号。</p><p>可以通过gcc的 <strong>attribute</strong>((weak)) 来定义任何一个强符号为弱符号。</p><p>不同的目标文件中不能有同名的强符号，否则不能链接在一起。<br>参考：<a href="http://www.cnblogs.com/whos/archive/2010/10/20/1856274.html" target="_blank" rel="noopener">http://www.cnblogs.com/whos/archive/2010/10/20/1856274.html</a></p><p>【用法剖析】<br><a href="http://man.linuxde.net/sed" target="_blank" rel="noopener">http://man.linuxde.net/sed</a><br><a href="https://blog.csdn.net/listener51/article/details/81876907" target="_blank" rel="noopener">https://blog.csdn.net/listener51/article/details/81876907</a></p><h3 id="2-1、sed-b用法"><a href="#2-1、sed-b用法" class="headerlink" title="2.1、sed \b用法"></a>2.1、sed \b用法</h3><h3 id="2-2、通过shell执行perl语句"><a href="#2-2、通过shell执行perl语句" class="headerlink" title="2.2、通过shell执行perl语句"></a>2.2、通过shell执行perl语句</h3><h2 id="3、库中强符号修改脚本"><a href="#3、库中强符号修改脚本" class="headerlink" title="3、库中强符号修改脚本"></a>3、库中强符号修改脚本</h2><p><strong>使用方法：</strong></p><ol><li>在配置文件（如下）config.txt中的相应位置填写相应的路径和符号前后缀</li><li>运行脚本命令： ./refinesymol.sh config.txt</li></ol><p><strong>配置文件config.txt</strong></p><pre><code>#lib path./build/lib/libxxx.a#code path./src#add prefixpre_test_#not modified function prefix or suffixTEST__mmx_sse_3dnow</code></pre><p><strong>强符号修改shell脚本如下：</strong></p><pre><code class="shell">#!/bin/bash## usage: refinesymol.sh config.txtcp $1 config.txt##删除注释行sed -i &quot;s/^#.*//g&quot; config.txtsed -i &quot;/^\$/d&quot; config.txt##删除每行后面的\rsed -i &quot;s/\r//g&quot; config.txt##读取配置信息config_arr=()n=0while read linedo    config_arr[n++]=$linedone &lt; config.txt## 获取数组元素个数arr=${#config_arr[@]}arr_length=$[$arr-1]#config_arr[0] 库的路径#config_arr[1] 代码路径#config_arr[2] 前缀#config_arr[3]...[n-1] 保留的函数名symfile=&#39;symbol.txt&#39;echo ${config_arr[0]}#导出所有定义的符号到文件symfile中nm --define-only ${config_arr[0]} &gt; $symfilecp $symfile file.txt#去掉symfile中的目标文件名sed -i &quot;s/\w\+\.o://g&quot; $symfile#删除所有的弱符号， 只保留强符号sed -i &quot;s/[0-9a-fA-F]\{8,16\} [TRDC] //g&quot; $symfile#每行只保留函数名sed -i &quot;s/[0-9a-fA-F]\{8,16\} [TRDC] //g&quot; $symfile#删除后缀名_sse，mmx的函数和接口函数名for((i=3; i&lt;$arr_length; i++))dosed -i &#39;s/.*&#39;${config_arr[$i]}&#39;\b//g&#39; $symfile  ##删除带后缀的函数sed -i &#39;s/^&#39;${config_arr[$i]}&#39;.*//g&#39; $symfile  ##删除带前缀的函数echo ${config_arr[$i]}#处理函数名前加了下划线的情况sed -i &quot;s/\b_//g&quot; $symfile#去除r表示的带.的名称sed -i &quot;s/.*\..*//g&quot; $symfile#删除空行sed -i &quot;/^\$/d&quot; $symfile#一次处理每个函数名while read linedo    tmp_name=$(echo $line)    echo $tmp_name    new_name=${config_arr[2]}$tmp_name      echo &quot;rename $line to $new_name&quot; &gt;&gt;rename.txt    echo ${config_arr[1]}    find ${config_arr[1]} -name &#39;*.h&#39; -print0 | xargs -0 perl -pi &#39;s/\b&#39;$line&#39;\b/&#39;$new_name&#39;/g&#39;    find ${config_arr[1]} -name &#39;*.c&#39; -print0 | xargs -0 perl -pi &#39;s/\b&#39;$line&#39;\b/&#39;$new_name&#39;/g&#39;    find ${config_arr[1]} -name &#39;*.cpp&#39; -print0 | xargs -0 perl -pi &#39;s/\b&#39;$line&#39;\b/&#39;$new_name&#39;/g&#39;    find ${config_arr[1]} -name &#39;*.asm&#39; -print0 | xargs -0 perl -pi &#39;s/\b&#39;$line&#39;\b/&#39;$new_name&#39;/g&#39;done &lt; $symfile</code></pre><hr><h2 id="THE-END"><a href="#THE-END" class="headerlink" title=" THE END! "></a><font color="read"> <strong>THE END!</strong> </font></h2>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
          <category> 自动化脚本 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> shell </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VS自定义生成工具配置方法和相关VS系统变量含义</title>
      <link href="/2018/11/20/%E3%80%90PE%E7%B3%BB%E5%88%97%E3%80%91Visual%20Studio%E8%87%AA%E5%AE%9A%E4%B9%89%E7%94%9F%E6%88%90%E5%B7%A5%E5%85%B7%E9%85%8D%E7%BD%AE%E6%96%B9%E6%B3%95%E5%92%8C%E7%9B%B8%E5%85%B3vs%E7%B3%BB%E7%BB%9F%E5%8F%98%E9%87%8F%E5%90%AB%E4%B9%89/"/>
      <url>/2018/11/20/%E3%80%90PE%E7%B3%BB%E5%88%97%E3%80%91Visual%20Studio%E8%87%AA%E5%AE%9A%E4%B9%89%E7%94%9F%E6%88%90%E5%B7%A5%E5%85%B7%E9%85%8D%E7%BD%AE%E6%96%B9%E6%B3%95%E5%92%8C%E7%9B%B8%E5%85%B3vs%E7%B3%BB%E7%BB%9F%E5%8F%98%E9%87%8F%E5%90%AB%E4%B9%89/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="1、自定义生成工具配置方法"><a href="#1、自定义生成工具配置方法" class="headerlink" title="1、自定义生成工具配置方法"></a>1、自定义生成工具配置方法</h2><p><strong>以x86纯汇编编译为例：</strong><br>x86纯汇编的编译需要yasm汇编器工具，在VC系统路径下查看当前系统中是否含有可用的yasm.exe：</p><pre><code>where yasm.exe</code></pre><p>可以将yasm.exe放在C盘windows下；<br>如果存在，直接运行yasm.exe会显示：</p><pre><code>yasm：No input files specified</code></pre><p><strong>VS自定义生成工具配置方法：</strong><br>1、首先选中汇编文件，右键属性—》常规—–》项类型—–》自定义生成工具；<br>2、在自定义生成工具中，命令行配置如下：</p><pre><code>yasm -i %(RootDir)%(Directory)\ -f win32 -o $(IntDir)%(Filename).obj %(FullPath)yasm -i %(RootDir)%(Directory)\ -f win64 -o $(IntDir)%(Filename).obj %(FullPath)</code></pre><p>输出设置如下：</p><pre><code>$(IntDir)%(Filename).obj;%(Outputs)</code></pre><h2 id="2、相关vs系统变量含义"><a href="#2、相关vs系统变量含义" class="headerlink" title="2、相关vs系统变量含义"></a>2、相关vs系统变量含义</h2><pre><code>%(RootDir)：当前文件根目录 比如D:\%(Directory)： 当前文件目录，不包含根目录$(IntDir)：中间目录，临时目录，比如Release\%(Filename)：编译文件名，不包含后缀名%(FullPath)：编译源文件的完整路径，包括路径和文件名$(TargetPath)：生成lib,dll或exe目标的路径$(TargetName)：生成lib,dll或exe目标的名字$(ProjectDir)：当前工程vcxproj的路径$(ProjectName)：当前工程的名字$(OutDir)：输出目录$(Platform)：平台名字，x64或win32$(Configuration)：配置名称，Release或Debug</code></pre><hr><h2 id="THE-END"><a href="#THE-END" class="headerlink" title=" THE END! "></a><font color="red"> <strong>THE END!</strong> </font></h2>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 工程化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> VS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ARM交叉编译工具链和编译浮点选项使用说明</title>
      <link href="/2018/11/14/%E3%80%90ARM%E7%B3%BB%E5%88%97%E3%80%91ARM%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91%E5%B7%A5%E5%85%B7%E9%93%BE%E5%92%8C%E7%BC%96%E8%AF%91%E6%B5%AE%E7%82%B9%E9%80%89%E9%A1%B9%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E/"/>
      <url>/2018/11/14/%E3%80%90ARM%E7%B3%BB%E5%88%97%E3%80%91ARM%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91%E5%B7%A5%E5%85%B7%E9%93%BE%E5%92%8C%E7%BC%96%E8%AF%91%E6%B5%AE%E7%82%B9%E9%80%89%E9%A1%B9%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="1、ARM交叉编译工具链-使用方法"><a href="#1、ARM交叉编译工具链-使用方法" class="headerlink" title="1、ARM交叉编译工具链 使用方法"></a>1、ARM交叉编译工具链 使用方法</h2><p>&ensp; &ensp;  arm交叉编译工具链是用于在一种平台上编译出能运行在体系结构不同的另一种平台上的程序，比如在PC平台（X86 CPU）上编译出能运行在以ARM为内核的CPU平台上的程序，编译得到的程序在X86 CPU平台上是不能运行的，必须放到ARM CPU平台上才能运行，虽然两个平台用的都是Linux系统。</p><ul><li>arm-none-linux-gnueabi-gcc：是 Codesourcery 公司（目前已经被Mentor收购）基于GCC推出的的ARM交叉编译工具。可用于交叉编译ARM（32位）系统中所有环节的代码，包括裸机程序、u-boot、Linux kernel、filesystem和App应用程序。</li><li>arm-linux-gnueabihf-gcc：是由 Linaro 公司基于GCC推出的的ARM交叉编译工具。可用于交叉编译ARM（32位）系统中所有环节的代码，包括裸机程序、u-boot、Linux kernel、filesystem和App应用程序。</li><li>aarch64-linux-gnu-gcc：是由 Linaro 公司基于GCC推出的的ARM交叉编译工具。可用于交叉编译ARMv8 64位目标中的裸机程序、u-boot、Linux kernel、filesystem和App应用程序。</li><li>arm-none-elf-gcc：是 Codesourcery 公司（目前已经被Mentor收购）基于GCC推出的的ARM交叉编译工具。可用于交叉编译ARM MCU（32位）芯片，如ARM7、ARM9、Cortex-M/R芯片程序。</li><li>arm-none-eabi-gcc：是 GNU 推出的的ARM交叉编译工具。可用于交叉编译ARM MCU（32位）芯片，如ARM7、ARM9、Cortex-M/R芯片程序。</li><li>arm-linux-androideabi-gcc：编译出运行在Android设备上的应用程序。</li><li>arm-hisiv500-linux-gcc: hisi3519v101交叉编译器</li><li>aarch64-himix100-linux-gcc: hisi3559a v100交叉编译器</li></ul><p>其他相关介绍可以参考：</p><ol><li><a href="https://blog.csdn.net/SoaringLee_fighting/article/details/72494620" target="_blank" rel="noopener">arm交叉编译器gnueabi、none-eabi、arm-eabi、gnueabihf、gnueabi区别</a></li><li><a href="https://blog.csdn.net/SoaringLee_fighting/article/details/70214785" target="_blank" rel="noopener">ARM交叉编译器以及ABI/EABI</a></li><li><a href="https://blog.csdn.net/smilefyx/article/details/73692126" target="_blank" rel="noopener">直接使用ndk提供的arm-linux-androideabi-gcc编译android可执行程序</a></li></ol><p><img src="/img/20181006104655699.png" alt="交叉编译示意图"></p><h2 id="2、ARM平台编译浮点选项-使用说明"><a href="#2、ARM平台编译浮点选项-使用说明" class="headerlink" title="2、ARM平台编译浮点选项 使用说明"></a>2、ARM平台编译浮点选项 使用说明</h2><p>参考自：<a href="https://blog.csdn.net/yuanlu837/article/details/7746274" target="_blank" rel="noopener">https://blog.csdn.net/yuanlu837/article/details/7746274</a></p><p>ABI即“application binary interface”，即编译器将c代码编译成汇编代码时使用的一种规则</p><p>使用规范如下：</p><p>在编译带有浮点参数的函数时，有三种可能的编译选项：</p><pre><code> -mfloat-abi=soft -mfloat-abi=softfp -mfloat-abi=hard</code></pre><p>“soft”选项：表明不使用FPU硬件，而是使用GCC的整数算术运算来模拟浮点运算。</p><p>“softfp”选项：表明要使用FPU硬件来做浮点运算，只是，函数的参数传递到整数寄存器（r0-r3）中，然后再传递到FPU中。</p><p>“hard”选项：表明要使用FPU硬件来做浮点运算，并且，函数的参数直接传递到FPU的寄存器（s0、d0）中</p><p>注意：有的芯片支持这三种选项，有的只是部分支持。若是要启用arm的浮点vfp指令，需要添加这个选项，指明浮点调用的接口；如果不添加，默认不会选择浮点指令集，采用soft选项的运行速度会很慢。</p><hr><h2 id="THE-END！"><a href="#THE-END！" class="headerlink" title="THE END！"></a><font color="red"><strong>THE END！</strong></font></h2>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 优化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ARM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android平台通用编译环境</title>
      <link href="/2018/11/13/%E3%80%90android%E3%80%91Android%E5%B9%B3%E5%8F%B0%E9%80%9A%E7%94%A8%E7%BC%96%E8%AF%91%E7%8E%AF%E5%A2%83/"/>
      <url>/2018/11/13/%E3%80%90android%E3%80%91Android%E5%B9%B3%E5%8F%B0%E9%80%9A%E7%94%A8%E7%BC%96%E8%AF%91%E7%8E%AF%E5%A2%83/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="1、Android-NDK下载：-内含ndk-build"><a href="#1、Android-NDK下载：-内含ndk-build" class="headerlink" title="1、Android NDK下载：(内含ndk-build)"></a>1、Android NDK下载：(内含ndk-build)</h2><p><a href="https://developer.android.google.cn/ndk/downloads/" target="_blank" rel="noopener">https://developer.android.google.cn/ndk/downloads/</a><br><a href="http://www.voidcn.com/article/p-fjfskgpc-bph.html" target="_blank" rel="noopener">http://www.voidcn.com/article/p-fjfskgpc-bph.html</a><br><a href="https://developer.android.google.cn/ndk/guides/stable_apis#purpose" target="_blank" rel="noopener">https://developer.android.google.cn/ndk/guides/stable_apis#purpose</a></p><h2 id="2、Android平台通用编译环境"><a href="#2、Android平台通用编译环境" class="headerlink" title="2、Android平台通用编译环境"></a>2、Android平台通用编译环境</h2><h3 id="2-1、Linux下编译Android程序（shell脚本）"><a href="#2-1、Linux下编译Android程序（shell脚本）" class="headerlink" title="2.1、Linux下编译Android程序（shell脚本）"></a>2.1、Linux下编译Android程序（shell脚本）</h3><pre><code class="shell">#!/bin/bashif [ $# -ne 1]; then    echo &quot;./build.sh ndk_dir&quot;    exitfi# get current dirPJTDIR=$(pwd)#check if we are in the ndk directorycd $1if [ ! -f &quot;ndk-build&quot;]; then    echo &quot;Run this script under NDK directory\n&quot;    exitfiecho &quot;------------------------clear output dir-------------------------&quot;find $PJTDIR/obj -name &quot;*.[od]&quot; | xargs rm -rffind $PJTDIR/obj -name &quot;*.so&quot; | xargs rm -rffind $PJTDIR/libs -name  &quot;*.so&quot; | xargs rm -rffind $PJTDIR/out -name &quot;*.so&quot; | xargs rm -rffind $PJTDIR/obj -name &quot;*.[od]&quot; | xargs rm -rffind $PJTDIR/obj -name &quot;*.a&quot; | xargs rm -rffind $PJTDIR/libs -name  &quot;*.a&quot; | xargs rm -rffind $PJTDIR/out -name &quot;*.a&quot; | xargs rm -rfecho &quot;------------------------build static library----------------------&quot;#cp $PJRDOR/jni/Android_lib.mk $PJRLIB/jni/Android.mk./ndk-build -B -C $PJTDIR APP_BUILD_SCRIPT:=Android_lib.mkcp  $PJTDIR/obj/local/armeabi/libxxx.a  $PJTDIR/out/armeabi/cp  $PJTDIR/obj/local/armeabi-v7a/libxxx.a  $PJTDIR/out/armeabi-v7a/cp  $PJTDIR/obj/local/arm64-v8a/libxxx.a  $PJTDIR/out/arm64-v8a/cp  $PJTDIR/obj/local/x86/libxxx.a  $PJTDIR/out/x86/cp  $PJTDIR/obj/local/x86_64/libxxx.a  $PJTDIR/out/x86_64/cp  $PJTDIR/obj/local/mips/libxxx.a  $PJTDIR/out/mips/cp  $PJTDIR/obj/local/mips64/libxxx.a  $PJTDIR/out/mips64/echo &quot;------------------------build dynamic library----------------------&quot;#cp $PJRDOR/jni/Android_lib.mk $PJRLIB/jni/Android.mk./ndk-build -B -C $PJTDIR APP_BUILD_SCRIPT:=Android_lib.mkcp  $PJTDIR/obj/local/armeabi/libxxx.so $PJTDIR/out/armeabi/cp  $PJTDIR/obj/local/armeabi-v7a/libxxx.so  $PJTDIR/out/armeabi-v7a/cp  $PJTDIR/obj/local/arm64-v8a/libxxx.so  $PJTDIR/out/arm64-v8a/cp  $PJTDIR/obj/local/x86/libxxx.so  $PJTDIR/out/x86/cp  $PJTDIR/obj/local/x86_64/libxxx.so  $PJTDIR/out/x86_64/cp  $PJTDIR/obj/local/mips/libxxx.so  $PJTDIR/out/mips/cp  $PJTDIR/obj/local/mips64/libxxx.so  $PJTDIR/out/mips64/echo &quot;------------------------build dynamic executable----------------------&quot;#cp $PJRDOR/jni/Android_app.mk  $PJRLIB/jni/Android.mk./ndk-build -B -C $PJTDIR APP_BUILD_SCRIPT:=Android_app.mkcp  $PJTDIR/obj/local/armeabi/xxx $PJTDIR/out/armeabi/cp  $PJTDIR/obj/local/armeabi-v7a/xxx  $PJTDIR/out/armeabi-v7a/cp  $PJTDIR/obj/local/arm64-v8a/xxx  $PJTDIR/out/arm64-v8a/cp  $PJTDIR/obj/local/x86/xxx  $PJTDIR/out/x86/cp  $PJTDIR/obj/local/x86_64/xxx  $PJTDIR/out/x86_64/cp  $PJTDIR/obj/local/mips/xxx  $PJTDIR/out/mips/cp  $PJTDIR/obj/local/mips64/xxx  $PJTDIR/out/mips64/echo &quot;------------------------build static executable----------------------&quot;#cp $PJRDOR/jni/Android_app_static.mk  $PJRLIB/jni/Android.mk./ndk-build -B -C $PJTDIR APP_BUILD_SCRIPT:=Android_app_static.mkcp  $PJTDIR/obj/local/armeabi/xxx $PJTDIR/out/armeabi/cp  $PJTDIR/obj/local/armeabi-v7a/xxx  $PJTDIR/out/armeabi-v7a/cp  $PJTDIR/obj/local/arm64-v8a/xxx  $PJTDIR/out/arm64-v8a/cp  $PJTDIR/obj/local/x86/xxx  $PJTDIR/out/x86/cp  $PJTDIR/obj/local/x86_64/xxx  $PJTDIR/out/x86_64/cp  $PJTDIR/obj/local/mips/xxx  $PJTDIR/out/mips/cp  $PJTDIR/obj/local/mips64/xxx  $PJTDIR/out/mips64/echo &quot;------------------------tar---------------------&quot;tar -zcvf $PJTDIR/out/libxxx_android_armeabi.tar.gz  -C $PJTDIR/out/armeabi/tar -zcvf $PJTDIR/out/libxxx_android_armeabi-v7a.tar.gz  -C $PJTDIR/out/armeabi-v7a/tar -zcvf $PJTDIR/out/libxxx_android_arm64-v8a.tar.gz  -C $PJTDIR/out/arm64-v8a/tar -zcvf $PJTDIR/out/libxxx_android_x86.tar.gz  -C $PJTDIR/out/x86/tar -zcvf $PJTDIR/out/libxxx_android_x86_64.tar.gz  -C $PJTDIR/out/x86_64/tar -zcvf $PJTDIR/out/libxxx_android_mips.tar.gz  -C $PJTDIR/out/mips/tar -zcvf $PJTDIR/out/libxxx_android_mips64.tar.gz  -C $PJTDIR/out/mips64/echo &quot;------------------------check results---------------------&quot;ls -l $PJTDIR/outls -l $PJTDIR/armeabils -l $PJTDIR/armeabi-v7als -l $PJTDIR/arm64-v8als -l $PJTDIR/x86ls -l $PJTDIR/x86-64ls -l $PJTDIR/mipsls -l $PJTDIR/mips-64</code></pre><p>其中：核心命令为：<br><code>./ndk-build -B -C $PJTDIR APP_BUILD_SCRIPT:=Android_lib.mk</code><br>其中，-B表示强制rebuild，-C表示Android.mk和Application.mk两个文件夹所在路径，就是指定makefile的路径，与linux中make -C dir是同一个含义，APP_BUILD_SCRIPT用于指定编译的makefile，同linux中的make -f makefile，NDK_PROJECT_PATH用于指定makefile的路径。</p><blockquote><p>注意：<br>1、无论是编译动态库、静态库还是可执行文件，都需要各自对应的Android.mk和Application.mk这两个文件。<br>2、Application.mk通常用于指定需要编译的平台的个数，比如<br>APP_ABI := x86 x86_64 armeabi armeabi-v7a arm64-v8a<br>APP_PLATFORM := android-9<br>NDK_TOOLCHAIN_VERSION := 4.9<br>3、Android.mk相当于被Applicatioin.mk调用的，即每个平台都会调用一次Android.mk产生一个相应平台的编译出来的模块。</p></blockquote><p>不同 CPU 和架构的 ABI 设置如下表所示：</p><table><thead><tr><th>CPU 和架构</th><th>设置</th></tr></thead><tbody><tr><td>ARMv5TE</td><td>armeabi</td></tr><tr><td>ARMv7</td><td>armeabi-v7a</td></tr><tr><td>ARMv8 AArch64</td><td>arm64-v8a</td></tr><tr><td>i686</td><td>x86</td></tr><tr><td>x86-64</td><td>x86_64</td></tr><tr><td>mips32 (r1)</td><td>mips</td></tr><tr><td>mips64 (r6)</td><td>mips64</td></tr><tr><td>全部</td><td>all</td></tr></tbody></table><h3 id="2-2、Window下编译Android程序（Python脚本）"><a href="#2-2、Window下编译Android程序（Python脚本）" class="headerlink" title="2.2、Window下编译Android程序（Python脚本）"></a>2.2、Window下编译Android程序（Python脚本）</h3><p>在没有shell环境情况下，采用windows环境下的python脚本：</p><pre><code class="python">//cmd=&quot;ndk-build -B -C ./ NDK_PROJECT_PATH=./ APP_BUILD_SCRIPT=./Android.mk&quot;#coding=utf8import osimport sysimport globimport shutilimport platformfrom sys import argvshare_lib_name = &#39;libxxx.so&#39;static_lib_name =  &#39;libxxx.a&#39;static_exe = &#39;demo&#39;#检查是否为windows系统def  isWindowsSys():    return &#39;Windows&#39; in platform.system()#检查是否为Linux系统def  isLinuxSys():    return &#39;Linux&#39; in platform.system()#清空目录下的内容def delDirFile(path):    def i in os.listdir(path):        file_path = os.path.join(path, i)        if os.path.isfile(file_path):            os.remove(file_path)        else            delDirFile(file_path)def process(ndk_dir, android_dir, pure_c, delimiter):    ndk_build = ndk_dir + delimiter + &#39;ndk-build&#39;    app_mk = android_dir + delimiter + &#39;jni&#39; + delimiter + &#39;Application.mk&#39;    mk_dir = android_dir + delimiter + &#39;jni&#39;    static_lib_dir = android_dir + delimiter + &#39;obj&#39; + delimiter + &#39;local&#39; + delimiter    out_sha_lib = android_dir + delimiter + &#39;out&#39; + delimiter    share_lib_dir = android_dir + delimiter + &#39;obj&#39; + delimiter + &#39;local&#39; + delimiter    out_sta_lib = android_dir + delimiter + &#39;out&#39; + delimiter    if isWindowsSys():        cpy = &quot;copy &quot;    else:        cpy = &quot;cp &quot;# &quot;=================CLEAR OUTPUT DIR=========================&quot;outdir_files = glob.glob(android_dir + delimiter + &#39;out&#39; + delimiter + &#39;*&#39;)for outdir in outdir_files:    print(outdir)    delDelFile(outdir)    isExist = os.path.exists(ourdir)    if(not isExist):        os.mkdir(outdir)pFile = open(app_mk, &#39;w&#39;)cmd = &#39;APP_ABI := x86 x86_64 armeabi armeabi-v7a arm64-v8a \nAPP_PLATFORM := android-9\nNDK_TOOLCHAIN_VERSION := 4.9&#39;pFile.writeLines(cmd)pFile.write(&#39;\n&#39;)pFile.close()# &quot;==================BUILD SHARED LIBRARY====================&quot;cmd = ndk_build + &quot; -B &quot; + &quot;NDK_PROJECT_PATH:=&quot; + android_dir + &quot;APP_BUILD_SCRIPT:=&quot; + mk_dir + delimiter + &quot;Android_lib.mk&quot; + &quot; V=1 SHARED=0&quot;print(cmd)os.system(cmd)cmd = cpy + share_lib_dir + &quot;x86&quot; + delimiter + share_lib_name + &quot;  &quot; + out_sha_lib + &quot;x86&quot; + delimiterprint(cmd)os.system(cmd)##其他平台依次类推# &quot;==================BUILD STATIC LIBRARY====================&quot;cmd = ndk_build + &quot; -B &quot; + &quot;NDK_PROJECT_PATH:=&quot; + android_dir + &quot;APP_BUILD_SCRIPT:=&quot; + mk_dir + delimiter + &quot;Android_lib.mk&quot;print(cmd)os.system(cmd)cmd = cpy + static_lib_dir + &quot;x86&quot; + delimiter + static_lib_name + &quot;  &quot; + out_sta_lib + &quot;x86&quot; + delimiterprint(cmd)os.system(cmd)##其他平台依次类推# &quot;==================BUILD STATIC EXE ====================&quot;cmd = ndk_build + &quot; -B &quot; + &quot;NDK_PROJECT_PATH:=&quot; + android_dir + &quot;APP_BUILD_SCRIPT:=&quot; + mk_dir + delimiter + &quot;Android_app.mk&quot;print(cmd)os.system(cmd)cmd = cpy + static_lib_dir + &quot;x86&quot; + delimiter + static_lib_name + &quot;  &quot; + out_sta_lib + &quot;x86&quot; + delimiterprint(cmd)os.system(cmd)##其他平台依次类推##############################main函数入口######################if __name__ == &#39;__main__&#39;:    if(len(argv) &lt; 3):        printf(&quot;Tips: build_android.py android_ndk_dir pure_c=0/1\n&quot;)        exit()    delimiter =os.path.sep    ndk_dir = argv[1]    pure_c = argv[2]    android_dir = os.getcwd()    process(ndkdir,android_dir,pure_c,delimiter)</code></pre><h2 id="3、Android平台真机测试方法"><a href="#3、Android平台真机测试方法" class="headerlink" title="3、Android平台真机测试方法"></a>3、Android平台真机测试方法</h2><p><a href="https://blog.csdn.net/SoaringLee_fighting/article/details/82908698" target="_blank" rel="noopener">android真机测试方法</a></p><h2 id="4、Android平台通用编译模板"><a href="#4、Android平台通用编译模板" class="headerlink" title="4、Android平台通用编译模板"></a>4、Android平台通用编译模板</h2><p><a href="https://soaringleefighting.github.io/2018/11/13/%E3%80%90android%E3%80%91Android%E5%B9%B3%E5%8F%B0%E9%80%9A%E7%94%A8%E7%BC%96%E8%AF%91%E6%A8%A1%E6%9D%BF%20/">Android平台通用编译模板</a></p><h2 id="5、参考"><a href="#5、参考" class="headerlink" title="5、参考"></a>5、参考</h2><p><strong>关于Application.mk,Android.mk和JNI的介绍更多可参考：</strong><br><a href="https://developer.android.google.cn/ndk/guides/android_mk" target="_blank" rel="noopener">https://developer.android.google.cn/ndk/guides/android_mk</a><br><a href="https://developer.android.google.cn/ndk/guides/application_mk" target="_blank" rel="noopener">https://developer.android.google.cn/ndk/guides/application_mk</a><br><a href="https://developer.android.google.cn/ndk/guides/ndk-build" target="_blank" rel="noopener">https://developer.android.google.cn/ndk/guides/ndk-build</a><br><a href="https://www.ibm.com/developerworks/cn/opensource/os-cn-android-build/" target="_blank" rel="noopener">https://www.ibm.com/developerworks/cn/opensource/os-cn-android-build/</a><br><a href="https://blog.csdn.net/yuanjize1996/article/details/54376228" target="_blank" rel="noopener">https://blog.csdn.net/yuanjize1996/article/details/54376228</a><br><a href="https://blog.csdn.net/xyz_lmn/article/details/6966259/" target="_blank" rel="noopener">https://blog.csdn.net/xyz_lmn/article/details/6966259/</a></p><hr><h2 id="THE-END！"><a href="#THE-END！" class="headerlink" title="THE END！"></a><font color="red"><strong>THE END！</strong></font></h2>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 工程化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android平台编译makefile编写规则</title>
      <link href="/2018/11/13/%E3%80%90android%E3%80%91Android%E5%B9%B3%E5%8F%B0%E7%BC%96%E8%AF%91makefile%E7%BC%96%E5%86%99%E8%A7%84%E5%88%99/"/>
      <url>/2018/11/13/%E3%80%90android%E3%80%91Android%E5%B9%B3%E5%8F%B0%E7%BC%96%E8%AF%91makefile%E7%BC%96%E5%86%99%E8%A7%84%E5%88%99/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="1、参考"><a href="#1、参考" class="headerlink" title="1、参考"></a>1、参考</h2><p><a href="https://www.ibm.com/developerworks/cn/opensource/os-cn-android-build/" target="_blank" rel="noopener">https://www.ibm.com/developerworks/cn/opensource/os-cn-android-build/</a><br><a href="https://blog.csdn.net/yuanjize1996/article/details/54376228" target="_blank" rel="noopener">https://blog.csdn.net/yuanjize1996/article/details/54376228</a><br><a href="https://blog.csdn.net/xyz_lmn/article/details/6966259/" target="_blank" rel="noopener">https://blog.csdn.net/xyz_lmn/article/details/6966259/</a><br><a href="https://developer.android.google.cn/ndk/guides/stable_apis#purpose" target="_blank" rel="noopener">https://developer.android.google.cn/ndk/guides/stable_apis#purpose</a></p><p>android ndk下载：(内含ndk-build)<br><a href="https://developer.android.google.cn/ndk/downloads/" target="_blank" rel="noopener">https://developer.android.google.cn/ndk/downloads/</a><br><a href="http://www.voidcn.com/article/p-fjfskgpc-bph.html" target="_blank" rel="noopener">http://www.voidcn.com/article/p-fjfskgpc-bph.html</a></p><p>说明：当前最新版本的android-ndk版本是r16b。</p><p>Android NDK说明：<br>主要是包括编译C/C++/ASM代码的编译器，需要按照ndk相关规则进行程序的编译。因此ndk编译器需要编写符合android规则的makefile才能编译。</p><h2 id="2、android平台makefile编写方法"><a href="#2、android平台makefile编写方法" class="headerlink" title="2、android平台makefile编写方法"></a>2、android平台makefile编写方法</h2><p><a href="http://android.mk/#intro" target="_blank" rel="noopener">http://android.mk/#intro</a>  该网址下面有Android.mk的详细编写方法。</p><p><strong>在任意目录执行NDK编译：</strong></p><h3 id="2-1-准备环境"><a href="#2-1-准备环境" class="headerlink" title="2.1  准备环境"></a>2.1  准备环境</h3><p>首先，你得安装了Android的NDK编译工具，假设你的NDK的根目录在 /opt/android/ndk .<br>当然，最好你能在环境变量里配置一下路径，否则使用ndk-build命令的时候，都得加上路径的前缀了。</p><p>修改 ~/.bashrc</p><pre><code class="shell">export NDK_HOME=/opt/android/ndkexport PATH=$NDK_HOME:$PATH</code></pre><p>然后执行：</p><pre><code class="shell">$ source ~/.bashrc</code></pre><h3 id="2-2-编写-c-文件"><a href="#2-2-编写-c-文件" class="headerlink" title="2.2 编写 .c 文件"></a>2.2 编写 .c 文件</h3><p>假设你在 ~/math 目录下编写了一个 math.c 文件，内容如下：</p><pre><code class="c">#include &lt;stdio.h&gt;int add( int a , int b ) {    return a+b;}</code></pre><p>OK，后面我们就准备在 ~/math 目录下，将这个.c文件编译为Android可使用的静态库/动态库了。</p><h3 id="2-3-编译成动态库"><a href="#2-3-编译成动态库" class="headerlink" title="2.3 编译成动态库"></a>2.3 编译成动态库</h3><p>编写 Android.mk 文件，内容如下：</p><pre><code class="shell">LOCAL_PATH := $(call my-dir)include $(CLEAR_VARS)LOCAL_MODULE := dmathLOCAL_SRC_FILES := math.cinclude $(BUILD_SHARED_LIBRARY)</code></pre><p>在 ~/math 目录下，执行 ndk-build 命令，参数如下：</p><pre><code class="shell">$ ndk-build -B  NDK_PROJECT_PATH=. APP_BUILD_SCRIPT=./Android.mk</code></pre><p>其中，NDK_PROJECT_PATH 指定了需要编译的代码的工程目录，这里给出的是当前目录，APP_BUILD_SCRIPT给出的是Android makefile文件的路径，当然，如果你还有 Application.mk 文件的话，则可以添加</p><pre><code class="shell">NDK_APP_APPLICATION_MK=./Application.mk</code></pre><p>执行完ndk-build命令后，你会发现当前目录下，生成了 obj 和 libs 文件夹，这样，你的libdmath.so动态库就已经制作完成了，在 libs/armeabi 目录下。</p><h3 id="2-4-编译为静态库"><a href="#2-4-编译为静态库" class="headerlink" title="2.4  编译为静态库"></a>2.4  编译为静态库</h3><p>编译为静态库，与编译为动态库唯一的区别就是 Android.mk 文件的写法不同，另外，如果要编译为静态库，则必须有其他的代码引用该静态库代码，ndk-build才会真正执行，否则无法成功生成静态库，这里，我们编写一个 Android.mk ，将 math.c 同时编译成静态库和动态库。</p><pre><code class="shell">LOCAL_PATH := $(call my-dir)include $(CLEAR_VARS)LOCAL_MODULE := smathLOCAL_SRC_FILES := math.cinclude $(BUILD_STATIC_LIBRARY)</code></pre><p>同样，在 ～/math 目录下执行：</p><pre><code class="shell">$ ndk-build NDK_PROJECT_PATH=. APP_BUILD_SCRIPT=./Android.mk</code></pre><p>你会在生成的 libs/armeabi 目录下看到动态库libdmath.so，在 obj/local/armeabi 目录下看到静态库 libsmath.a。</p><h3 id="2-5-编译成可执行文件"><a href="#2-5-编译成可执行文件" class="headerlink" title="2.5 编译成可执行文件"></a>2.5 编译成可执行文件</h3><p>大部分编译规则与动静态库的书写方法一样，主要是加上下面语句：</p><pre><code class="shell">include $(BUILD_EXECUTABLE)</code></pre><h2 id="3、常用NDK命令行参数："><a href="#3、常用NDK命令行参数：" class="headerlink" title="3、常用NDK命令行参数："></a>3、常用NDK命令行参数：</h2><p>参考：<a href="http://blog.51cto.com/ticktick/1425857" target="_blank" rel="noopener">http://blog.51cto.com/ticktick/1425857</a></p><p>Android提供了NDK工具，用来编译native代码（c/c++），该工具配置好了相关的交叉编译环境和工具链，只需要你简单地编写几个.mk文件即可将你的c/c++代码编译为Android的java工程/Android手机可以识别、加载和运行的库或者应用程序。</p><p>默认情况下，使用NDK编译c/c++代码，需要将该代码放置到任一个Android应用工程的jni目录下，然后编写相应的Android.mk文件，并执行ndk-build命令完成编译。其实你也是可以在任意目录下去编译native代码的，只需要在ndk-build命令后面添加相应的命令行参数即可，这里给出一些常用的ndk-build命令行参数，方便大家灵活地使用NDK编译自己的native代码。</p><pre><code>1. ndk-build NDK_LOG=1用于配置LOG级别，打印ndk编译时的详细输出信息2. ndk-build NDK_PROJECT_PATH=.指定NDK编译的代码路径为当前目录，如果不配置，则必须把工程代码放到Android工程的jni目录下3. ndk-build APP_BUILD_SCRIPT=./Android.mk指定NDK编译使用的Android.mk文件4. ndk-build NDK_APP_APPLICATION_MK=./Application.mk指定NDK编译使用的application.mk文件5. ndk-build clean清除所有编译出来的临时文件和目标文件6. ndk-build -B强制重新编译已经编译完成的代码7. ndk-build NDK_DEBUG=1执行 debug build8. ndk-build NDK_DEBUG=0执行 release build9. ndk-build NDK_OUT=./mydir指定编译生成的文件的存放位置10. ndk-build -C /opt/myTest/到指定目录编译native代码   </code></pre><h2 id="4、ndk工程目录编译后libs与obj目录下库文件的区别"><a href="#4、ndk工程目录编译后libs与obj目录下库文件的区别" class="headerlink" title="4、ndk工程目录编译后libs与obj目录下库文件的区别"></a>4、ndk工程目录编译后libs与obj目录下库文件的区别</h2><p>参考：<a href="https://blog.csdn.net/bidgod/article/details/6930440" target="_blank" rel="noopener">https://blog.csdn.net/bidgod/article/details/6930440</a><br>在执行NDK编译之后，编译器会生成libs和obj两个目录，并且libs/armeabi中和obj/local/armeabi中都包含可执行文件和动态库，区别何在呢？</p><blockquote><p>As part of the build process, the files in the libs folder have been stripped of symbols and debugging information. So you’ll want to keep two copies of each of your .so files: One from the libs folder to install on the Android device, and one from the obj folder to install for GDB to get symbols from.<br>libs目录下生成的库是剥离了符号表与调试信息的，而obj下的库是带有调试信息的。</p></blockquote><h2 id="5、Android-mk和Application-mk说明"><a href="#5、Android-mk和Application-mk说明" class="headerlink" title="5、Android.mk和Application.mk说明"></a>5、Android.mk和Application.mk说明</h2><p>关于Application.mk , Android.mk和JNI的介绍可参考：<br><a href="https://developer.android.google.cn/ndk/guides/android_mk" target="_blank" rel="noopener">https://developer.android.google.cn/ndk/guides/android_mk</a><br><a href="https://developer.android.google.cn/ndk/guides/application_mk" target="_blank" rel="noopener">https://developer.android.google.cn/ndk/guides/application_mk</a><br>通用模块编译可以采用Android_lib.mk，Android_app.mk和common.mk以及Application.mk采用ndk-build进行编译。<br><strong>libmpeg2解码器的Android平台编译：</strong><br><a href>libmpeg2解码器的Android平台编译</a><br>示例：<br>common.mk:设置源文件目录以及头文件目录：配置LOCAL_C_INCLUDES和LOCAL_SRC_FILES.<br>Android_lib.mk:设置编译参数、特定平台编译参数、编译动静态库配置：配置LOCAL_PATH，LOCAL_MODULE，LOCAL_CFLAGS，LOCAL_CPPFLAGS。<br>Application.mk：设置APP_ABI，APP_PLATFORM和NDK_TOOLCHAIN_VERSION等。<br><font color="red"> 补充说明及注意事项：<br>汇编(.asm,.S,.s)文件的编译参数设置：<strong>LOCAL_ASMFLAGS</strong><br>C文件编译参数设置：<strong>LOCAL_CFLAGS</strong><br>C++文件编译参数设置：<strong>LOCAL_CPPFLAGS</strong><br>链接器参数设置：<strong>LOCAL_LDFLAGS</strong><br> </font></p><h2 id="6、ndk-build的编译选项"><a href="#6、ndk-build的编译选项" class="headerlink" title="6、ndk-build的编译选项"></a>6、ndk-build的编译选项</h2><p><a href="https://developer.android.google.cn/ndk/guides/ndk-build" target="_blank" rel="noopener">https://developer.android.google.cn/ndk/guides/ndk-build</a></p><p>所有给ndk-build的选项都会直接传给GNU Make，由make运行NDK的编译脚本。几个常见调用方式如下：</p><pre><code> ndk-build clean 清掉二进制文件  ndk-build NDK_DEBUG=1     编译为可调试版的二进制文件  ndk-build NDK_DEBUG=0     编译为release版  ndk-build V=1             执行ndk-build且打印出它所执行的详细编译命令。  ndk-build -B              强制重新编译  ndk-build -B V=1          -B 和 V=1 的组合  ndk-build NDK_LOG=1        打印出内部的NDK日志信息（用于调试NDK自己）  ndk-build NDK_APPLICATION_MK=&lt;文件路径&gt;      用这里指定的路径寻找Application.mk文件  ndk-build -C &lt;project路径&gt;  先cd进入&lt;project路径&gt;，然后执行ndk-build。</code></pre><p><strong>jni中如何指定编译器：</strong><br>在jni/Application.mk中添加</p><pre><code>NDK_TOOLCHAIN_VERSION :=4.9</code></pre><p>NDK_TOOLCHAIN_VERSION. Define this variable as 4.9 to select that version of the GCC compiler. Define this variable as clang to select the Clang compiler,</p><h2 id="7、编译脚本"><a href="#7、编译脚本" class="headerlink" title="7、编译脚本"></a>7、编译脚本</h2><p><a href="https://soaringleefighting.github.io/2018/11/13/%E3%80%90android%E3%80%91Android%E5%B9%B3%E5%8F%B0%E9%80%9A%E7%94%A8%E7%BC%96%E8%AF%91%E7%8E%AF%E5%A2%83/">Android平台通用编译环境</a></p><h2 id="8、编译模板"><a href="#8、编译模板" class="headerlink" title="8、编译模板"></a>8、编译模板</h2><p><a href="https://soaringleefighting.github.io/2018/11/13/%E3%80%90android%E3%80%91Android%E5%B9%B3%E5%8F%B0%E9%80%9A%E7%94%A8%E7%BC%96%E8%AF%91%E6%A8%A1%E6%9D%BF%20/">Android平台通用编译模板</a></p><p>更多参考网址：<br><a href="https://www.cnblogs.com/wanghuaijun/p/8092747.html" target="_blank" rel="noopener">https://www.cnblogs.com/wanghuaijun/p/8092747.html</a><br><a href="https://blog.csdn.net/listener51/article/details/84026778" target="_blank" rel="noopener">https://blog.csdn.net/listener51/article/details/84026778</a><br><a href="https://www.tuicool.com/articles/QZJ3qa" target="_blank" rel="noopener">https://www.tuicool.com/articles/QZJ3qa</a><br><a href="https://blog.csdn.net/crash163/article/details/52228412" target="_blank" rel="noopener">https://blog.csdn.net/crash163/article/details/52228412</a></p><h2 id="9、Android平台编译注意事项"><a href="#9、Android平台编译注意事项" class="headerlink" title="9、Android平台编译注意事项"></a>9、Android平台编译注意事项</h2><ol><li>当前最新版本的android-ndk版本是r16b。将x86纯汇编代码编译为x86_64平台Android程序时，报出如下问题：<pre><code>Android.mk: Unsupported source file extensions for &quot;xxxxxxxxxx&quot;</code></pre></li></ol><p><strong>原因：</strong> 采用ndk版本为r10。该版本不支持x86_64平台上的asm汇编文件的编译，不识别asm格式的文件。这样会导致编译时忽略掉asm文件的编译。<br><strong>解决方案：</strong> 经过测试，r10，r10b都不支持x86_64平台上的asm汇编编译，r10e和更高版本的ndk支持x86_64平台上的asm汇编编译。</p><hr><h2 id="THE-END"><a href="#THE-END" class="headerlink" title="THE  END!"></a><font color="red"><strong>THE  END!</strong></font></h2>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 工程化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android平台通用编译模板</title>
      <link href="/2018/11/13/%E3%80%90android%E3%80%91Android%E5%B9%B3%E5%8F%B0%E9%80%9A%E7%94%A8%E7%BC%96%E8%AF%91%E6%A8%A1%E6%9D%BF/"/>
      <url>/2018/11/13/%E3%80%90android%E3%80%91Android%E5%B9%B3%E5%8F%B0%E9%80%9A%E7%94%A8%E7%BC%96%E8%AF%91%E6%A8%A1%E6%9D%BF/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="1、NDK编译C-C-Native代码的通用方法"><a href="#1、NDK编译C-C-Native代码的通用方法" class="headerlink" title="1、NDK编译C/C++ Native代码的通用方法"></a>1、NDK编译C/C++ Native代码的通用方法</h2><p>android编译目录关系如下：<br>jni/Android_lib.mk<br>jni/Android_app.mk<br>jni/common.mk<br>jni/Application.mk<br>libs：编译后自动创建，存放各个架构平台stripped的可执行文件和库<br>obj：编译后自动创建，存放各个架构平台not stripped的目标文件、可执行文件和库。<br>out：自己创建的目录，存放各个架构平台的动静态库和可执行文件。<br>build_android.py、build_android.sh：编译脚本 参考： <a href="https://blog.csdn.net/SoaringLee_fighting/article/details/82910083" target="_blank" rel="noopener">Android平台通用编译环境</a></p><p><font color="red">通用模块编译可以通过编写Android_lib.mk，Android_app.mk和common.mk以及Application.mk文件采用ndk-build进行编译。</font></p><p>模板如下：</p><h3 id="1-1-common-mk"><a href="#1-1-common-mk" class="headerlink" title="1.1 common.mk:"></a>1.1 <strong>common.mk:</strong></h3><p>设置源文件目录以及头文件目录：配置LOCAL_C_INCLUDES和LOCAL_SRC_FILES。</p><pre><code class="makefile">##主要指定源文件路径和头文件路径SRC_DIR := ../../../src##头文件路径LOCAL_C_INCLUDES := ./                    \            $(DIR_SRC)            \            $(DIR_SRC)/../include        \            $(DIR_SRC)/$(INCLUDEASM)##纯C文件路径C_SRCS := $(DIR_SRC)/test1.c                \    $(DIR_SRC)/test2.c                \    $(DIR_SRC)/test3.c                \    $(DIR_SRC)/test4.c                \    $(DIR_SRC)/test5.c##汇编文件路径A_SRCS :=ifeq($(PURE_C),0)#x86架构ifeq($(findstring x86, $(TARGET_ARCH_ABI)), x86)IFLAGS += -I$(SRC_DIR)/x86A_SRCS += $(DIR_SRC)/x86/test1.asm            \    $(DIR_SRC)/x86/test2.asmendif#arm架构ifeq($(findstring armeabi, $(TARGET_ARCH_ABI)), armeabi)IFLAGS += -I$(SRC_DIR)/armA_SRCS += $(DIR_SRC)/arm/test1.asm            \    $(DIR_SRC)/arm/test2.asmendifendif##设置汇编文件LOCAL_SRC_FILES := $(C_SRCS) $(A_SRCS)</code></pre><h3 id="1-2-Android-lib-mk"><a href="#1-2-Android-lib-mk" class="headerlink" title="1.2 Android_lib.mk:"></a>1.2 <strong>Android_lib.mk:</strong></h3><p>Android.mk 文件位于项目 jni/ 目录的子目录中，用于向构建系统描述源文件和共享库。 它实际上是构建系统解析一次或多次的微小 GNU makefile 片段。 Android.mk 文件用于定义 Application.mk、构建系统和环境变量所未定义的项目范围设置。</p><p>设置编译参数、特定平台编译参数、编译动静态库配置：配置LOCAL_PATH，LOCAL_MODULE，LOCAL_CFLAGS，LOCAL_CPPFLAGS。</p><pre><code class="makefile">LOCAL_PATH := $(call my-dir)include $(CLEAR_VARS)LOCAL_MODULE := libxxx##参数初始化DEBUG ?= 0SHARED ?= 1INCLUDEASM :=#设置汇编优化使能ifeq ($(PURE_C),1)OPTIM := 1elseOPTIM := 0endif#设置GDB调试使能ifeq ($(DEBUG),1)GDBEN := -gelseGDBEN := -O3endif#设置公用编译参数CFLAGS := -WallCFLAGS += -fPICCFLAGS += -std=c99CFLAGS += $(GDBEN)#特定架构编译参数ifeq($(TARGET_ARCH_ABI),arm64-v8a)INCLUDEASM = aarch64CFLAGS += -march=armv8-aCFLAGS += -D_REENTRANTCFLAGS += 架构相关优化宏endififeq($(TARGET_ARCH_ABI),armeabi-v7a)INCLUDEASM = armCFLAGS += -march=armv7-a -mfpu=neon -marmCFLAGS += -D_REENTRANTCFLAGS += 架构相关优化宏endififeq($(TARGET_ARCH_ABI),x86_64)INCLUDEASM = x86CFLAGS += -march=x86-64 -m64 -msse -msse2 -msse3 -msse4.1CFLAGS += -D_REENTRANTCFLAGS += 架构相关优化宏endififeq($(TARGET_ARCH_ABI),x86)INCLUDEASM = x86CFLAGS += -march=i686 -m32 -msse -msse2 -msse3 -msse4.1CFLAGS += -D_REENTRANTCFLAGS += 架构相关优化宏endif#设置编译参数LOCAL_CFLAGS := $(CFLAGS)LOCAL_CPPFLAGS := $(CFLAGS)#include $(LOCAL_PATH)/common.mk#配置编译静态库、动态库ifeq ($(SHARED),1)include $(BUILD_SHARED_LIBRARY)elseinclude $(BUILD_STATIC_LIBRARY)endif</code></pre><h3 id="1-3-Android-app-mk"><a href="#1-3-Android-app-mk" class="headerlink" title="1.3 Android_app.mk:"></a>1.3 <strong>Android_app.mk:</strong></h3><p>设置编译参数、特定平台编译参数、编译可执行文件配置：配置LOCAL_PATH，LOCAL_MODULE，LOCAL_CFLAGS，LOCAL_CPPFLAGS。</p><pre><code class="makefile">LOCAL_PATH := $(call my-dir)include $(CLEAR_VARS)LOCAL_MODULE := libxxxLOCAL_C_INCLUDES :=      $(LOCAL_PATH)/../../../demo/        \            $(LOCAL_PATH)/../../../include/#设置公用编译参数CFLAGS := -WallCFLAGS += -fPICCFLAGS += -std=c99CFLAGS += $(GDBEN)#特定架构编译参数ifeq($(TARGET_ARCH_ABI),arm64-v8a)INCLUDEASM = aarch64CFLAGS += -march=armv8-aendififeq($(TARGET_ARCH_ABI),armeabi-v7a)INCLUDEASM = armCFLAGS += -march=armv7-a -mfpu=neon -marmendififeq($(TARGET_ARCH_ABI),x86_64)INCLUDEASM = x86CFLAGS += -march=x86-64 -m64 -msse -msse2 -msse3 -msse4.1endififeq($(TARGET_ARCH_ABI),x86)INCLUDEASM = x86CFLAGS += -march=i686 -m32 -msse -msse2 -msse3 -msse4.1endif#设置编译参数LOCAL_CFLAGS := $(CFLAGS)LOCAL_CPPFLAGS := $(CFLAGS)LOCAL_LDFLAGS := $(LOCAL_PATH)/../out/$(TARGET_ARCH_ABI)/libxxx.aLOCAL_STATIC_LIBRARIES := $(LOCAL_PATH)/../out/$(TARGET_ARCH_ABI)/libxxx.a#设置demo源文件SRC_DIR =$(LOCAL_PATH)/../../../demoDEMO_SRCS := $(SRC_DIR)/demo.cLOCAL_SRC_FILES := $(DEMO_SRCS)include $(BUILD_EXECUTABLE)</code></pre><h3 id="1-4-Application-mk："><a href="#1-4-Application-mk：" class="headerlink" title="1.4 Application.mk："></a>1.4 <strong>Application.mk：</strong></h3><p>设置APP_ABI，APP_PLATFORM和NDK_TOOLCHAIN_VERSION等。</p><pre><code class="makefile">APP_ABI := x86 x86_64 armeabi armeabi-v7a arm64-v8aAPP_PLATFORM := android-9NDK_TOOLCHAIN_VERSION := 4.9</code></pre><p>系统宏用法：<br><strong>APP_ABI</strong><br>默认情况下，NDK 构建系统为 armeabi ABI 生成机器代码。 此机器代码对应于基于 ARMv5TE、采用软件浮点运算的 CPU。 您可以使用 APP_ABI 选择不同的 ABI。<br><strong>APP_PLATFORM</strong><br>此变量包含目标 Android 平台的名称。<br><strong>APP_BUILD_SCRIPT</strong><br>默认情况下，NDK 构建系统在 jni/ 下查找名称为 Android.mk 的文件。<br>如果要改写此行为，可以定义 APP_BUILD_SCRIPT 指向替代构建脚本。 构建系统始终将非绝对路径解释为 NDK 顶级目录的相对路径。<br><strong>NDK_TOOLCHAIN_VERSION</strong><br>将此变量定义为 4.9 或 4.8 以选择 GCC 编译器的版本。 64 位 ABI 默认使用版本 4.9 ，32 位 ABI 默认使用版本 4.8。要选择 Clang 的版本，请将此变量定义为 clang3.4、clang3.5 或 clang。 指定 clang 会选择 Clang 的最新版本</p><p>关于系统变量、宏和函数宏的用法更多可参考：<br><a href="https://developer.android.google.cn/ndk/guides/android_mk" target="_blank" rel="noopener">https://developer.android.google.cn/ndk/guides/android_mk</a><br><a href="https://developer.android.google.cn/ndk/guides/application_mk" target="_blank" rel="noopener">https://developer.android.google.cn/ndk/guides/application_mk</a></p><hr><h2 id="THE-END"><a href="#THE-END" class="headerlink" title="THE  END!"></a><font color="red"><strong>THE  END!</strong></font></h2>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 工程化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>FFmpeg开源代码提取方法（附mpeg2编解码器提取）</title>
      <link href="/2018/11/11/%E3%80%90Codecs%E7%B3%BB%E5%88%97%E3%80%91FFmpeg%E4%B8%ADmpeg2%E7%BC%96%E8%A7%A3%E7%A0%81%E5%99%A8%E7%9A%84%E6%8F%90%E5%8F%96%E5%92%8C%E7%BC%96%E8%AF%91%E6%B5%8B%E8%AF%95/"/>
      <url>/2018/11/11/%E3%80%90Codecs%E7%B3%BB%E5%88%97%E3%80%91FFmpeg%E4%B8%ADmpeg2%E7%BC%96%E8%A7%A3%E7%A0%81%E5%99%A8%E7%9A%84%E6%8F%90%E5%8F%96%E5%92%8C%E7%BC%96%E8%AF%91%E6%B5%8B%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="1、参考"><a href="#1、参考" class="headerlink" title="1、参考"></a>1、参考</h2><p><a href="https://blog.csdn.net/SoaringLee_fighting/article/details/68926337" target="_blank" rel="noopener">ffmpeg命令行工具利用libx264和libx265编码YUV文件</a><br><a href="https://blog.csdn.net/wutong_login/article/details/6876132" target="_blank" rel="noopener">ffmpeg的mpeg2编码I帧代码解读</a></p><h2 id="2、目录"><a href="#2、目录" class="headerlink" title="2、目录"></a>2、目录</h2><ul><li>ffmpeg框架<ul><li>简介</li><li>目录结构</li><li>工作流程</li><li>编译</li><li>运行</li></ul></li><li>ffmpeg开源代码提取<ul><li>总体流程</li><li>MPEG-2解码器为例说明开源代码提取过程</li></ul></li></ul><h2 id="3、ffmpeg框架"><a href="#3、ffmpeg框架" class="headerlink" title="3、ffmpeg框架"></a>3、ffmpeg框架</h2><h3 id="3-1-ffmpeg简介"><a href="#3-1-ffmpeg简介" class="headerlink" title="3.1 ffmpeg简介"></a>3.1 ffmpeg简介</h3><p> ffmpeg既是一款音视频编解码工具，包括多种音视频编解码器、多种协议的流媒体、多种颜色空间转换、多种采样率转换、多种码率转换等；<br> 提供了多种丰富的插件模块，包括封装和解封装插件、编码和解码插件。</p><h3 id="3-2-ffmpeg目录结构"><a href="#3-2-ffmpeg目录结构" class="headerlink" title="3.2 ffmpeg目录结构"></a>3.2 ffmpeg目录结构</h3><pre><code class="shell"> tree -d -L 1</code></pre><p>ffmpeg版本：4.1.4<br><img src="/img/20190717221951241-.png" alt="FFmpeg目录结构"></p><ul><li>ffbuild: 编译工具</li><li>libavcodec:音视频编解码库</li><li>libavdevice: 音视频输入输出设备库</li><li>libavfilter:音视频格式封装和解封装库</li><li>libavresample:音频重采样</li><li>libavutil:音视频工具库</li><li>libpostproc:音视频后处理库</li><li>libswresample:音频重采样、采样格式转换、混音</li><li>libswscale:视频缩放和色彩空间转换</li></ul><h3 id="3-3-ffmpeg工作流程"><a href="#3-3-ffmpeg工作流程" class="headerlink" title="3.3 ffmpeg工作流程"></a>3.3 ffmpeg工作流程</h3><p><img src="/img/20190717214942716-.png" alt="FFmpeg工作流程"></p><h3 id="3-4-ffmpeg编译"><a href="#3-4-ffmpeg编译" class="headerlink" title="3.4 ffmpeg编译"></a>3.4 ffmpeg编译</h3><h4 id="3-4-1-ffmpeg-linux平台编译"><a href="#3-4-1-ffmpeg-linux平台编译" class="headerlink" title="3.4.1 ffmpeg linux平台编译"></a>3.4.1 ffmpeg linux平台编译</h4><p>这个很简单，一般开源代码都是下面这个步骤：</p><pre><code class="shell">./configuremakemake install</code></pre><h4 id="3-4-2-三方库x264编译到ffmpeg库"><a href="#3-4-2-三方库x264编译到ffmpeg库" class="headerlink" title="3.4.2 三方库x264编译到ffmpeg库"></a>3.4.2 三方库x264编译到ffmpeg库</h4><p>ffmpeg本身支持一些音视频编码标准格式、文件封装格式以及一些流媒体传输协议，但是支持的数目是有限的。有些模块可以采用第三方外部链接库的方式提供支持。可以通过命令./configure –help查看。如下：</p><pre><code class="shell">./configure --help</code></pre><p>External library support :<br><img src="/img/20190718223437616-.png" alt="第三方库支持"></p><p>(1).下载x264源码并编译出静态库<br>编译命令：</p><pre><code class="shell">./configure --disable-asm --enable-static -prefix=./ffmpeg/x264/make -j8make install</code></pre><p>(2).编译带x264编码器的ffmpeg<br>编译命令：</p><pre><code class="shell">./configure --enable-gpl --enable-nonfree --enable-version3 --enable-pthreads --enable-libx264 --enable-static --disable-shared --extra-cflags=&#39;-I/ffmpeg/x264/include&#39; --extra-ldflags=&#39;-L/ffmpeg/x264/lib -lx264 -lpthread -lm -ldl&#39;make -j8</code></pre><p>输出结果(各个模块库、三个工具ffmpeg、ffplay和ffprobe)在/ffmpeg中</p><p>测试x264编码器是否成功编译进ffmpeg命令：</p><pre><code class="shell">./ffmpeg -encoders</code></pre><h3 id="3-5-ffmpeg运行"><a href="#3-5-ffmpeg运行" class="headerlink" title="3.5 ffmpeg运行"></a>3.5 ffmpeg运行</h3><p>(1). 查看ffmpeg中x264编码器的参数命令：</p><pre><code class="shell">./ffmpeg -h encoder=libx264</code></pre><p>(2). ffmpeg中运行x264编码的命令行：</p><pre><code class="shell">./ffmpeg -s cif -i foreman_cif.yuv -vcodec libx264  output.264</code></pre><h2 id="4、ffmpeg开源代码提取"><a href="#4、ffmpeg开源代码提取" class="headerlink" title="4、ffmpeg开源代码提取"></a>4、ffmpeg开源代码提取</h2><h3 id="4-1-总体流程"><a href="#4-1-总体流程" class="headerlink" title="4.1 总体流程"></a>4.1 总体流程</h3><p>待补充</p><h3 id="4-2-mpeg2编解码器开源代码提取示例"><a href="#4-2-mpeg2编解码器开源代码提取示例" class="headerlink" title="4.2 mpeg2编解码器开源代码提取示例"></a>4.2 mpeg2编解码器开源代码提取示例</h3><p>待补充</p><hr><h2 id="THE-END"><a href="#THE-END" class="headerlink" title=" THE END! "></a><font color="red"> THE END! </font></h2>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 编解码 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Codecs </tag>
            
            <tag> FFMPEG </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>对于现在工作的思考--20181111</title>
      <link href="/2018/11/11/%E3%80%90Think%E7%B3%BB%E5%88%97%E3%80%91%E5%AF%B9%E4%BA%8E%E7%8E%B0%E5%9C%A8%E5%B7%A5%E4%BD%9C%E7%9A%84%E6%80%9D%E8%80%8320181111/"/>
      <url>/2018/11/11/%E3%80%90Think%E7%B3%BB%E5%88%97%E3%80%91%E5%AF%B9%E4%BA%8E%E7%8E%B0%E5%9C%A8%E5%B7%A5%E4%BD%9C%E7%9A%84%E6%80%9D%E8%80%8320181111/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="1、参考"><a href="#1、参考" class="headerlink" title="1、参考"></a>1、参考</h2><p><a href="https://baijiahao.baidu.com/s?id=1607956666437116057&amp;wfr=spider&amp;for=pc" target="_blank" rel="noopener">https://baijiahao.baidu.com/s?id=1607956666437116057&amp;wfr=spider&amp;for=pc</a></p><h2 id="2、工作的思考"><a href="#2、工作的思考" class="headerlink" title="2、工作的思考"></a>2、工作的思考</h2><p>&ensp; &ensp; “双11”本来只是每年时间里一个普通的日子，现在却成为了阿里，京东等商家促进全民消费的日子，铺天盖地的广告宣传，巧言令色的红包规则，促成了不到2小时天猫双11交易额突破千亿。可见消费尤其是全民零售消费已经成为了拉动经济的三驾马车（投资、出口和消费）中一个非常重要的角色。双11本来只是被戏谑为“光棍节”，现在却成了消费狂欢节，这背后可能存在很多经济学和心理学的理论。</p><p>&ensp; &ensp; 2017年推动中国经济发展的三驾马车：领头马是“固定资产投资”，总额为63.17万亿；二马是“社会消费品零售”，总额为36.62万亿；三马是“进出口”，总额为27.79万亿。可以看出，固投依然是中国经济的绝对推动力！</p><p>&ensp; &ensp;现如今，中国的这三驾马车也逐渐出现了疲软的现象，中美贸易战造成进出口存在一定程度的降低，现在，各个电商平台的新零售正促进了消费，拉动了内需。</p><p>&ensp; &ensp; 上面是我对“双11”的一个思考，透过生活中的现象看到本质，这也是我们应该具备的能力。转眼间，工作已近一年半了，对于现在这家公司（A）和当前工作应该说已经相对比较熟悉了。今天杭城天气阴沉沉的，雾气很大，因此就呆在出租房里休息、学习和思考。对于A，总体评价应该是不错的，无论是公司发展还是人文关怀，都是不错的。对于当前的工作，我也是喜欢的。还记得17年3月刚来这里实习时，那时的自己对工作充满激情，对这里的一切感到兴趣。对于工作，我一直保持学习的态度，在工作过程中学习积累，在学习积累过程中完成工作，如此持续循环，从而量变引起质变。最初在几份offer中选择A的初衷，是认为这里的平台更大，学到的东西更多，有一种来这里镀金的意思，我并没有在这里的一直待下去的打算，可以对于离职，我始终没有拿定注意，也许是在等待一个时机吧。当前来看，我没有理由一直呆在杭城：(1). 我内心可能更加渴望在老家生活吧，比较恋家；(2). 毕竟在家里已经买房了；(3). 父母已经年迈，陪伴他们的时间还剩多少呢？(4). 希望对家乡发展做出自己的一点贡献吧。</p><p>&ensp; &ensp; 总结一下这将近一年半时间 工作的思考和进步：</p><ol><li>工作。工作的本质更多是交付件和自己劳动时间的交换，公司和领导更多看重的是结果而不是过程，公司永远会认为你应该输出更多交付件，压榨和索取是领导的手段，并且是以一种让你认为是为你好的方式。因此工作和生活应该分开的。不能为了工作而牺牲了自己生活！</li><li>良好的工作方式和工作习惯。当前公司给我最大的进步除了技术成长外，应该是养成良好的工作习惯。虽然这两次绩效都不是最好的，但是现在的工作方式应该可以让自己有更大的成长和发展。</li><li>事业。工作和事业是二回事！我们在工作的同时应该去探索事业的方向，从而追求更好的发展。</li><li>同理心。就是换位思考。对待领导，需要有同理心。这就需要有全局视野和更深度的思考。</li><li>持续思考。思考力是一种能力！无论何时何地，都需要持续思考，保持自己的思考和观点，并且思考更加深入，不断更新自己的认知。</li><li>持续学习。学习力是一种能力！无论在哪里，都要保持学习，在工作中学习，向同事学习，向身边的人学习，向优秀的人学习。并且学习中持续积累，从而量变引起质变。</li><li>学会在团队中找到自己的定位，并做出自己的贡献。</li><li>情绪控制。要学会管理好自己的情绪，控制好自己的情绪，注意的言行，三思而后行。这点自己要不断改进!</li><li>时间管理。时间是我们年轻的资本，是需要投资的。时间管理是一门学问，制定自己的周计划、月计划、年计划，短期计划、中期计划和长期计划，按照计划不断推进，持续积累和学习。</li><li>责任担当。处事方式需要不断优化和改进，对家人的责任和担当需要更多投入。</li></ol><hr><h2 id="THE-END"><a href="#THE-END" class="headerlink" title="THE END!"></a><font color="red">THE END!</font></h2>]]></content>
      
      
      <categories>
          
          <category> 生活 </category>
          
          <category> 规划 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Think </tag>
            
            <tag> Plan </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>视频编解码标准梳理框架和要点分析</title>
      <link href="/2018/11/03/%E3%80%90Codecs%E7%B3%BB%E5%88%97%E3%80%91%E8%A7%86%E9%A2%91%E7%BC%96%E8%A7%A3%E7%A0%81%E6%A0%87%E5%87%86%E6%A2%B3%E7%90%86%E6%A1%86%E6%9E%B6%E5%92%8C%E8%A6%81%E7%82%B9%E5%88%86%E6%9E%90/"/>
      <url>/2018/11/03/%E3%80%90Codecs%E7%B3%BB%E5%88%97%E3%80%91%E8%A7%86%E9%A2%91%E7%BC%96%E8%A7%A3%E7%A0%81%E6%A0%87%E5%87%86%E6%A2%B3%E7%90%86%E6%A1%86%E6%9E%B6%E5%92%8C%E8%A6%81%E7%82%B9%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="1、前言"><a href="#1、前言" class="headerlink" title="1、前言"></a>1、前言</h2><p>&ensp; &ensp; 在研读编解码标准时，需要注意不能完全按照标准的思路和角度去理解标准，虽然标准已经将所有技术细节讲述清楚了，但是可能整体的框架和要点并不能完全呈现出来，需要我们自己去组织呈现，并将各个技术要点具体化。</p><h2 id="2、编解码标准框架和要点"><a href="#2、编解码标准框架和要点" class="headerlink" title="2、编解码标准框架和要点"></a>2、编解码标准框架和要点</h2><p>&ensp; &ensp; 梳理标准可以从两个维度进行：</p><ol><li>首先把握整体的框架和要点（基本要素或骨架）；</li><li>在上面基础上梳理各个要点的细节（具体化）。</li></ol><p>使用上面总-分的方式梳理标准，可以更好的把握标准的框架和细节。</p><p><strong>以MPEG-2标准为例进行分析：</strong></p><h3 id="2-1-码流组织方式（码流结构）"><a href="#2-1-码流组织方式（码流结构）" class="headerlink" title="2.1. 码流组织方式（码流结构）"></a>2.1. 码流组织方式（码流结构）</h3><ul><li>分层结构（MPEG1/2/4）</li><li>单层nal结构（H.264/H.265）<br>码流结构其实是定义了如何存放码流数据和一些辅助信息。 头信息可以理解为一些辅助信息。确定码流结构之后，首先需要明确头信息解码中的相关信息。<br>在MPEG-2标准中，Sequence_header中包含有码流的帧宽和帧高信息，所以必须要有sequence_header，并且后面紧跟着sequence_extension。并且必须要有Picture_header（包含帧类型），后面紧跟picture_coding_extension。其中gop_header是可选的，sequence_header和picture_header都是必须要有的。</li></ul><p>  <strong>主线： 预测 + 残差 = 重建</strong></p><p><font color="red"> <strong>预测过程</strong>  </font></p><h3 id="2-2-帧内预测"><a href="#2-2-帧内预测" class="headerlink" title="2.2. 帧内预测"></a>2.2. 帧内预测</h3><ul><li>宏块划分方式（确定预测块的大小）：区分亮度块大小和色度块大小</li><li>预测方式<ul><li>无像素域预测（MPEG1/2/4）</li><li>有像素域预测<ul><li>相邻块可用性（确定参考块）</li><li>预测模式：区分亮度块和色度块的预测模式</li></ul></li></ul></li></ul><h3 id="2-3-帧间预测"><a href="#2-3-帧间预测" class="headerlink" title="2.3. 帧间预测"></a>2.3. 帧间预测</h3><ul><li><p>宏块划分方式（确定预测块的大小），区分亮度块大小和色度块大小</p></li><li><p>预测方式（指示通过MV和参考帧找到参考块，按图索骥）</p></li><li><p>参考帧或参考场：区分场预测（参考为场）和帧预测（参考为帧）</p></li><li><p>MV运动信息：MV=MVP+MVD</p><ul><li>相邻块可用性</li><li>运动矢量预测MVP</li><li>MV计算精度</li></ul></li><li><p>知识串联：可以采用预测方式为主线将帧内预测中的各个要点串联起来。</p></li><li><p>预测方式：<br>1). 特点：比如Skip模式没有残差，mvd等于0，重构值等于预测值。<br>2). 预测方向： 前向、后向、双向<br>3). 参考帧<br>4). 块划分大小<br>5). MV信息</p></li></ul><p><font color="red">   <strong>残差解码过程</strong>  </font></p><h3 id="2-4-熵解码"><a href="#2-4-熵解码" class="headerlink" title="2.4. 熵解码"></a>2.4. 熵解码</h3><p>以VLC(Huffman)为例：</p><ul><li>块大小：8x8</li><li>区分帧内和帧间的块解码方法</li><li>区分DC系数和AC系数解码</li><li>DC系数解码一般采用差分方法（差分+VLC），即dc = pred(前一个块的dc值或者其他方式获取) + diff(码流中传输)</li><li>AC系数解码：RLC+VLC方式</li></ul><h3 id="2-5-反扫描"><a href="#2-5-反扫描" class="headerlink" title="2.5. 反扫描"></a>2.5. 反扫描</h3><ul><li>块大小：8x8或者4x4</li><li>扫描方式：常用zigzag</li></ul><h3 id="2-6-反量化"><a href="#2-6-反量化" class="headerlink" title="2.6. 反量化"></a>2.6. 反量化</h3><ul><li>块大小：8x8或4x4 （量化块尺寸与预测块（宏块划分方式）之间关系）</li><li>量化参数QP确定：区分亮度块和色度块<br>例如0~31(mpeg-2/4),0~55(svac1)。编码句法中必定有句法表示QP(例如mpeg-2中的quantiser_scale)。</li><li>反量化后残差系数的取值范围（运算精度）</li><li>区分帧内块和帧间块</li></ul><h3 id="2-7-反变换"><a href="#2-7-反变换" class="headerlink" title="2.7. 反变换"></a>2.7. 反变换</h3><ul><li>块大小：8x8或4x4 （变换块尺寸与预测块（宏块划分方式）之间关系）</li><li>定点化（缩放）</li><li>反变换后残差系数的取值范围（计算精度）</li></ul><hr><h2 id="THE-END！"><a href="#THE-END！" class="headerlink" title=" THE END！ "></a><font color="red"> THE END！ <font></font></font></h2>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 编解码 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Codecs </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MPEG-2标准总结文档</title>
      <link href="/2018/10/24/%E3%80%90Codecs%E7%B3%BB%E5%88%97%E3%80%91MPEG-2%E6%A0%87%E5%87%86%E6%80%BB%E7%BB%93%E6%96%87%E6%A1%A3/"/>
      <url>/2018/10/24/%E3%80%90Codecs%E7%B3%BB%E5%88%97%E3%80%91MPEG-2%E6%A0%87%E5%87%86%E6%80%BB%E7%BB%93%E6%96%87%E6%A1%A3/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="0、前言"><a href="#0、前言" class="headerlink" title="0、前言"></a>0、前言</h2><p>&ensp; &ensp;   本文档是MPEG-2标准的学习总结文档，主要讲述了MPEG-2标准基本知识、码流分层结构、码流的句法和语义以及视频流的解码过程，相对比较详细，可供学习标准层面的知识。</p><h2 id="1、MPEG-2简介"><a href="#1、MPEG-2简介" class="headerlink" title="1、MPEG-2简介"></a>1、MPEG-2简介</h2><p>&ensp; &ensp;   MPEG组织于<strong>1994年</strong>正式推出MPEG-2压缩标准，以实现视/音频服务与应用互操作的可能性。最典型和成功的应用就是<strong>DVD产品</strong>。MPEG-2标准包括了系统层、视频层、音频层等9个部分，本文档主要讲述ISO/IEC 13818 Part2 视频部分。MPEG-2标准就是定义了一个标准的MPEG-2码流中每一位的具体含义，MPEG-2码流的结构以及视频解码的过程。　<br>&ensp; &ensp;  MPEG-2标准是针对<strong>标准数字电视和高清晰度电视</strong>在各种应用下的压缩方案和系统层的详细规定，<strong>编码码率从每秒3M比特～100M比特</strong>，标准的正式规范在ISO/IEC13818中。MPEG-2不是MPEG-1的简单升级，MPEG-2在系统和传送方面作了更加详细的规定和进一步的完善。MPEG-2特别适用于广播级的数字电视的编码和传送，被认定为SDTV和HDTV的编码标准。<br>&ensp; &ensp;  MPEG-2图像压缩的原理是利用了图像中的两种特性：空间相关性和时间相关性。这两种相关性使得图像中存在大量的冗余信息。如果我们能将这些冗余信息去除，只保留少量非相关信息进行传输，就可以大大节省传输频带。而接收机利用这些非相关信息，按照一定的解码算法，可以在保证一定的图像质量的前提下恢复原始图像。一个好的压缩编码方案就是能够最大限度地去除图像中的冗余信息。<br>&ensp; &ensp;  MPEG-2的编码图像被分为三类，分别称为I帧，P帧和B帧。 I帧图像采用帧内编码方式，即只利用了单帧图像内的空间相关性，而没有利用时间相关性。P帧和B帧图像采用帧间编码方式，即同时利用了空间和时间上的相关性。P帧图像只采用前向时间预测，可以提高压缩效率和图像质量。P帧图像中可以包含帧内编码的部分，即P帧中的每一个宏块可以是前向预测，也可以是帧内编码。B帧图像采用双向时间预测，可以大大提高压缩倍数。</p><h2 id="2、档次和级别-（Profile-amp-amp-Level）"><a href="#2、档次和级别-（Profile-amp-amp-Level）" class="headerlink" title="2、档次和级别 （Profile &amp;&amp; Level）"></a>2、档次和级别 （Profile &amp;&amp; Level）</h2><p>&ensp; &ensp;   为了实现标准的语法体系的实用性（满足不同的应用），定义了Profile和Level的方式来限定有限数目的语法子集。Profile是标准中定义个完整比特流语法一个子集（偏向于功能性约束）；Level是对比特流语法中各个参数进行限定的集合（偏向于参数限定）。<br>&ensp; &ensp;  MPEG-2标准定义了7种Profile和4种Level，如下表所示：<br>（参考自：<a href="https://www.cs.rutgers.edu/~elgammal/classes/cs334/slide11_short.pdf）" target="_blank" rel="noopener">https://www.cs.rutgers.edu/~elgammal/classes/cs334/slide11_short.pdf）</a><br><img src="/img/Profiles_and_levelsInMPEG2.png" alt="MPEG-2标准中的Profile和Level"><br>其中在Main Profile中分为High,High 1440，Main和Low四种Level，具体规定如下图：<br><img src="/img/Main_profile_In_MPEG2.png" alt="MPEG-2标准的Main Profile"></p><p><strong>说明：</strong><br>MPEG-2是向下兼容MPEG-1的，因此MPEG-2解码器可以解码满足一定条件的MPEG-1码流。<br>MPEG-2中的Simple,Main，SNR可分级、空域可分级和High Profile的所有level对于MPEG-1中的约束参数的比特流都是可解码的。</p><h2 id="3、码流的分层结构"><a href="#3、码流的分层结构" class="headerlink" title="3、码流的分层结构"></a>3、码流的分层结构</h2><p> &ensp; &ensp;   编码的视频数据由称作layer的比特流序列组成。如果仅有一层，那么这个视频流就是不可分级的视频比特流。如果有两层或多层，则称为分级的视频比特流。<br> &ensp; &ensp;   MPEG-2的编码码流共分为六个层次。为更好地表示编码数据，MPEG-2用句法Syntax规定了一个层次性结构。它共分为六层，自上到下分别是：图像序列层（Video Sequence）、图像组层(GOP)、图像层（Picture）、宏块条层（Slice）、宏块层（MacroBlock）和块层（Block）。</p><h3 id="3-1、Video-Sequence-视频序列"><a href="#3-1、Video-Sequence-视频序列" class="headerlink" title="3.1、Video Sequence 视频序列"></a>3.1、Video Sequence 视频序列</h3><p> &ensp; &ensp;  编码的比特流中的最高语法结构就是视频序列。一个视频序列以一个序列头开始，后面可选地跟着一组图像头和一个或多个编码帧。视频序列以一个sequence_end_code终止。序列头、图像组头和图像头在视频序列中可能是重复出现的，通过重复第一个序列头的数据单元，从而使得对视频序列的随机访问成为可能。<br>  <img src="/img/video_sequence_mpeg2.png" alt="MPEG-2码流分层结构"></p><h3 id="3-2、Group-of-Pictures（GOP）-图像组"><a href="#3-2、Group-of-Pictures（GOP）-图像组" class="headerlink" title="3.2、Group of Pictures（GOP） 图像组"></a>3.2、Group of Pictures（GOP） 图像组</h3><p>&ensp; &ensp;  图像组是由一系列的编码图像组成。在编码比特流中，图像组头后面的第一个编码帧是I帧。</p><h3 id="3-3、逐行序列和隔行序列"><a href="#3-3、逐行序列和隔行序列" class="headerlink" title="3.3、逐行序列和隔行序列"></a>3.3、逐行序列和隔行序列</h3><p>&ensp; &ensp;  MPEG-2标准支持逐行编码和隔行编码。</p><h3 id="3-4、Picture-图像"><a href="#3-4、Picture-图像" class="headerlink" title="3.4、Picture 图像"></a>3.4、Picture 图像</h3><p>&ensp; &ensp;  一个重构图可以通过对一个编码图的解码获得。一个编码图是由一个图像头、紧跟后面的可选扩展以及图像数据组成。一个编码图可以是一个帧图或一个场图。一个重构图可以是一个重构帧，或是一个重构帧的一个场。</p><p><strong>MPEG-2支持三种图像类型：</strong></p><ul><li>I 图 ： 只使用当前帧的编码信息。</li><li>P 图 ：利用前面的I图或P图使用运动补偿预测进行编码的图。</li><li>B 图： 利用前面的或后面的I图或P图使用运动补偿预测进行编码的图。</li></ul><h3 id="3-5、Slice-条带（块组）"><a href="#3-5、Slice-条带（块组）" class="headerlink" title="3.5、Slice 条带（块组）"></a>3.5、Slice 条带（块组）</h3><p>&ensp; &ensp; Slice是由一系列任意数目的连续宏块组成。Slice的第一个和最后一个宏块不能是Skip块。一个Slice中至少要包含一个宏块。Slice之间不能重叠。<strong>Slice的第一个和最后一个宏块要在同一宏块水平行上。</strong> Slice可以独立编解码，Slice的设计是为了错误恢复。</p><blockquote><p>注意：Slice的句法元素最早是在MPEG-1标准中引入的，MPEG-1标准中Slice的第一个宏块和最后 一个宏块可以不在同一个宏块水平行上。但是这种设计不利于错误恢复。</p></blockquote><h3 id="3-6、Macroblock-宏块"><a href="#3-6、Macroblock-宏块" class="headerlink" title="3.6、Macroblock  宏块"></a>3.6、Macroblock  宏块</h3><p>&ensp; &ensp;  宏块包含亮度分离和对应的色度分量。MPEG-2支持3种色度格式：4:2:0，4:2:2和4:4:4。对于4:2:0格式的图像，亮度宏块的大小为16x16，色度块的大小为8x8。一个宏块是由6个块组成的，分别是4个亮度块和2个色度块。<br>&ensp; &ensp;  对于隔行扫描的图像，亮度块有2种组织方式：<br>（1）帧DCT编码中，每个块由两场的行交替组成；<br>（2）场DCT编码中，每个块仅由两场中之一个场的行组成。<br>所以对场DCT编码的图像中，一个亮度块解码之后，要按照隔行的方式去存放，才能恢复出原来的图像。</p><h3 id="3-7、Block-块"><a href="#3-7、Block-块" class="headerlink" title="3.7、Block 块"></a>3.7、Block 块</h3><p>&ensp; &ensp; 块是视频编码中处理的最小单元。一般来说，DCT变换和量化的基本单元就是8x8的块。<br>&ensp; &ensp; 这里块既可以指源图像数据和重构图像数据，也可以指DCT系数或相应的编码数据单元。</p><h2 id="4、视频比特流的语法"><a href="#4、视频比特流的语法" class="headerlink" title="4、视频比特流的语法"></a>4、视频比特流的语法</h2><h3 id="4-1、-起始码"><a href="#4-1、-起始码" class="headerlink" title="4.1、 起始码"></a>4.1、 起始码</h3><p>&ensp; &ensp;  起始码是不会在视频中另外出现的特定位模式。<br>&ensp; &ensp;  每个起始码由一个起始码前缀和跟在后面的一个起始码值组成。起始码前缀是由一串23个零值和跟在后面的一位1值组成，即“0000 0000 0000 0000 0000 00001”。<br>&ensp; &ensp;  起始码值是个8bit整数，表明了起始码的类型。大部分起始码类型只有一个起始码值，而slice_start_code由许多起始码值表示，在这种情况下slice的起始码值是slice_vertical_position。</p><p><strong>表1.  MPEG-2标准定义的起始码值</strong><br><img src="/img/start_code.png" alt="起始码值"></p><h3 id="4-2、-Sytax-of-Video-Sequence"><a href="#4-2、-Sytax-of-Video-Sequence" class="headerlink" title="4.2、 Sytax of Video Sequence"></a>4.2、 Sytax of Video Sequence</h3><p>详见标准P22。包括了Sequence header、Extension and user data、Sequence extension、Sequence display extension、Sequence scalable extension和Group of pictures header的句法。</p><h3 id="4-3、Sytax-of-Picture-header"><a href="#4-3、Sytax-of-Picture-header" class="headerlink" title="4.3、Sytax of Picture header"></a>4.3、Sytax of Picture header</h3><p>详见标准P27。包括了Picture coding extension、Quant matrix extension、Picture display  extension和Picture temporal scalable extension、Copyright extension等句法。</p><h3 id="4-4、Sytax-of-Picture-data"><a href="#4-4、Sytax-of-Picture-data" class="headerlink" title="4.4、Sytax of Picture data"></a>4.4、Sytax of Picture data</h3><p>详见标准P30。</p><h3 id="4-5、Sytax-of-Slice"><a href="#4-5、Sytax-of-Slice" class="headerlink" title="4.5、Sytax of Slice"></a>4.5、Sytax of Slice</h3><p>详见标准P32。</p><h3 id="4-6、Sytax-of-Macroblock"><a href="#4-6、Sytax-of-Macroblock" class="headerlink" title="4.6、Sytax of Macroblock"></a>4.6、Sytax of Macroblock</h3><p>详见标准P33。</p><h3 id="4-7、Sytax-of-Block"><a href="#4-7、Sytax-of-Block" class="headerlink" title="4.7、Sytax of Block"></a>4.7、Sytax of Block</h3><p>详见标准P35。</p><h2 id="5、视频比特流的语义"><a href="#5、视频比特流的语义" class="headerlink" title="5、视频比特流的语义"></a>5、视频比特流的语义</h2><h3 id="5-1-视频比特流的语法结构"><a href="#5-1-视频比特流的语法结构" class="headerlink" title="5.1  视频比特流的语法结构"></a>5.1  视频比特流的语法结构</h3><p><strong>图1  高层比特流组织方式</strong></p><p><img src="/img/high_level.png" alt="高层比特流组织方式"></p><p>下面的语义规则适用于：</p><ul><li>如果视频序列的第一个sequence_header()后面没有紧跟着sequence_extension()，那么视频流将与ISO/IEC 11172-2一致。</li><li>如果视频序列的第一个sequence_header()后面紧跟着一个sequence_extension()，那么后面所有出现sequence_header的后面都要紧跟一个sequence_extension()。</li><li>sequence_extension仅紧跟在sequence_header后面。</li><li>如果sequence_extension在比特流中出现，那么每个picture_header后面都将紧跟一个picture_coding_extension。</li><li>picture_coding_extension仅紧跟在picture_header后面。</li><li>跟在group_of_picure_header后面的第一个编码图像应该是I图像。</li></ul><h3 id="5-2、语义分析"><a href="#5-2、语义分析" class="headerlink" title="5.2、语义分析"></a>5.2、语义分析</h3><p>详细语义参见标准P38~60。</p><h2 id="6、视频流解码过程"><a href="#6、视频流解码过程" class="headerlink" title="6、视频流解码过程"></a>6、视频流解码过程</h2><p>&ensp; &ensp; 视频流解码过程就是从编码码流中恢复出重建图像的过程，主要包括可变长解码VLD、反扫描、反量化、反变换IDCT和运动补偿5个过程。<br>简化的视频流解码流程如下图所示：<br><img src="/img/video_decoding_process.jpg" alt="视频流解码流程"></p><p><strong><em>视频解码流程</em></strong></p><h3 id="6-1、高层语法结构"><a href="#6-1、高层语法结构" class="headerlink" title="6.1、高层语法结构"></a>6.1、高层语法结构</h3><p>&ensp; &ensp;  码流中针对宏块和所有其他语法结构中的各种参数和标志都应该按照第6小节（参考文献）的语法和语义进行解释。很多参数和标志将会影响下面的解码过程。一旦给定图像中所有宏块都解码完，整幅图像就可以重建出来了。<br>&ensp; &ensp;  重构场图将成对形成重构帧。<br>&ensp; &ensp;  重构帧序列需要按照6.1.1.11进行帧重排序。<br>&ensp; &ensp;  如果progressive_sequence ==1，则重构帧将以帧周期为时间间隔从解码过程输出。如果progressive_sequence ==0，则重构帧将被分成一个重构场的序列，在解码过程中，以由规律的场周期为时间间隔出现。</p><h3 id="6-2、可变长解码VLD（Variable-length-decoding）"><a href="#6-2、可变长解码VLD（Variable-length-decoding）" class="headerlink" title="6.2、可变长解码VLD（Variable length decoding）"></a>6.2、可变长解码VLD（Variable length decoding）</h3><p>&ensp; &ensp; 可变长解码的过程实质上是将编码码流中的VLC码按照一定的语法规则转化成一维残差系数QFS[n]。</p><p><strong>（1）帧内块DC系数（DC coefficient(n=0)）</strong></p><p>&ensp; &ensp; dct_dc = dct_dc_pred[cc] + dct_dc_diff ; 其中dct_dc_pred[cc]为DC系数预测值， dct_dc_diff为DC系数差分值。</p><ul><li>1）差分值dct_dc_diff的确定<br>&ensp; &ensp; 帧内宏块中块的DC系数按照标准中附录II-B的表II-B-12和II-B-13所定义的变长码进行编码，并指明dct_dc_size。如果dct_dc_size等于0，则当前帧内块的DC系数就等于DC系数的预测值；否则，后面要跟着一个固定长度码（以dct_dc_size为位数的dc_dct_differential）。这个DC系数差分值首先从编码的数据中恢复出来，然后加上预测值就可以恢复出最终的解码系数。</li><li>2）预测值dct_dc_pred[cc]的确定<br>&ensp; &ensp;  有三个DC系数的预测器，每个颜色分量一个。每次对帧内宏块中的块的DC系数进行解码时，将预测值与差分值相加来恢复实际的DC系数值。然后预测器的值被设置为刚刚解码的系数值。在下面描述的不同时刻，预测器的值需要被重置。<ul><li>在一个Slice的开始；</li><li>当解码的宏块是非帧内宏块时；</li><li>当解码的宏块时Skip块，即当macroblock_address_increment &gt; 1时。</li></ul></li></ul><p>复位值的确定通过参数intra_dc_precision按下表确定：<br><img src="/img/dc_precision.png" alt="intra_dc_precision"></p><ul><li><p>3）Intra块DC系数值QFS[0]的计算：<br><img src="/img/qfs.png" alt="Intra块DC系数值QFS[0]"></p><ul><li>4）范围限定<br>比特流中有一个规定，QFS[0]必须在以下范围内取值：<br>0~((2^(8 + intra_dc_precision)) - 1)</li></ul></li></ul><p><strong>（2）其他系数（AC系数(n&gt;0)和非帧内块的DC系数）</strong><br>&ensp; &ensp; 除了帧内DC系数外的其他系数都采用标准中表B.14，B.15和B.16进行编码。</p><ul><li><p>1）所有变长码首先都要使用表B.14或表B.15来解码，解码值指明了采用下面三种行动中的哪一种。</p><ul><li><p>块结束。此时块中再没有别的系数，块中剩余的系数应被置为0。采用句法”End of block”表示 。</p></li><li><p>正常系数。解码得到的run和level值的后面紧跟一个bit的s值，s给出了这个系数的符号。run个系数应该设置为0，剩余系数应该设置为signed_level。<br>if (s ==0)<br> signed_level = level;<br>else<br> signed_level = (-level);</p></li><li><p>Escape编码系数。其中run和signed_level采用定长编码，具体见 4）Escape编码。</p></li></ul></li><li><p>2）码表选择<br>下表指明了DCT系数的解码将用到哪个表。<br><img src="/img/vlc_tables.png" alt="码表选择"></p><ul><li>3）非帧内块DC系数的解码<br>&ensp; &ensp; 对于非帧内块的第一个系数的解码，需要将表B.14按照表下面的Note2和Note3所指示的那样进行修改。这个修改仅影响了表示run=0，level=+/-1的表项。<br>（此处有疑问？ Note 3 &amp; Note 4）<blockquote><p>理解：对于非帧内块DC系数的解码，如果第一个系数为run=0，level=+/-1的情况，则VLC码位1s；如果其他系数为run=0，level=+/-1的情况，则VLC编码为11s。</p></blockquote></li></ul></li></ul><p>&ensp; &ensp;部分DCT系数表如下图表所示：<br><img src="/img/dct_coeff_zero.png" alt="部分DCT系数表"></p><ul><li>4）Escape编码<br>&ensp; &ensp; 很多可能的run和level值的组合并没有变长码来表示它们。为了编码这些统计上很少出现的组合，    采用了Escape编码方法。</li></ul><p><strong>Escape编码方法：</strong><br>Escape VLC采用6位的固定长度码来表示run，紧跟12位的固定长度码表示signed_level，表B.16中定义了紧跟ESCAPE码后的run和level的固定长度编码方法。</p><ul><li>5） 其余系数解码的小结<br>在其余系数解码开始，对于帧内块n=1,对于非帧内块，n=0。</li></ul><h3 id="6-3、反扫描-Inverse-scan"><a href="#6-3、反扫描-Inverse-scan" class="headerlink" title="6.3、反扫描 Inverse scan"></a>6.3、反扫描 Inverse scan</h3><p>&ensp; &ensp; 以QFS[n]表示变长码解码器输出端的数据，n在0<del>63的区间内。<br>&ensp; &ensp; 反扫描的过程就是将一维数据QFS[n]转换成二维系数矩阵QF[v][u]，其中u和v均在区间0</del>7中。反扫描的块大小为8x8。<br>&ensp; &ensp; MPEG-2标准定义了2个扫描模板。将要采用的扫描模板通过编码在picture_coding_extension中的句法alternate_scan来确定。</p><p>&ensp; &ensp;下面图7-2和图7-3分别是2种扫描模板：</p><p>图7-2为alternate_scan为0的情况，是常用的zig_zag扫描顺序。<br>图7-3为alternae_scan位1的情况，是垂直交替扫描方式，与MPEG-4标准中的垂直交替扫描方式一样。</p><h4 id="6-3-1-加载矩阵的反扫描"><a href="#6-3-1-加载矩阵的反扫描" class="headerlink" title="6.3.1  加载矩阵的反扫描"></a>6.3.1  加载矩阵的反扫描</h4><p>&ensp; &ensp; 当量化矩阵被加载时，它们以一种扫描顺序在比特流中编码，被转化成反量化器中使用的二维矩阵，就像系数使用的方法一样。<br>&ensp; &ensp;  对于矩阵加载，通常采用zigzag扫描方式，即图7-2中的扫描方式。<br>&ensp; &ensp;   以W[w][u]][v]表示反量化器中的加权矩阵，W[w][n]表示码流中编码的矩阵。则加载矩阵等效于下面过程：<br><img src="/img/20181025204056388.png" alt="加载矩阵"></p><h3 id="6-4-反量化-Inverse-quantisation"><a href="#6-4-反量化-Inverse-quantisation" class="headerlink" title="6.4  反量化 Inverse quantisation"></a>6.4  反量化 Inverse quantisation</h3><p>&ensp; &ensp; 二维系数矩阵QF[v][u]通过反量化生成重构DCT系数 F[v][u]。这个过程本质上是乘以量化步长。量化步长可以通过2种方式进行修改：</p><ul><li>通过权重矩阵改变一个块的量化步长；</li><li>使用尺度因子在很少几个比特的花费下（和编码整个全新矩阵相比）改变量化步长。</li></ul><p>下图7-4描述了反量化的整个过程。通过适当的反量化算法得到系数F’’[v][u]后，经饱和运算得到了F’[v][u]，最后进行了错误匹配控制操作，得到最终的重建DCT系数F[v][u]。</p><p><strong>1）帧内DC系数的反量化</strong><br>F’’[0][0] = intra_dc_mult * QF[0][0]</p><p>在帧内块中，F’’[0][0]通过一个常数因子与QF[0][0]相乘而得到，这个常数因子intra_dc_mult既不会被加权矩阵修改，也不会被比例因子修改。常数因子的值与编码在码中的picure_coding_extension的参数intra_dc_precision有关。</p><p> <strong>2）其他系数</strong><br>除了帧内块DC系数以外的其他系数的反量化在这一节中进行讲述。</p><ul><li><p>权重矩阵<br>&ensp; &ensp;当使用4:2:0格式时，要用到两个加权矩阵。一个用于帧内宏块，另一个用于非帧内宏块。当使用4:2:2或4:4:4格式数据时，用到4个矩阵，允许亮度和色度数据分别使用不同矩阵。每个矩阵都有一套缺省值，但可以通过加载用户定义的矩阵而被重写。<br>&ensp; &ensp; 以W[w][v][u]表示加权矩阵，其中w取值为0~3，表明正在使用哪一个矩阵。表7-5总结了选择w的规则。</p></li><li><p>量化比例因子<br>&ensp; &ensp; 量化比例因子被编码成5bit的固定长度码，即quantiser_scale_code。这个值表示用于反量化算法中适当的quantiser_scale值。<br>&ensp; &ensp; q_scale_type（编码在picture_coding_extension中）表明了应该使用哪一种quantiser_scale_code与quantiser_scale之间的对应映射关系。具体关系如下表7-6所示：</p></li><li><p>重构公式<br>下面的公式表示从QF[v][u]重建得到F’’[v][u]的算法（针对除了帧内DC系数外的其他系数）：<br><img src="/img/20181026135603899.png" alt="重构公式"></p></li></ul><p>  <strong>这就是MPEG反量化方法。在MPEG-4标准中采用了2种反量化方法，分别是MPEG反量化方法和H263反量化方法</strong>。</p><ul><li>饱和 Saturation<br>反量化得到的系数要饱和到[-2048, +2047]之间，因此，饱和满足如下公式：<br><img src="/img/20181026140038132.png" alt="饱和"></li><li>错误匹配控制 Mismatch control<br>错误匹配控制可以使用和下面等效的过程。首先对块中所有重建的饱和系数F’[v][u]求和，然后判断这个值是奇数还是偶数。如果它是偶数，那么系数F[7][7]将要被修正。</li></ul><p><strong>3） 反量化小结</strong><br>反量化过程为任何与下面在数字结果相等价的过程：<br><img src="/img/20181026141923129.png" alt="反量化过程"></p><h3 id="6-5-反变换-IDCT"><a href="#6-5-反变换-IDCT" class="headerlink" title="6.5 反变换 IDCT"></a>6.5 反变换 IDCT</h3><p>&ensp; &ensp; 一旦DCT系数F[v][u]被重构，那么就可以用反DCT变换获得反变换值f[y][x]，这些值要被饱和到 [-256, 255]。</p><h4 id="6-5-1-兼容IDCT的说明"><a href="#6-5-1-兼容IDCT的说明" class="headerlink" title="6.5.1 兼容IDCT的说明"></a>6.5.1 兼容IDCT的说明</h4><p>NxN的二维DCT计算公式如下所示：</p><p>数学上<strong>实数IDCT</strong>定义如下：</p><p><strong>整数IDCT</strong>定义如下：<br>     &ensp; &ensp;    f ‘(x, y) = round(f(x, y)) ，其中round是取整函数，取整到最相近的整数，中间值取整到远离0的值。<br><strong>饱和的整数IDCT</strong>定义如下：<br>     &ensp; &ensp;  f “(x, y) = saturate(f ‘(x, y))</p><p><font color="red"><strong>只要满足标准附录A中的4个要求，解码过程中使用的IDCT函数f[y][x]可以等于饱和的整数IDCT   f “(x, y)的多个近似值。</strong></font></p><h4 id="6-5-2-非编码块和跳过宏块"><a href="#6-5-2-非编码块和跳过宏块" class="headerlink" title="6.5.2  非编码块和跳过宏块"></a>6.5.2  非编码块和跳过宏块</h4><p>&ensp; &ensp;  在一个非跳过宏块中，针对宏块中的特定块，如果pattern_code[i]等于1，那么码流中含有这个块的残差数据，这将使用前面章节所述的方法进行解码。否则，如果pattern_code[i]等于0或者当前宏块是Skip块，那么这个块不包含残差数据。因此这种块像素域系数f[y][x]都将取零值（即非编码块和跳过宏块的残差为0）。</p><h3 id="6-6-运动补偿-Motion-compensation"><a href="#6-6-运动补偿-Motion-compensation" class="headerlink" title="6.6 运动补偿 Motion compensation"></a>6.6 运动补偿 Motion compensation</h3><p>&ensp; &ensp;  运动补偿过程是利用前面解码的图像形成预测，然后与残差系数数据（IDCT过程的输出）结合恢复出最终解码图像。前面6.2~6.5过程都是在讲述残差数据的解码过程，本小节重点讲述预测图像的建立过程，即基于插值的运动补偿过程。</p><p>通常，对于每个块最多可以形成4种独立的预测，组合起来形成最终的预测块p[y][x]。</p><ul><li>对于帧内编码宏块，没有预测，因而p[y][x]为0。</li><li>对于不编码的宏块，则可能是由于整个宏块都是Skip块，或者是由于这个不编码的块没有残差系数。在这种情况下，f[y][x]为0，解码样本仅为预测值p[y][x]。</li></ul><h4 id="6-6-1-预测方式-Prediction-modes"><a href="#6-6-1-预测方式-Prediction-modes" class="headerlink" title="6.6.1  预测方式 Prediction modes"></a>6.6.1  预测方式 Prediction modes</h4><p>预测方式主要有2种：<strong>场预测和帧预测</strong>。<br>在场预测中，通过使用一个或多个以前解码场中的数据，每个场都可以独立的进行预测。帧预测由一个或多个以前的解码帧形成帧的预测。</p><blockquote><p>注意：<br>（1）用来产生预测的这些场和帧本身是可以按照场图或帧图进行解码的。<br>（2）在一个场图中，所有预测都是场预测。而在帧图中，既可能用到场预测，也可能用到帧预测（在宏块基础上选择）。</p></blockquote><p>除了场预测和帧预测这两种模式，还使用到两种特殊的预测模式：</p><ul><li><p>16x8运动补偿<br>这种模式仅用于场图。其中，每个宏块使用两个运动矢量，第一个运动矢量用于上面的16x8区域，第二个运动矢量用于下面的16x8区域。对于双向预测宏块，总共要用到四个运动矢量，两个用于前向预测，两个用于后向预测。</p></li><li><p>双基 dual-prime<br>这种模式仅用于在参考场（帧）与被预测场（帧）之间没有B图的P图。其中，在比特流中，仅有一个运动向量和一个小的差分运动向量被编码。<br>==对于场图，从这个信息中可以得到两个运动向量，它们用于分别从两个参考场（一个顶场，一个底场）中形成预测，之后被平均来形成最终的预测？<br>对于帧图，两个场都重复这一过程，因此总共进行4个场预测。==</p></li><li><p>换个角度小结一下<br>从前向预测和后向预测的角度来看预测方式：</p><ul><li>前向预测<br>对于帧图像，预测方式有帧预测、场预测和双基预测；<br>对于场图像，预测方式有场预测、16x8运动补偿和双基预测。</li><li>后向预测<br>对于帧图像，预测方式有帧预测和场预测；<br>对于场图像，预测方式有场预测和16x8运动补偿。<br><font color="red">因此，只有双基预测方式，既可以用于帧图像，也可以用于场图像。</font></li></ul></li></ul><h4 id="6-6-2-参考帧（场）的选择"><a href="#6-6-2-参考帧（场）的选择" class="headerlink" title="6.6.2   参考帧（场）的选择"></a>6.6.2   参考帧（场）的选择</h4><ol><li>场预测</li></ol><p><strong>P图的场预测：</strong><br>在P图中，采用最近解码的两个解码场进行预测。<br>有如下几种情况：<br>1）对帧图进行场预测或者对编码帧的一个场图（顶场）进行预测：</p><blockquote><p>注意：<br>1.参考场本身可能由两个场图或者单个帧图重构而成；<br>2.在对一个场图进行预测是，被预测的场既可以是顶场，也可以是底场。</p></blockquote><p>  2）对编码帧的第二个场图进行预测：<br>要用到两个最近被解码的参考场，其中最近一个参考场要通过对这个编码帧的第一个场图解码得到。<br>如下图7-7表示第二个场图为底场的情形。==（此处有疑问？）==</p><p>图7-8表示当第二个场图为顶场的情形。</p><p><strong>B图的场预测：</strong><br>在B图中，场预测应该由最近重构的两个参考帧的两场进行预测。如下图所示：</p><blockquote><p>注意： 参考帧本身可能是由两个场图或者一个单一的帧图像重构而成。</p></blockquote><ol start="2"><li>帧预测</li></ol><p><strong>对于P图</strong>，利用最近重构的参考帧进行预测，如下图7-10所示。</p><blockquote><p>注意：</p><ol><li>MPEG-2只支持单参考帧预测，一般是最近重构的前一帧（对于P帧）。MPEG-4中的P帧也支持单参考帧预测，到H264才支持多参考帧。</li><li>参考帧本身可能是由两个场图或者一个单一的帧图像重构而成。</li></ol></blockquote><p><strong>对于B图</strong>，帧预测通过两个最近的重构参考帧进行。</p><h4 id="6-6-3-运动向量"><a href="#6-6-3-运动向量" class="headerlink" title="6.6.3  运动向量"></a>6.6.3  运动向量</h4><p>&ensp; &ensp; 为了减少表示运动向量所需要的bit数，<font color="red">运动向量根据前一个运动向量进行差分编码</font>。为了解码运动矢量，解码器必须保持4个运动矢量预测器PMV[r][s][t]。对于每个预测，先得到一个运动向量 vector’[r][s][t]，然后根据采样格式（4:2:0或4:2:2或4:4:4）对其进行改变，为每个颜色分量给出一个运动向量vector[r][s][t]。这个数组中维数的含义如图表7-7所示：</p><h5 id="6-6-3-1-运动向量解码"><a href="#6-6-3-1-运动向量解码" class="headerlink" title="6.6.3.1  运动向量解码"></a>6.6.3.1  运动向量解码</h5><p>  每个运动向量分量vector’[r][s][t]都应该按照与下面等价的过程进行计算。并且运动矢量预测器也应按照这个过程进行修改。</p><h5 id="6-6-3-2-运动向量限制"><a href="#6-6-3-2-运动向量限制" class="headerlink" title="6.6.3.2.  运动向量限制"></a>6.6.3.2.  运动向量限制</h5><p>在帧图中，场运动向量的垂直分量应该受到限制，以使它们仅覆盖与那些运动向量相关的f_code所支持范围的一半。这个限制保证了运动向量预测器对于解码后续帧运动矢量能够具有合适的值。限制如表7-8所示：</p><h5 id="6-6-3-3-更新和复位运动矢量预测器"><a href="#6-6-3-3-更新和复位运动矢量预测器" class="headerlink" title="6.6.3.3. 更新和复位运动矢量预测器"></a>6.6.3.3. 更新和复位运动矢量预测器</h5><p>==复位运动矢量预测器：==<br>当宏块中所有运动向量解码完之后，有时需要修改一些运动向量预测器。这是因为在一些预测模式中，可能会使用少于最大可能数目的运动向量。<br>运动向量预测器应按表7-9和表7-10所示进行修改。<br>==复位运动矢量预测器：==<br>在下列情况下，所有的运动矢量预测器都将被复位为零。</p><ul><li>在每个slice的开始；</li><li>当没有隐藏运动矢量的帧内宏块被解码时；</li><li>在P图中，当macroblock_motion_forward为零的非帧内宏块被解码时；</li><li>在P图中，当一个宏块被跳过时。</li></ul><h5 id="6-6-3-4-P帧的预测"><a href="#6-6-3-4-P帧的预测" class="headerlink" title="6.6.3.4. P帧的预测"></a>6.6.3.4. P帧的预测</h5><p> 在P帧中，如果macroblock_motion_forward为0并且macroblock_intra为零，则这个宏块没有运动矢量编码，然后必然形成预测。运动矢量为(0, 0)。此时运动矢量预测器应该被复位为0。</p><h5 id="6-6-3-5-色度分量的运动矢量确定"><a href="#6-6-3-5-色度分量的运动矢量确定" class="headerlink" title="6.6.3.5. 色度分量的运动矢量确定"></a>6.6.3.5. 色度分量的运动矢量确定</h5><p>前面章节所计算的运动矢量都是针对亮度分量： vector[r][s][t] = vector’[r][s][t] (for all r, s and t)<br>对于每个色度分量，运动矢量按照如下方式进行改变：<br><strong>4:2:0 运动矢量的水平和垂直分量都除以2</strong><br> vector[r][s][0] = vector’[r][s][0] / 2;<br> vector[r][s][1] = vector’[r][s][1] / 2;</p><p><strong>4:2:2 运动矢量的水平分量除以2，垂直分量不变</strong><br>vector[r][s][0] = vector’[r][s][0] / 2;<br>vector[r][s][1] = vector’[r][s][1];</p><p><strong>4:4:4 不修改运动矢量</strong><br> vector[r][s][0] = vector’[r][s][0];<br>vector[r][s][1] = vector’[r][s][1];</p><h5 id="6-6-3-6-隐藏的运动矢量"><a href="#6-6-3-6-隐藏的运动矢量" class="headerlink" title="6.6.3.6. 隐藏的运动矢量"></a>6.6.3.6. 隐藏的运动矢量</h5><p>隐藏的运动矢量是帧内宏块中所带的运动矢量，是为了数据错误阻碍了系数解码时来掩盖错误引入的。当且仅当concealment_motion_vectors(在picuture_coding_extension中)的值为1时，在所有帧内宏块中均会出现隐藏的运动矢量。<br><strong>隐藏运动矢量是用于由于数据错误而导致信息丢失的情况。</strong></p><h5 id="6-6-3-7-双基附加算法"><a href="#6-6-3-7-双基附加算法" class="headerlink" title="6.6.3.7. 双基附加算法"></a>6.6.3.7. 双基附加算法</h5><p>双基附加算法详见标准P77（7.6.3.6 Dual prime additional algorithm）。</p><h4 id="6-6-4-形成预测"><a href="#6-6-4-形成预测" class="headerlink" title="6.6.4   形成预测"></a>6.6.4   形成预测</h4><p>预测通过从参考帧或场中读取预测像素而形成。一个给定样本通过读取参考帧或参考场由运动矢量指明的相应样本而被预测。<br>所有运动矢量被规定为<strong>半像素精度</strong>。半像素的情况通过简单的线性插值获得。</p><h4 id="6-6-5-跳过宏块"><a href="#6-6-5-跳过宏块" class="headerlink" title="6.6.5 跳过宏块"></a>6.6.5 跳过宏块</h4><p>跳过宏块（Skip宏块）表示没有数据被编码，跳过宏块是编码的slice的一部分。<br>对于Skip宏块，预测值等于重构值。<br>除了在一个slice的开始，如果number(macroblock_address - previous_macroblock_address -1)大于1，则表示需要跳过number个宏块的编码。</p><p>其中在P图和B图中对跳过宏块的处理不同，并且对于帧和场的处理也不同。</p><ul><li>P场图<ul><li>按照field_motion_type为基于场的方式进行预测；</li><li>参考场应该为与当前场具有相同奇偶性的场；</li><li>运动矢量预测器应该被复位为0；</li><li>运动矢量应为0。</li></ul></li><li>P帧图<ul><li>按照frame_motion_type为基于帧的方式进行预测；</li><li>运动矢量预测器应复位为0；</li><li>运动矢量应为0。</li></ul></li><li>B场图<ul><li>按照field_motion_type为基于场的方式进行预测；</li><li>参考场应该为与当前场具有相同奇偶性的场；</li><li>预测方向（前向、后向或双向）应该与前一个宏块相同 。</li><li>运动矢量预测器不受影响。</li><li>运动矢量通过合适的运动矢量预测器得到。色度分量的运动矢量的改变按照标准7.6.3.7所述。</li></ul></li><li>B帧图<ul><li>按照frame_motion_type为基于帧的方式进行预测；</li><li>预测方向（前向、后向或双向）应该与前一个宏块相同；</li><li>运动矢量预测器不受影响</li><li>运动矢量通过合适的运动矢量预测器得到。色度分量的运动矢量的改变按照标准7.6.3.7所述。</li></ul></li></ul><h4 id="6-6-6-组合预测"><a href="#6-6-6-组合预测" class="headerlink" title="6.6.6 组合预测"></a>6.6.6 组合预测</h4><p>最后的步骤是将各种预测组合到一块，以形成最终的预测块。<br>将这些数据按场或帧的方式组织到块中，并且使其可以直接加到解码系数上。<br>变换系数是以场组织方式还是以帧组织方式是由dct_type决定的。</p><ul><li><p>简单帧预测<br>对于简单的帧预测来说，所需要做的进一步处理就是<strong>将B图中的前向预测和后向预测求平均。</strong><br>如果pel_pred_forward[y][x]是前向预测样本，且pel_pred_backward[y][x]是对应的后向预测样本，则最终的预测样本应如下形成：<br><img src="/img/20181029143030658.png" alt="简单帧预测 示意图"><br>对于4:2:0格式、4:2:2格式和4:4:4格式的色度分量预测，对应块尺寸应分别为8x8，16x8和16x8。</p></li><li><p>简单场预测<br>对于简单的场预测来说，所需要做的进一步处理仅是将B图中前向和后向预测求平均。这将按照上一节中帧预测那样实现。</p><ul><li>对于帧图像中的简单场预测，每个场中的4:2:0格式、4:2:2格式和4:4:4格式的色度分量的块尺寸应分别4x8，8x8和16x8。</li><li>对于场图像中的简单场预测，每个场中4:2:0格式、4:2:2格式和4:4:4格式的色度分量的块尺寸应分别8x8，16x8和16x16。</li></ul></li><li><p>16x8运动补偿<br>在这种预测模式中，宏块的上边16x8区域和下边16x8区域会分别形成预测。<br>对于每个16x8区域的色度分量的预测，4:2:0格式、4:2:2格式和4:4:4格式对应的块尺寸分别为4x8，8x8和8x16。</p></li><li><p>双基预测<br>在双基模式中，对于每个场都形成预测，采用与B图中的后向和前向预测的方式。如果pel_pred_same_parity[y][x]是由相同奇偶性场中得到的预测样本，pel_opposite_parity[y][x]是由相反奇偶性场中得到的样本，则最终的预测样本按照如下公式形成：<br><img src="/img/20181029144906597.png" alt="双基预测 示意图"></p><ul><li>对于帧图中的双基预测，对于每个场中4:2:0格式、4:2:2格式和4:4:4格式的色度分量预测，对应的块尺寸应分别为8x4，8x8和16x8。</li><li>对于场图中的双基预测，对于每个场中:2:0格式、4:2:2格式和4:4:4格式的色度分量预测，对应的块尺寸应分别8x8，16x8和16x16。</li></ul></li></ul><h4 id="6-6-7-预测和残差数据求和"><a href="#6-6-7-预测和残差数据求和" class="headerlink" title="6.6.7 预测和残差数据求和"></a>6.6.7 预测和残差数据求和</h4><p>预测块得到之后 ，并按照与变换数据块所用的帧/场结构相匹配的方式重组为预测像素块p[y][x]。<br>变换数据块f[y][x]加上预测数据块并饱和后形成最终的解码样本d[y][x]，如下所示：<br><img src="/img/20181029150235939.png" alt="预测和残差数据求和"></p><h3 id="6-7-可分级编码"><a href="#6-7-可分级编码" class="headerlink" title="6.7 可分级编码"></a>6.7 可分级编码</h3><p><strong>MPEG-2标准支持空域分级、时域分级、SNR分级和数据分割四种基本可分级方式。</strong><br>下面进行简单介绍，详细解码过程可以参见标准7.7~7.11节。</p><ul><li>空域分级扩展<br>主要用于电信、视频标准交替、视频数据库浏览、HDTV和TV交替等应用中，即我们需要一个至少有两个空间分辨率层次的视频系统。空域分级包括从一个视频源中产生两个空间分辨率的视频层。这样，低层自己编码来提供基本的空间分辨率；增强层利用这个空域插值的低层来生成输入视频源的全分辨率。</li><li>时域分级扩展<br>时域分级扩展主要用于与从电信到HDTV的不同视频应用中，对它们来说，从低时域分辨率到高时域分辨率的转变是必要的。时域可分级将视频帧分割成层，这样，低层自身编码提供基本的时域分辨率，而增强层通过对低层进行时域预测编码，最后通过对这些层解码和时域多路复合来产生视频源的全时域分辨率。</li><li>SNR可分级扩展<br>SNR可分级主要用于电信、多质量视频服务、TV和HDTV的应用中，即我们需要一个至少有两个视频质量层的视频系统。    SNR分级包括从一个视频源中产生两个具有相同的空间分辨率和不同的视频质量的视频层，其中，低层自己编码来提供基本的视频质量，而增强层被编码来增强低层。当把增强层加回到低层时，将会重新产生输入视频的一个高质量的重构。</li><li>数据分割扩展<br>在ATM网络、陆上广播等应用中，我们可以有两个通道供视频流进行存储和传送，这种情况下可以用到数据分割。在这两个通道间比特流被分割，这样，比特流中的重要部分（比如头信息、运动矢量、DC系数）可以在错误率低的通道中传送，而不重要的部分（比如DCT系数）可以在较差的信道中传送。这样，可以将信道错误造成的损失降到最小。</li></ul><h2 id="7、参考文献"><a href="#7、参考文献" class="headerlink" title="7、参考文献"></a>7、参考文献</h2><p><a href="https://www.itu.int/rec/dologin_pub.asp?lang=e&amp;id=T-REC-H.262-200002-S!!PDF-E&amp;type=itemshttp://ecee.colorado.edu/~ecen5653/ecen5653/papers/iso13818-2.pdf" target="_blank" rel="noopener">https://www.itu.int/rec/dologin_pub.asp?lang=e&amp;id=T-REC-H.262-200002-S!!PDF-E&amp;type=itemshttp://ecee.colorado.edu/~ecen5653/ecen5653/papers/iso13818-2.pdf</a></p><hr><h2 id="THE-END"><a href="#THE-END" class="headerlink" title="THE END! "></a><font color="red"><strong>THE END!</strong> </font></h2>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 编解码 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Codecs </tag>
            
            <tag> MPEG2 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>xcode工程建立和配置（ios真机测试方法）</title>
      <link href="/2018/09/27/%E3%80%90ios%E3%80%91xcode%E5%B7%A5%E7%A8%8B%E5%BB%BA%E7%AB%8B%E5%92%8C%E9%85%8D%E7%BD%AE%EF%BC%88ios%E7%9C%9F%E6%9C%BA%E6%B5%8B%E8%AF%95%E6%96%B9%E6%B3%95%EF%BC%89/"/>
      <url>/2018/09/27/%E3%80%90ios%E3%80%91xcode%E5%B7%A5%E7%A8%8B%E5%BB%BA%E7%AB%8B%E5%92%8C%E9%85%8D%E7%BD%AE%EF%BC%88ios%E7%9C%9F%E6%9C%BA%E6%B5%8B%E8%AF%95%E6%96%B9%E6%B3%95%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="0、参考"><a href="#0、参考" class="headerlink" title="0、参考"></a>0、参考</h2><p><a href="https://blog.csdn.net/snaill/article/details/4092748" target="_blank" rel="noopener">https://blog.csdn.net/snaill/article/details/4092748</a><br><a href="https://blog.csdn.net/lizhongfu2013/article/details/42387311" target="_blank" rel="noopener">https://blog.csdn.net/lizhongfu2013/article/details/42387311</a></p><h2 id="1、xcode和ios基本概念"><a href="#1、xcode和ios基本概念" class="headerlink" title="1、xcode和ios基本概念"></a>1、xcode和ios基本概念</h2><h3 id="1-1-clang"><a href="#1-1-clang" class="headerlink" title="1.1 clang"></a>1.1 clang</h3><p>&ensp;&ensp;  Clang是一个C++编写、基于LLVM、发布于LLVM BSD许可证下的C/C++/Objective-C/Objective-C++编译器。它与GNU C语言规范几乎完全兼容(当然，也有部分不兼容的内容，包括编译命令选项也会有点差异)，并在此基础上增加了额外的语法特性，比如C函数重载(通过<strong>attribute</strong>((overloadable))来修饰函数)，其目标(之一)就是超越GCC。<br>参考：<a href="https://www.oschina.net/p/clang" target="_blank" rel="noopener">https://www.oschina.net/p/clang</a></p><h3 id="1-2-LLVM"><a href="#1-2-LLVM" class="headerlink" title="1.2  LLVM"></a>1.2  LLVM</h3><p>&ensp;&ensp;LLVM是构架编译器(compiler)的框架系统，以C++编写而成，用于优化以任意程序语言编写的程序的编译时间(compile-time)、链接时间(link-time)、运行时间(run-time)以及空闲时间(idle-time)，对开发者保持开放，并兼容已有脚本。<br>&ensp;&ensp;LLVM计划启动于2000年，最初由美国UIUC大学的Chris Lattner博士主持开展。2006年Chris Lattner加盟Apple Inc.并致力于LLVM在Apple开发体系中的应用。Apple也是LLVM计划的主要资助者。<br>&ensp;&ensp;目前LLVM已经被苹果IOS开发工具、Xilinx Vivado、Facebook、Google等各大公司采用。<br>&ensp;&ensp;LLVM官方参考：<a href="https://llvm.org/" target="_blank" rel="noopener">https://llvm.org/</a></p><h3 id="1-3-xcrun"><a href="#1-3-xcrun" class="headerlink" title="1.3  xcrun"></a>1.3  xcrun</h3><p><a href="https://developer.apple.com/library/archive/documentation/Darwin/Reference/ManPages/man1/xcrun.1.html" target="_blank" rel="noopener">https://developer.apple.com/library/archive/documentation/Darwin/Reference/ManPages/man1/xcrun.1.html</a></p><h3 id="1-4-xcode"><a href="#1-4-xcode" class="headerlink" title="1.4  xcode"></a>1.4  xcode</h3><p>&ensp;&ensp; Xcode 是运行在操作系统Mac OS X上的集成开发工具(IDE)，由Apple Inc开发。Xcode是开发 macOS 和 iOS 应用程序的最快捷的方式。Xcode 具有统一的用户界面设计，编码、测试、调试都在一个简单的窗口内完成。</p><h3 id="1-5-Objective-C"><a href="#1-5-Objective-C" class="headerlink" title="1.5 Objective-C"></a>1.5 Objective-C</h3><p>&ensp;&ensp;  Objective-C，通常写作ObjC或OC和较少用的Objective C或Obj-C，是扩充C的面向对象编程语言。它主要使用于Mac OS X和GNUstep这两个使用OpenStep标准的系统，而在NeXTSTEP和OpenStep中它更是基本语言。<br>&ensp;&ensp; GCC与Clang含Objective-C的编译器，Objective-C可以在GCC以及Clang运作的系统上编译。<br>&ensp;&ensp;  1980年代初布莱德·考克斯(Brad Cox)在其公司Stepstone发明Objective-C。他对软件设计和编程里的真实可用度问题十分关心。Objective-C最主要的描述是他1986年出版的书 Object Oriented Programming: An Evolutionary Approach. Addison Wesley. ISBN 0-201-54834-8.</p><h2 id="2、xcode工程建立和配置（ios手机测试库功能的方法）"><a href="#2、xcode工程建立和配置（ios手机测试库功能的方法）" class="headerlink" title="2、xcode工程建立和配置（ios手机测试库功能的方法）"></a>2、xcode工程建立和配置（ios手机测试库功能的方法）</h2><h3 id="2-1-xcode新建工程："><a href="#2-1-xcode新建工程：" class="headerlink" title="2.1 xcode新建工程："></a>2.1 xcode新建工程：</h3><p>（1）用于单元测试：<br>File–&gt;new—&gt;Project—&gt;iOS(application)–&gt;选择single view Application,然后根据提示选择工程路径，即可完成工程的创建。<br>（2）用于库测试：<br>File—&gt;new—&gt;Project—&gt;iOS(FrameWork &amp; Library)—&gt;选择Cocoa Touch Static Libarary，然后根据提示选择工程路径，即可完成工程的创建。</p><h3 id="2-2-xcode工程配置："><a href="#2-2-xcode工程配置：" class="headerlink" title="2.2 xcode工程配置："></a>2.2 xcode工程配置：</h3><p>（1）在左上角工程文件名称旁边选择设备名称；<br>（2）在执行工程之前，单击工程名称，需要检查如下配置：<br>a. 单击工程名，在General菜单栏中确认Linked Framework and Libararies下是否需要添加的码流文件或者库文件等；Build Phases中确认Complie Sources（需编译的资源）和Linked Binary with Libaraies（库文件）等。</p><blockquote><p>注意事项：库文件添加必须通过Build Phases中Linked Binary with Libaraies添加，不能通过将资源拖拽到包（工程）中！</p></blockquote><p>b. 在Build Setting中确认Architectures：</p><p>下面三个选项是与架构平台相关的选项：<br><strong>Architectures：</strong><br>   Space-separated list of identifiers. <strong>Specifies the architectures (ABIs, processor models) to which the binary is targeted.</strong> When this build setting specifies more than one architecture, the generated binary may contain object code for each of the specified architectures.</p><p><strong>ONLY_ACTIVE_ARCH</strong>：在需要编译全平台的ios可执行文件时，设置为no，此时VALID_ARCHS无效；否则单独编译某个平台的ios可执行文件时，设置为yes。设置为yes，只编译当前的Architecture和ONLY_ACTIVE_ARCH交集的版本。该选项用于指定是否只对当前连接设备所支持的指令集编译。在xcode6.1中VALID_ARCH默认指定为Standard architectures(armv7,arm64)，这样会编译打包32位和64位的代码。</p><p>当其值设置为YES，这个属性设置为yes，是为了debug的时候编译速度更快，它只编译当前的architecture版本，而设置为no时，会编译所有的版本。 编译出的版本是向下兼容的，连接的设备的指令集匹配是由高到低（arm64 &gt; armv7s &gt; armv7）依次匹配的。比如你设置此值为yes，用iphone4编译出来的是armv7版本的，iphone5也可以运行，但是armv6的设备就不能运行。  所以，一般debug的时候可以选择设置为yes，release的时候要改为no，以适应不同设备。</p><p><strong>VALID_ARCHS</strong>: ios32: armv7,armv7s   ；ios64: arm64</p><p> Space-separated list of identifiers. Specifies the architectures for which the binary may be built. During the build, this list is intersected with the value of ARCHS build setting; the resulting list specifies the architectures the binary can run on. If<br> the resulting architecture list is empty, the target generates no binary.</p><p>关于Architectures和VALID_ARCHS的选择，更多可参考：<br><a href="https://blog.csdn.net/lizhongfu2013/article/details/42387311" target="_blank" rel="noopener">https://blog.csdn.net/lizhongfu2013/article/details/42387311</a></p><blockquote><p>注意事项：ios平台打包所有平台静态库(lib_universal.a)的方法：<br>makefile脚本如下：</p></blockquote><pre><code>all:    test -d ../bin/tmp || mkdir ../bin/tmp    #armv7    make -C ./dec_lib PLATFORM=ios32    cp ../lib/ios32/lib_test.a ../bin/tmp/lib_test_ios32.a    #arm64    make -C ./dec_lib PLATFORM=ios64    cp ../lib/ios64/lib_test.a ../bin/tmp/lib_test_ios64.a    #i386    make -C ./dec_lib PLATFORM=ios_i386    cp ../lib/ios_i386/lib_test.a ../bin/tmp/lib_test_ios_i386.a    #x86_64    make -C ./dec_lib PLATFORM=ios_x86_64    cp ../lib/ios_x86_64/lib_test.a ../bin/tmp/lib_test_ios_x86_64.a    libpo -create ../bin/tmp/* -output ../lib/libtest_univesal.a    rm -rf ../bin/tmp</code></pre><p>（3）添加demo文件（main.c，头文件）。将demo文件和库文件拷贝到刚刚建立的xcode工程下面，在工程名上右键–&gt;add files to xxx—&gt;选择需要添加的文件完成文件添加。<br>（4）工程设置。点击工程名—&gt;build settings—&gt;code signing–&gt;设置code signing identity中的项目（debug/release）。<br>（5）添加静态库文件。点击工程名—&gt;build phases—&gt;link binary with libraries—&gt;将需要添加的库加进来。<br>（6）添加资源文件。点击工程名—&gt;build phases—-&gt;copy bundle resourses—&gt;将需要的资源文件添加进来。<br>（7）读取码流文件。点击itools工具—&gt;选择新建的app名字—-&gt;点击文件夹符号—-&gt;documents—-&gt;导入—–&gt;选中需要导入的测试码流。需要注意读取码流文件时的路径应该也是手机中documnent目录。<br>（8）在app控件初始化函数中添加代码。在主函数中需添加在ViewController.m的viewDidLoad函数中，作为一个普通函数调用：<br>例如：</p><pre><code class="c">int main_test(int argc, char *argv[], char *pin, char *pout); //函数声明-(void) viewDidLoad{[super viewDidLoad];NSArray* array = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES);//当前报的域指向对应手机中的文件指针NSString* strDocument = [array objectAtIndex:0];NSString* outfilePath = [strDocument stringByAppendingPathComponent:@&quot;test_out.yuv&quot;];//输出路径需要在手机相应的document下！NSLog(@&quot;output path is %@&quot;,outfilePath); //用于打印数据NSString* InputfilePath = [[NSBundle mainBundle] pathForResource:@&quot;svac2&quot;];//输入文件可以直接使用包的路径，这样，码流文件放在包（工程）中即可。NSLog(@&quot;input mainBudle path is %@&quot;,InputfilePath);main_test(0,NULL,[InputfilePath UTF8String],[outputtfilePath UTF8String]);//demo文件传入相应参数}</code></pre><blockquote><p>说明:将我们自己的库demo加入到xcode工程中的方法的进一步说明：<br>测试描述：新建一个简单的app工程，将原来我们自己的库demo添加到app中测试，可以将main_test()函数添加到app控件初始化函数下（需要将demo文件中的main函数修改为main_test函数名），这样控件初始化的时候，就可以执行main_test()函数。</p></blockquote><p>（9）从手机中获取xcode工程生成的yuv文件或者log文件：<br>a. 在launchpad中找到iTools；<br>b. 在应用中找到进行解码的xcode工程名称，比如test_demo，然后选中工程右键选择文档；然后点击所需要的文件导出即可。</p><p>（10）一个xcode工程既可以运行arm_ios32汇编，也可以运行arm_ios64汇编，需要选中TARGETS进行相应修改：<br>a. 在工程设置Build_settings下Architectures—-ONLY_ACTIVE_ARCH设为Yes;<br>b. 在工程设置Build_settings下Architectures—-VALID_ARCHS中<br>  ios32: armv7<br>  ios64: arm64</p><h3 id="2-3-测试环境："><a href="#2-3-测试环境：" class="headerlink" title="2.3 测试环境："></a>2.3 测试环境：</h3><p>mac（xcode6.1环境）+iphone SE<br>ios 32位测试机：iphone 5c （苹果A6（Cortex-A7处理器），32位双核处理器，1G运行内存，架构：armv7s）<br>ios 64位测试机： iphone 6s （苹果A9，64位双核处理器，2G运行内存，架构：arm64）</p><h3 id="2-4-运行："><a href="#2-4-运行：" class="headerlink" title="2.4 运行："></a>2.4 运行：</h3><ol><li>用数据线连接苹果手机</li><li>点击xcode中的运行按钮或者Fn+F6，即可完成编译和运行。</li><li>生成的yuv文件或者log文件在手机的document目录下面。</li><li>在使用xcode IDE过程中，可以设置断点进行单步调试或者采用NSLog函数打印相关信息。</li></ol><h3 id="2-5-补充知识："><a href="#2-5-补充知识：" class="headerlink" title="2.5 补充知识："></a>2.5 补充知识：</h3><p>ios/mac相关编译器、系统库和头文件的选择及其路径：<br>1、编译器路径：<br>无论是对于ios还是ios simulator都是这个路径：</p><pre><code>/Applications/Xcode6.4.app/Contents/Developer/ToolChains/XcodeDefault.xctoolchain/usr/bin/clang</code></pre><p>2、系统库和头文件路径：<br>在路径/Applications/Xcode.app/Contents/Developer/Platforms下面</p><p>3、查看编译器或工具的路径：</p><pre><code>xcrun -sdk iphonesimulator -findxcrun -sdk iphoneos -findxcrun -sdk macos -find clang</code></pre><hr><h2 id="THE-END！"><a href="#THE-END！" class="headerlink" title="THE END！"></a><font color="red"><strong>THE END！</strong></font></h2>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 工程化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ios </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mac和ios通用编译环境</title>
      <link href="/2018/09/26/%E3%80%90PE%E7%B3%BB%E5%88%97%E3%80%91mac%E5%92%8Cios%E9%80%9A%E7%94%A8%E7%BC%96%E8%AF%91%E7%8E%AF%E5%A2%83/"/>
      <url>/2018/09/26/%E3%80%90PE%E7%B3%BB%E5%88%97%E3%80%91mac%E5%92%8Cios%E9%80%9A%E7%94%A8%E7%BC%96%E8%AF%91%E7%8E%AF%E5%A2%83/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="1、MAC编译环境配置"><a href="#1、MAC编译环境配置" class="headerlink" title="1、MAC编译环境配置"></a>1、MAC编译环境配置</h2><p><strong>mac32：</strong></p><pre><code>ifeq ( $(findstring mac32, $(platform)), mac32)CC = gccCPP = g++LD = ldAR = arCFLAGS += -fPIC -arch i386 -m32LDFLAGS += -Wl,  -Bsymbolic-functionsLDFLAGS += -m32 -read_only_relocs suppressendif</code></pre><p><strong>mac64：</strong></p><pre><code>ifeq ( $(findstring mac64, $(platform)), mac64)CC = gccCPP = g++LD = ldAR = arCFLAGS += -fPIC  -arch x86_64  -m64LDFLAGS += -Wl,  -Bsymbolic-functions -m64LDFLAGS += -m64 -read_only_relocs suppressendif</code></pre><h2 id="2、ios编译环境配置"><a href="#2、ios编译环境配置" class="headerlink" title="2、ios编译环境配置"></a>2、ios编译环境配置</h2><p><strong>ios32：</strong></p><pre><code>ifeq ( $(findstring ios32, $(platform)), ios32)CC = xcrun -sdk iphoneos clangCPP = xcrun -sdk iphoneos clangAR = arCFLAGS += -arch armv7 -mios-version-min=6.0  -march=armv7-aLDFLAGS += -arch armv7 -mios-version-min=6.0  -march=armv7-a  -Wl,  -Bsymbolic-functions -read_only_relocs suppressendif</code></pre><p><strong>ios64：</strong></p><pre><code>ifeq ( $(findstring ios64, $(platform)), ios64)CC = xcrun -sdk iphoneos clangCPP = xcrun -sdk iphoneos clangAR = arCFLAGS += -Wall -O3 -arch arm64 -mios-version-min=6.0  LDFLAGS += -arch arm64 -mios-version-min=6.0   -Wl,  -Bsymbolic-functionsendif</code></pre><p><strong>i386模拟器环境：</strong></p><pre><code>ifeq ( $(findstring ios_i386, $(platform)), ios_i386)CC = xcrun -sdk iphonesimulator clangCPP = xcrun -sdk iphonesimulator clangAR = arCFLAGS += -Wall -O3 -arch i386 -mios-simulator-version-min=6.0  -DIOSLDFLAGS += -arch i386  -mios-simulator-version-min=6.0   -Wl,  -Bsymbolic-functionsendif</code></pre><p><strong>x86_64模拟器环境：</strong></p><pre><code>ifeq ( $(findstring ios_x86_64, $(platform)), ios_x86_64)CC = xcrun -sdk iphonesimulator clangCPP = xcrun -sdk iphonesimulator clangAR = arCFLAGS += -Wall -O3 -arch x86_64 -mios-simulator-version-min=6.0  -DIOSLDFLAGS += -arch x86_64 -mios-simulator-version-min=6.0   -Wl,  -Bsymbolic-functionsendif</code></pre><hr><h2 id="THE-END"><a href="#THE-END" class="headerlink" title="THE END! "></a><font color="red"><strong>THE END!</strong> </font></h2>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 工程化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> makefile </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>FFMPEG 命令行常用方法示例（含yuv处理命令）</title>
      <link href="/2018/09/20/%E3%80%90Codecs%E7%B3%BB%E5%88%97%E3%80%91FFMPEG%20%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%E7%A4%BA%E4%BE%8B%EF%BC%88%E5%90%AByuv%E5%A4%84%E7%90%86%E5%91%BD%E4%BB%A4%EF%BC%89/"/>
      <url>/2018/09/20/%E3%80%90Codecs%E7%B3%BB%E5%88%97%E3%80%91FFMPEG%20%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%E7%A4%BA%E4%BE%8B%EF%BC%88%E5%90%AByuv%E5%A4%84%E7%90%86%E5%91%BD%E4%BB%A4%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="1、引言"><a href="#1、引言" class="headerlink" title="1、引言"></a>1、引言</h2><p>FFMPEG以其强大的功能而在音视频领域著称，更重要的是它还是开源的！音视频格式转换、裁剪、拼接、提取字幕或某音轨等等，它都能胜任，可谓一把瑞士军刀，小巧但功能强大，是音视频研究的必备利器之一。</p><h2 id="2、常用命令示例"><a href="#2、常用命令示例" class="headerlink" title="2、常用命令示例"></a>2、常用命令示例</h2><h3 id="2-1、-转换成H264码流"><a href="#2-1、-转换成H264码流" class="headerlink" title="2.1、 转换成H264码流"></a>2.1、 转换成H264码流</h3><pre><code class="c">ffmpeg -i input_file -vcodec h264 output_file  </code></pre><p>其中 -i 表示输入文件， -vcodec  h264 表示视频编解码方式为 H264。</p><h3 id="2-2、-转换成H265码流"><a href="#2-2、-转换成H265码流" class="headerlink" title="2.2、 转换成H265码流"></a>2.2、 转换成H265码流</h3><pre><code class="c">ffmpeg -i input_file -vcode hevc output_file  </code></pre><p>其中 -i 表示输入文件， -vcodec  hevc 表示视频编解码方式为 H265，注意ffmpeg 中名称为 hevc，不是H265！</p><h3 id="2-3、-设置输出视频的分辨率"><a href="#2-3、-设置输出视频的分辨率" class="headerlink" title="2.3、 设置输出视频的分辨率"></a>2.3、 设置输出视频的分辨率</h3><pre><code class="c">ffmpeg -i input_file -vcodec h264 -s 1280x720 output_file</code></pre><p>其中 -s 表示分辨率。</p><h3 id="2-4、设置输出文件的音视频比特率"><a href="#2-4、设置输出文件的音视频比特率" class="headerlink" title="2.4、设置输出文件的音视频比特率"></a>2.4、设置输出文件的音视频比特率</h3><pre><code class="c">ffmpeg -i input_file  -vcodec h264 -b:v 10M -b:a 128K output_file</code></pre><p>其中 -b:v 10M 表示视频码率为10Mbps， -b:a 128K 表示音频码率为 128Kbps，注意FFMPEG对于码率控制，有时候不太准确，跟输入源有一定关系。</p><h3 id="2-5、-剪切某段视频"><a href="#2-5、-剪切某段视频" class="headerlink" title="2.5、 剪切某段视频"></a>2.5、 剪切某段视频</h3><pre><code class="c">ffmpeg -ss 0:05:00 -t 0:1:30 -i input_file -vcodec copy -acodec copy output_file  ffmpeg -ss 300 -t 90  -i input_file -vcodec copy -acodec copy output_file</code></pre><p>上面的两种方式等价，时间格式支持 HH:MM:SS或者秒数。 -ss 开始时间， -t 持续时间， -vcodec copy 保持原视频编码方式， -acodec copy 保持原音频编码方式。</p><blockquote><p>注意：-vcodec copy与-c:v以及-codec:v 这三种写法的功能是一样的，具体可参考：<br><a href="https://lists.ffmpeg.org/pipermail/ffmpeg-user/2017-February/035335.html" target="_blank" rel="noopener">https://lists.ffmpeg.org/pipermail/ffmpeg-user/2017-February/035335.html</a></p></blockquote><h3 id="2-6、-分离音视频流保存为不同文件"><a href="#2-6、-分离音视频流保存为不同文件" class="headerlink" title="2.6、 分离音视频流保存为不同文件"></a>2.6、 分离音视频流保存为不同文件</h3><pre><code class="c">ffmpeg -i input_file -vcodec copy -an output_file_video　　//提取视频流ffmpeg -i input_file -acodec copy -vn output_file_audio　　//提取音频流</code></pre><p>其中 -an 表示不处理音频， -vn 表示不处理视频。</p><h3 id="2-7、合并多个音视频文件为一个文件"><a href="#2-7、合并多个音视频文件为一个文件" class="headerlink" title="2.7、合并多个音视频文件为一个文件"></a>2.7、合并多个音视频文件为一个文件</h3><pre><code class="c">ffmpeg –i video_file –i audio_file –vcodec copy –acodec copy output_file</code></pre><h3 id="2-8、提取视频图像保存为图片文件-将视频分解为单幅图片"><a href="#2-8、提取视频图像保存为图片文件-将视频分解为单幅图片" class="headerlink" title="2.8、提取视频图像保存为图片文件(将视频分解为单幅图片)"></a>2.8、提取视频图像保存为图片文件(将视频分解为单幅图片)</h3><pre><code class="c">ffmpeg –i input_file –r 1 –f image2 image-%3d.jpeg        //提取图片</code></pre><p>其中 -r 表示提取图像的频率，-f 表示输出格式， %3d 表示文件命名方式（也即生成的图片名为 image-001.jpeg, image-002.jpeg, …., image-999.jpeg）。</p><h3 id="2-9、-转换成YUV原始文件"><a href="#2-9、-转换成YUV原始文件" class="headerlink" title="2.9、 转换成YUV原始文件"></a>2.9、 转换成YUV原始文件</h3><pre><code class="c">ffmpeg -i input_file -vcodec rawvideo -an output_file_yuv</code></pre><h3 id="2-10、YUV序列转出AVI文件"><a href="#2-10、YUV序列转出AVI文件" class="headerlink" title="2.10、YUV序列转出AVI文件"></a>2.10、YUV序列转出AVI文件</h3><pre><code class="c">ffmpeg –s w*h –pix_fmt yuv420p –i input.yuv –vcodec mpeg4 output.avi</code></pre><h3 id="2-11、控制关键帧间隔和B帧"><a href="#2-11、控制关键帧间隔和B帧" class="headerlink" title="2.11、控制关键帧间隔和B帧"></a>2.11、控制关键帧间隔和B帧</h3><pre><code class="c">ffmpeg –i input_file  –vcodec h264 –bf 0 –g 25 –s 854x480 –an –f m4v output_file</code></pre><p>其中-bf 控制B帧数目，-g 控制关键帧间隔， -f 控制文件格式（format，注意与codec的区别）。</p><h3 id="2-12、-多个视频文件拼接"><a href="#2-12、-多个视频文件拼接" class="headerlink" title="2.12、 多个视频文件拼接"></a>2.12、 多个视频文件拼接</h3><p>首先创建一个需要拼接的文件，例如 concat.txt，内容如下：</p><p>file ‘orig_20160616113303_0.avi’<br>file ‘orig_20160616113303_1.avi’</p><p>然后执行如下命令</p><pre><code class="c">ffmpeg  -f concat -i concat.txt  -c copy orig_20160616113303_merge.avi</code></pre><h2 id="3、YUV处理相关命令（持续更新ing）"><a href="#3、YUV处理相关命令（持续更新ing）" class="headerlink" title="3、YUV处理相关命令（持续更新ing）"></a>3、YUV处理相关命令（持续更新ing）</h2><h3 id="3-1、查看ffmpeg支持哪些yuv格式的转换"><a href="#3-1、查看ffmpeg支持哪些yuv格式的转换" class="headerlink" title="3.1、查看ffmpeg支持哪些yuv格式的转换"></a>3.1、查看ffmpeg支持哪些yuv格式的转换</h3><pre><code class="c">ffmpeg -pix_fmts  </code></pre><h3 id="3-2、ffmpeg转换yuv格式命令"><a href="#3-2、ffmpeg转换yuv格式命令" class="headerlink" title="3.2、ffmpeg转换yuv格式命令"></a>3.2、ffmpeg转换yuv格式命令</h3><pre><code class="c">ffmpeg -pix_fmt yuv420p -s 176x144 -i carphone_qcif.yuv -pix_fmt nv12 carphone_qcif_nv12.yuv  </code></pre><h3 id="3-3、ffmpeg命令行yuv缩放命令"><a href="#3-3、ffmpeg命令行yuv缩放命令" class="headerlink" title="3.3、ffmpeg命令行yuv缩放命令"></a>3.3、ffmpeg命令行yuv缩放命令</h3><pre><code class="c">ffmpeg -s:v 1920x1080 -r 25 -i input.yuv -vf scale=960:540 -c:v rawvideo -pix_fmt yuv420p out.yuv  </code></pre><h3 id="3-4、ffmpeg解码码流命令"><a href="#3-4、ffmpeg解码码流命令" class="headerlink" title="3.4、ffmpeg解码码流命令"></a>3.4、ffmpeg解码码流命令</h3><pre><code class="c">ffmpeg -i 720P.264 -s 1280x720 -pix_fmt yuv422p 720P-out.yuv  ffmpeg -i 720P.264 -vframes 300  720P-out.yuv    //指定解码的帧数简化版：ffmpeg -i 720P.264 720P-out.yuv</code></pre><blockquote><p>注意不同选项的顺序，-s选项放在-i后面，指定不同分辨率时，在解码后进行了缩放。</p></blockquote><h3 id="3-5、ffmpeg-yuv转avi"><a href="#3-5、ffmpeg-yuv转avi" class="headerlink" title="3.5、ffmpeg yuv转avi"></a>3.5、ffmpeg yuv转avi</h3><pre><code class="c">ffmpeg -s wxh -pix_fmt yuv420p -i input.yuv -vcodec mpeg4 output.avi  ffmpeg -s wxh -pix_fmt yuv420p -i input.yuv -vcodec h264 output.avi  </code></pre><h3 id="3-6、ffmpeg-裸码流转avi"><a href="#3-6、ffmpeg-裸码流转avi" class="headerlink" title="3.6、ffmpeg 裸码流转avi"></a>3.6、ffmpeg 裸码流转avi</h3><pre><code class="c">ffmpeg -f h264 -i source.264 -c:v libx264 -an dest.aviUse -c:v copy instead to copy the source stream without re-encoding</code></pre><p>参考网址：<a href="https://stackoverflow.com/questions/33108985/ffmpeg-264-to-avi" target="_blank" rel="noopener">https://stackoverflow.com/questions/33108985/ffmpeg-264-to-avi</a></p><h3 id="3-7、ffmpeg-avi转裸码流"><a href="#3-7、ffmpeg-avi转裸码流" class="headerlink" title="3.7、ffmpeg avi转裸码流"></a>3.7、ffmpeg avi转裸码流</h3><h4 id="3-7-1-提取裸码流"><a href="#3-7-1-提取裸码流" class="headerlink" title="3.7.1  提取裸码流"></a>3.7.1  提取裸码流</h4><pre><code class="c">ffmpeg.exe -i BQSquare_416x240_37.avi -f rawvideo -vcodec copy xx.264</code></pre><h4 id="3-7-2-提取若干帧数码流"><a href="#3-7-2-提取若干帧数码流" class="headerlink" title="3.7.2  提取若干帧数码流"></a>3.7.2  提取若干帧数码流</h4><pre><code class="c">ffmpeg.exe -i BQSquare_416x240_37.avi -f rawvideo -vcodec copy -vframes 100 xx.264</code></pre><p>对于提取特定的帧，需要用特殊的方法：假设提取260帧，帧率是26， 则可用-ss 10.0 其中10.0=260/26</p><h3 id="3-8、YUV裁剪功能"><a href="#3-8、YUV裁剪功能" class="headerlink" title="3.8、YUV裁剪功能"></a>3.8、YUV裁剪功能</h3><p>Extract some YUV frames from large yuv File<br>从第0帧开始截取30帧：</p><pre><code class="c">ffmpeg -s widthxheight -i input.yuv -c:v rawvideo -filter:v select=&quot;gt(n\, -1)&quot; -vframes 30 out30.yuv</code></pre><p>或者：</p><pre><code class="c">ffmpeg -s widthxheight -i input.yuv -c:v rawvideo -filter:v select=&quot;between(n\, 0\, 29)&quot; out30.yuv</code></pre><p>或者：</p><pre><code class="c">ffmpeg -r 1 -ss 0 -i input.yuv -vcodec copy -vframes 30 output.yuv</code></pre><p>中间截取帧（截取从第30帧到第100帧）：</p><pre><code class="c">ffmpeg -s widthxheight -i input.yuv -c:v rawvideo -filter:v select=&quot;between(n\, 30\, 100)&quot; out.yuv</code></pre><p>根据时间截取帧（截取从第10秒到第20秒 ）：</p><pre><code class="c">//Select only frames contained in the 10-20 time interval://select=between(t\,10\,20)ffmpeg -s widthxheight -i input.yuv -c:v rawvideo -filter:v select=&quot;between(t\, 10\, 20)&quot; out.yuv</code></pre><p>参考自： <a href="https://blog.csdn.net/listener51/article/details/82025541" target="_blank" rel="noopener">https://blog.csdn.net/listener51/article/details/82025541</a></p><h2 id="4、FFMPEG常用参数说明"><a href="#4、FFMPEG常用参数说明" class="headerlink" title="4、FFMPEG常用参数说明"></a>4、FFMPEG常用参数说明</h2><h3 id="4-1-主要参数："><a href="#4-1-主要参数：" class="headerlink" title="4.1 主要参数："></a>4.1 <strong>主要参数：</strong></h3><pre><code>-i 设定输入流-f 设定输出格式-ss 开始时间-formats  查看所有支持的容器格式-codecs  查看所有编解码器-filters      查看所有可用的filter-pix_fmts 查看所有支持的图片格式-sample_fmts 查看所有支持的像素格式-i input_file 查看媒体文件input_file的信息（注意后面不再接其它参数，例如: ffmpeg -i test.mp4，查看 test.mp4视频信息）</code></pre><h3 id="4-2-视频参数："><a href="#4-2-视频参数：" class="headerlink" title="4.2 视频参数："></a>4.2 <strong>视频参数：</strong></h3><pre><code>-b 设定视频流量，默认为200Kbit/s-r 设定帧速率，默认为25-s 设定画面的宽与高-aspect 设定画面的比例-vn 不处理视频-vcodec 设定视频编解码器，未设定时则使用与输入流相同的编解码器</code></pre><h3 id="4-3-音频参数："><a href="#4-3-音频参数：" class="headerlink" title="4.3 音频参数："></a>4.3 <strong>音频参数：</strong></h3><pre><code>-ar 设定采样率-ac 设定声音的Channel数-acodec 设定声音编解码器，未设定时则使用与输入流相同的编解码器-an 不处理音频</code></pre><h2 id="5、小结"><a href="#5、小结" class="headerlink" title="5、小结"></a>5、小结</h2><p>&ensp; ffmpeg功能强大，参数配置众多，最好的方式查看它的命令行帮助文档，各个参数都有详细的说明，唯一的遗憾就是没有例子，对于初入媒体领域的人来说，门槛比较高。不明白的参数，可以多试试，再接合MediaInfo工具查看具体信息，通过VLC或者FFMPEG自带的 ffplay播放器播放，就容易理解了。</p><h2 id="6、文档参考"><a href="#6、文档参考" class="headerlink" title="6、文档参考"></a>6、文档参考</h2><p>官网翻译文档：<a href="https://www.bookstack.cn/read/other-doc-cn-ffmpeg/ffmpeg-doc-cn-40.md" target="_blank" rel="noopener">https://www.bookstack.cn/read/other-doc-cn-ffmpeg/ffmpeg-doc-cn-40.md</a><br>官方ffmpeg命令行参考文档：<a href="http://ffmpeg.org/ffmpeg.html" target="_blank" rel="noopener">http://ffmpeg.org/ffmpeg.html</a></p><p>更多ffmpeg命令使用可参考：<br><a href="http://processors.wiki.ti.com/index.php/Open_Source_Video_Processing_Tools_-_MPlayer,_FFMpeg,_AviSynth,_MKVToolnix,_MP4Box#Downloads" target="_blank" rel="noopener">http://processors.wiki.ti.com/index.php/Open_Source_Video_Processing_Tools_-_MPlayer,_FFMpeg,_AviSynth,_MKVToolnix,_MP4Box#Downloads</a><br><a href="http://ffmpeg.org/ffmpeg-filters.html#aselect_002c-select" target="_blank" rel="noopener">http://ffmpeg.org/ffmpeg-filters.html#aselect_002c-select</a><br><a href="https://lists.ffmpeg.org/pipermail/ffmpeg-user/2017-February/035335.html" target="_blank" rel="noopener">https://lists.ffmpeg.org/pipermail/ffmpeg-user/2017-February/035335.html</a><br><a href="https://www.bookstack.cn/read/other-doc-cn-ffmpeg/ffmpeg-doc-cn-40.md" target="_blank" rel="noopener">https://www.bookstack.cn/read/other-doc-cn-ffmpeg/ffmpeg-doc-cn-40.md</a><br><a href="https://blog.csdn.net/SoaringLee_fighting/article/details/56015567" target="_blank" rel="noopener">https://blog.csdn.net/SoaringLee_fighting/article/details/56015567</a><br><a href="https://www.suninf.net/2017/02/ffmpeg-command-usage.html" target="_blank" rel="noopener">https://www.suninf.net/2017/02/ffmpeg-command-usage.html</a></p><hr><h2 id="THE-END"><a href="#THE-END" class="headerlink" title="THE END!"></a><font color="red">THE END!</font></h2>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 编解码 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Codecs </tag>
            
            <tag> FFMPEG </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>makefile工程编译模板</title>
      <link href="/2018/09/10/%E3%80%90PE%E7%B3%BB%E5%88%97%E3%80%91makefile%E5%B7%A5%E7%A8%8B%E7%BC%96%E8%AF%91%E6%A8%A1%E6%9D%BF/"/>
      <url>/2018/09/10/%E3%80%90PE%E7%B3%BB%E5%88%97%E3%80%91makefile%E5%B7%A5%E7%A8%8B%E7%BC%96%E8%AF%91%E6%A8%A1%E6%9D%BF/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="1、前言"><a href="#1、前言" class="headerlink" title="1、前言"></a>1、前言</h2><p>&ensp;&ensp;&ensp;&ensp;最近在调试一个解码器工程时，编写了一个简单的makefile，通过makefile实现工程demo的编译，涉及到makefile使用的相关知识，分享出来供大家学习。<br>&ensp;&ensp;&ensp;&ensp;makefile旨在构建目标文件，实现工程的自动化编译。</p><h2 id="2、makefile使用相关知识"><a href="#2、makefile使用相关知识" class="headerlink" title="2、makefile使用相关知识"></a>2、makefile使用相关知识</h2><h3 id="2-1-ensp-规则语法："><a href="#2-1-ensp-规则语法：" class="headerlink" title="2.1&ensp;规则语法："></a>2.1&ensp;规则语法：</h3><pre><code>target ... : prerequisites ...    command    ...</code></pre><h3 id="2-2-ensp-VPATH的使用"><a href="#2-2-ensp-VPATH的使用" class="headerlink" title="2.2&ensp;VPATH的使用"></a>2.2&ensp;VPATH的使用</h3><ol><li><p>示例1 - 当前目录中找不到文件时, 按顺序从 src目录, ../parent-dir目录中查找文件<br>VPATH src:../parent-dir   </p></li><li><p>示例2 - .h结尾的文件都从 ./header 目录中查找<br>VPATH %.h ./header</p></li></ol><h3 id="2-3-ensp-变量的定义"><a href="#2-3-ensp-变量的定义" class="headerlink" title="2.3&ensp;变量的定义"></a>2.3&ensp;变量的定义</h3><ol><li>=  延迟赋值 ，将整个makefile中的所有变量的值都计算完之后，确定该变量的值。<ol start="2"><li>:=  立即赋值，:=只能使用前面定义好的变量。</li><li>+= 追加赋值</li><li>?= 条件赋值  </li></ol></li></ol><h3 id="2-4-ensp-自动变量"><a href="#2-4-ensp-自动变量" class="headerlink" title="2.4&ensp;自动变量"></a>2.4&ensp;自动变量</h3><ol><li>$@  所有目标的集合</li><li>$^    所有依赖目标的集合, 会去除重复的依赖目标</li><li>$+    所有依赖目标的集合, 不会去除重复的依赖目标</li><li>$?   比目标新的依赖目标的集合</li></ol><h3 id="2-5-ensp-伪目标"><a href="#2-5-ensp-伪目标" class="headerlink" title="2.5&ensp;伪目标"></a>2.5&ensp;伪目标</h3><p>并不是一个”目标(target)”, 不像真正的目标那样会生成一个目标文件.</p><p>典型的伪目标是 Makefile 中用来清理编译过程中中间文件的 clean 伪目标, 一般格式如下:</p><pre><code class="shell">.PHONY: clean   &lt;-- 这句没有也行, 但是最好加上clean:    -rm -f *.o</code></pre><h3 id="2-6-ensp-变量替换和变量引用"><a href="#2-6-ensp-变量替换和变量引用" class="headerlink" title="2.6&ensp;变量替换和变量引用"></a>2.6&ensp;变量替换和变量引用</h3><pre><code class="shell">#变量替换SRCS := programA.c programB.c programC.cOBJS := $(SRCS:%.c=%.o)#变量引用$(SRCS)echo $(SRCS)</code></pre><h3 id="2-7-ensp-C相关命令和参数定义"><a href="#2-7-ensp-C相关命令和参数定义" class="headerlink" title="2.7&ensp;C相关命令和参数定义"></a>2.7&ensp;C相关命令和参数定义</h3><table><thead><tr><th>命令</th><th>含义</th><th>示例</th></tr></thead><tbody><tr><td>RM</td><td>rm -f</td><td>RM=rm -f</td></tr><tr><td>AR</td><td>ar</td><td>AR=ar</td></tr><tr><td>CC</td><td>gcc</td><td>CC=gcc</td></tr><tr><td>CXX</td><td>g++</td><td>CXX=g++</td></tr><tr><td>ARFLAGS</td><td>AR命令的参数</td><td>-crus</td></tr><tr><td>CFLAGS</td><td>C语言编译器的参数</td><td>CFLGAS+=-Wall -O3  -fPIC -fsigned-char</td></tr><tr><td>CXXFLAGS</td><td>C++语言编译器的参数</td><td>同上</td></tr><tr><td>LDFLAGS</td><td>ld链接器的参数</td><td>同上</td></tr></tbody></table><h2 id="3、makefile工程编译模板"><a href="#3、makefile工程编译模板" class="headerlink" title="3、makefile工程编译模板"></a>3、makefile工程编译模板</h2><pre><code class="shell">#指定后缀名和伪目标.SUFFIXES: .c,.o,.cpp,.S,.s  .PHONY: all,clean#设置相关工具CC = gccCXX = g++AR = arLD = ld#设置相关路径VPATH %.h ./incROOTSRC = ./srcINCLUDES = ./inc#设置工具的相关参数BIN_TARGET = DEMOCFLAGS += -Wall -O3  -g  -I$(INCLUDES)CXXFLAGS += -Wall -gLDFLAGS += -Wall -O3 -gARFLAGS += -crus#以下获取OBJS文件的方式适用于含有少量文件的编译SRCS = $(ROOTSRC)/file1.c            \       $(ROOTSRC)/file2.cpp         \       $(ROOTSRC)/file3.s           \       $(ROOTSRC)/file4.S                OBJS = $(patsubst %.s, %.o, $(patsubst %.cpp,%.o, $(patsubst %.c,%.o,$(SRCS))))#以下通过通配符和字符串函数获取OBJS的方式适用于较大工程（含有大量文件）的编译SRCOBJS := $(patsubst %.cpp, %.o, $(wildcard $(SRCDIR)/*.cpp))TESTOBJS := $(patsubst %.cpp, %.o, $(wildcard $(TESTDIR)/*.cpp))OBJS := $(SRCOBJS) $(TESTOBJS)#编译规则all: clean $(BIN_TARGET)BIN_TARGET:    $(OBJS)    $(CXX) -o $@ $(OBJS) $(LDFLAGS)    rm $(OBJS)%.o: %.c    $(CC) -c $&lt; $(CFLAGS) -o $@%.o: %.cpp    $(CXX) -c $&lt; $(CXXFLAGS) -o $@clean:    rm    $(OBJS)    rm  $(BIN_TARGET)</code></pre><blockquote><p>关于第二种获取OBJS方式的说明：<br>    &ensp;&ensp;  这是通过make的两个内置函数wildcard和patsubst实现的。wildcard返回所有符合给定模式的匹配。在上面的例子中，我们要匹配所有处于$(SRCDIR)和$(TESTDIR)目录下的.cpp文件，并将其路径作为变量传入另一个函数patsubst，它会将每个路径中的.cpp替换成.o，最后存入我们指定的变量中。</p></blockquote><p>关于写一个通用makefile的相关知识更多可以参考：</p><ol><li><a href="https://bitmingw.com/2015/03/21/general-makefile/" target="_blank" rel="noopener">https://bitmingw.com/2015/03/21/general-makefile/</a></li><li><a href="https://www.cnblogs.com/vamei/archive/2013/04/29/3051062.html" target="_blank" rel="noopener">https://www.cnblogs.com/vamei/archive/2013/04/29/3051062.html</a></li></ol><h2 id="4、更加完善的makefile编译模板"><a href="#4、更加完善的makefile编译模板" class="headerlink" title="4、更加完善的makefile编译模板"></a>4、更加完善的makefile编译模板</h2><p>（1）系统或架构相关宏、FLAGS配置在config.mk中：</p><pre><code class="shell">#检测系统OS = $(shell uname)#设置是否调试ifeq ($(DEBUG), 0)    DEBUG_FLAGS := -O3else    DEBUG_FLAGS := -Gendif#####################################################linux系统 ###################ifeq ($(findstring Linux, $(OS)), Linux)    CROSS ?=    CC    := $(CROSS)gcc -fPIC -DPIC    CPP    := $(CROSS)g++ -fPIC -DPIC    LD    := $(CROSS)ld    AR    := $(CROSS)ar    ASM    :=    yasm -DPIC###ARM32架构ifeq ($(platform), arm32)    ARCH_DEF    :=    EXTRA_CFLAGS := -march=armv7-a -marm $(ARCH_DEF)    EXTRA_LFLAGS := -march=armv7-a -marm    EXTRA_AFLAGS := -march=armv7-a $(ARCH_DEF)    OUT_DIR        := ./bin/arm32endif###ARM64架构ifeq ($(platform), arm64)    ARCH_DEF    :=    EXTRA_CFLAGS := -march=armv8-a $(ARCH_DEF)    EXTRA_LFLAGS := -march=armv8-a      EXTRA_AFLAGS := -march=armv8-a $(ARCH_DEF)    OUT_DIR        := ./bin/arm64endif###X86_32架构ifeq ($(platform), x86_32)    ARCH_DEF    :=    EXTRA_CFLAGS := -m32 $(ARCH_DEF)    EXTRA_LFLAGS := -m32 -shared    EXTRA_AFLAGS := -m x86 $(ARCH_DEF)    OUT_DIR        := ./bin/x86m32endif###X86_64架构ifeq ($(platform), x86_64)    ARCH_DEF    :=    EXTRA_CFLAGS := -m64 $(ARCH_DEF)    EXTRA_LFLAGS := -m64 -shared -Wl, -Bsymbolic    EXTRA_AFLAGS := -m amd64 $(ARCH_DEF)    OUT_DIR        := ./bin/x86m64endifendif#####################################################MAC/IOS系统 ###################ifeq ($(findstring Darwin, $(OS)), Darwin)###MAC平台ifeq ($(target_plat), mac)    CROSS ?=    CC    := $(CROSS)gcc -fPIC -DPIC    CPP    := $(CROSS)g++ -fPIC -DPIC    AR    := $(CROSS)ar    ASM    :=    yasm -DPIC##X86_32架构ifeq ($(platform), x86_32)    ARCH_DEF :=    EXTRA_CFLAGS    := -m32    EXTRA_LFLAGS    := -m32 -dynamiclib -Wl, -dynamic -Wl, -read_only_relocs, suppress    EXTRA_AFLAGS    := -f macho32 -m x86    OUT_DIR            := ./bin/mac32endif##X86_64架构ifeq ($(platform), x86_64)    ARCH_DEF :=    EXTRA_CFLAGS    := -m64    EXTRA_LFLAGS    := -m64 -dynamiclib -Wl, -dynamic    EXTRA_AFLAGS    := -f macho64 -m amd64    OUT_DIR            := ./bin/mac64endifendif###IOS平台ifeq ($(target_plat), ios)    CROSS := iphoneifeq ($(platform), ios32)    CC    := xcrun -sdk $(CROSS)os clang    CPP    := g++    AR    := ar    ASM    := gas-preprocessor.pl -arch arm -as-type apple-clang --$(CC)    ARCH_DEF    :=    EXTRA_CFLAGS := -arch armv7 -mios-version-min=6.0    EXTRA_LFLAGS := -arch armv7 -mios-version-min=6.0    EXTRA_AFLAGS := -arch armv7 -mios-version-min=6.0    OUT_DIR        := ./bin/ios32endififeq ($(platform), ios64)    CC    := xcrun -sdk $(CROSS)os clang    CPP := g++    AR    := ar    ASM    := gas-preprocessor.pl -arch aarch64 -as-type apple-clang --$(CC)    ARCH_DEF    :=    EXTRA_CFLAGS := -arch arm64 -mios-version-min=6.0    EXTRA_LFLAGS := -arch arm64 -mios-version-min=6.0    EXTRA_AFLAGS := -arch arm64 -mios-version-min=6.0    OUT_DIR        := ./bin/ios64endififeq ($(platform), ios_sim32)    CC    := xcrun -sdk $(CROSS)simulators clang    CPP    := g++    AR    := ar    ASM    := yasm    ARCH_DEF    :=    EXTRA_CFLAGS := -arch i386 -mios-simulator-version-min=6.0    EXTRA_LFLAGS := -arch i386 -mios-simulator-version-min=6.0 -Wl, -Bsymbolic-functions -read_only_relocs suppress    EXTRA_AFLAGS := -f macho32 -m x86    OUT_DIR        := ./bin/ios_simendififeq ($(platform), ios_sim64)    CC    := xcrun -sdk $(CROSS)simulators clang    CPP    := g++    AR    := ar    ASM    := yasm    ARCH_DEF    :=    EXTRA_CFLAGS := -arch x86_64 -mios-simulator-version-min=6.0    EXTRA_LFLAGS := -arch x86_64 -mios-simulator-version-min=6.0    EXTRA_AFLAGS := -f macho64 -m amd64    OUT_DIR        := ./bin/ios_simendifendif ##ifeq ($(target_plat), ios)endif</code></pre><p>（2）构建法则在Makefile中</p><pre><code class="shell">include config.mkSRC_PATH    := ../srcINCLUDE_PATH:= ../includeLIB_PATH    := $(OUT_DIR)LIB_NAME    := xxxARFLAGS        := cruCFLAGS        := $(DEBUG_FLAGS)CFLAGS        +=$(EXTRA_CFLAGS) -I$(INCLUDE_PATH)ASMFLAGS    :=ASMFLAGS    += $(EXTRA_AFLAGS) -I$(INCLUDE_PATH)LDFALGS        := -lm -ldlLDFALGS        += $(EXTRA_LFLAGS)LIB         := $(LIB_PATH)/$(LIB_NAME).a $(LIB_PATH)/$(LIB_NAME).soOBJS        := $(SRC_PATH)/x.o        \               $(SRC_PATH)/y.oall: clean $(LIB)$(filter %.a, $(LIB)):$(OBJS)    $(AR) $(ARFLAGS) $@ $^$(filter %.so, $(LIB)):$(OBJS)    $(CC) $(LDFALGS) -shared -o $@ $^%.o:%.c    $(CC) -o $&lt; $(CFLAGS) -c -o $@%.o:%.asm    $(ASM) $&lt; $(ASMFLAGS) -c -o $@clean:    rm -rf $(OBJS)    rm -rf $(LIB)</code></pre><h2 id="5、参考"><a href="#5、参考" class="headerlink" title="5、参考"></a>5、参考</h2><p><a href="https://www.cnblogs.com/wang_yb/p/3990952.html" target="_blank" rel="noopener">https://www.cnblogs.com/wang_yb/p/3990952.html</a><br><a href="https://www.cnblogs.com/yyangblog/p/4159778.html" target="_blank" rel="noopener">https://www.cnblogs.com/yyangblog/p/4159778.html</a><br><a href="https://bitmingw.com/2015/03/21/general-makefile/" target="_blank" rel="noopener">https://bitmingw.com/2015/03/21/general-makefile/</a><br><a href="https://github.com/switchbrew/34c3-demo/blob/master/Makefile" target="_blank" rel="noopener">https://github.com/switchbrew/34c3-demo/blob/master/Makefile</a><br><a href="https://blog.csdn.net/listener51/article/details/84930829" target="_blank" rel="noopener">https://blog.csdn.net/listener51/article/details/84930829</a></p><hr><h2 id="THE-END"><a href="#THE-END" class="headerlink" title="THE END!"></a><font color="red">THE END!</font></h2>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 工程化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> makefile </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>编解码器一致性验证和性能测试自动化脚本</title>
      <link href="/2018/09/07/%E3%80%90Codecs%E7%B3%BB%E5%88%97%E3%80%91%E7%BC%96%E8%A7%A3%E7%A0%81%E5%99%A8%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%E8%87%AA%E5%8A%A8%E5%8C%96%E8%84%9A%E6%9C%AC/"/>
      <url>/2018/09/07/%E3%80%90Codecs%E7%B3%BB%E5%88%97%E3%80%91%E7%BC%96%E8%A7%A3%E7%A0%81%E5%99%A8%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%E8%87%AA%E5%8A%A8%E5%8C%96%E8%84%9A%E6%9C%AC/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="1、自动化测试脚本说明"><a href="#1、自动化测试脚本说明" class="headerlink" title="1、自动化测试脚本说明"></a>1、自动化测试脚本说明</h2><p>说明：编解码器在开发过程中，通常需要和标准或参考编解码进行对比以验证编解码一致性，以及测试测试编解码的性能。该脚本可用于在Linux平台、arm平台上对编解码器单独编解码或者用于一致性验证和性能测试。</p><h2 id="2、自动化测试脚本实现"><a href="#2、自动化测试脚本实现" class="headerlink" title="2、自动化测试脚本实现"></a>2、自动化测试脚本实现</h2><pre><code class="shell">#! /bin/sh#Functionality： codecs coherence test and performance test#Filename:  auto_codec_arm_test.sh#Creator:     SoaringLee#Modify: 1、支持待验证可执行文件单独解码码流；#         2、支持测试性能时，解码不写yuv，默认是解码写yuv的；#         3、增加在脚本执行中断后从制定序号位置处继续执行的功能；##===================main========================##定义全局变量MaxChar=100AnchorNdec=0Refdec=0Refdemo=&quot;0&quot;YUVflag=&quot;1&quot; #默认写yuvYUVCompare=&quot;./diffyuv&quot; ##YUV比较可执行文件CoreNum=&quot;&quot; ##指定当前可执行文件运行的CPU核心##输入参数个数检查if [ $# -lt 3 ];then    echo &quot;Usage: $0 &lt;AnchorDemo StreamDir outFileDir&gt; [YUVflag RefDemo start_idx CodeNum]&quot;    echo &quot;Notice: This shell script need at lease 3 parameters,&lt;xxx&gt; is necessary, [xxx] is optinal&quot;    exit 1##读取命令行参数，增加可读性AnchorDemo=&quot;$1&quot;StreamsDir=&quot;$2&quot;outFileDir=&quot;$3&quot;##判断输出目录是否存在if [ -d ${outFileDir} ];then    echo &quot;${outFileDir} doesn&#39;t exist, Now create it!&quot;    mkdir &quot;${outFileDir}&quot;else    echo &quot;${outFileDir} already exist!&quot;fiif [ $# -ge 4 ];then    YUVflag=&quot;$4&quot;fiif [ $# -ge 5 ];then    RefDemo=&quot;$5&quot;fiif [ $# -ge 6 ];then    StartIdx=&quot;$6&quot;fiif [ $# -ge 7 ];then    CoreNum=&quot;$7&quot;##统计输出txtpMatchtxt=${outFileDir}/&quot;__pMatch.txt&quot;       #一致性对比的一致输出txtpNotMatchtxt=${outFileDir}/&quot;__pNotMatch.txt&quot; #一致性对比的不一致输出txtpPerformancetxt=${outFileDir}/&quot;__pCollect.txt&quot;#性能对比输出txtpAnchor_Ndectxt=${outFileDir}/&quot;__Anchor_notdecstream.txt&quot;#待验证可执行文件不能解码的码流pRef_Ndectxt=${outFileDir}/&quot;__Ref_notdecstream.txt&quot;#参考可执行文件不能解码的码流##titletitle=&quot;filename&quot;spacenum_title=$((${MaxChar}-${#title}))spacezero=$(seq -s &#39;-&#39; ${spacenum_title} | sed &#39;s/[0-9]//g&#39;)totaltitle=&quot;filename ${spacezero}    total frames  | fps&quot;echo $totaltitle &gt; $pPerformancetxtprocessIdx=-1##[1]. Recursively get svac stream filesallfile=$(find  ${StreamDir} -name &quot;*.svac&quot;)for file in `ls ${allfiles}`do    ## 去除含有QP和ai的码流    result=`echo $file | grep -e &quot;QP&quot; -e &quot;ai&quot;`    if  [ -n &quot;${result}&quot; ]; then        continue    fi    processIdx=$((${processIdx}+1))    if [ $# -ge 6 ]; then      if [ ${processIdx}  -le  ${StartIdx} ]; then        continue      fi    fi    echo &quot;******processIdx*******:&quot; ${processIdx}    echo &quot;******Current test*******:&quot; $file    ##提取出文件名    filename=${file##*/} #从字符首部开始，删除最长匹配*/的子串    filename=${filename%.*} 从字符串尾部开始，删除最短匹配.*的子串##格式控制spacenum=$((${MaxChar}-${#filename}))spaceone=$(seq -s &#39;-&#39; ${spacenum} | sed &#39;s/[0-9]//g&#39;)spacetwo=$(seq -s &#39;-&#39; ${spacenum} | sed &#39;s/[0-9]//g&#39;)spacethr=$(seq -s &#39;-&#39; ${#filename} | sed &#39;s/[0-9]//g&#39;)##解码yuv和解码输出txtoutyuvAnchor=${outFileDir}/${filename}&quot;_Anchor.yuv&quot;outyuvRef=${outFileDir}/${filename}&quot;_Ref.yuv&quot;outtxtAnchor=${outFileDir}/${filename}&quot;_Anchor.txt&quot;outtxtRef=${outFileDir}/${filename}&quot;_Ref.yuv&quot;RawCmd=${AnchorDemo}&quot; -i &quot;${file}RefCmd=${RawDemo}&quot; -i &quot;${file}##[2].Decoding svac streams using anchor and red decoderif [ &quot;${YUVflag}&quot;==&quot;1&quot; ];then    RefCmd=${RefCmd}&quot; -o &quot;${outyuvRef}    RawCmd=${RawCmd}&quot; -o &quot;${outyuvAnchor}fiif [ -n &quot;${CoreNum}&quot; ]; then    RefCmd=${RefCmd}&quot; -c ${CoreNum}&quot;    RawCmd=${RawCmd}&quot; -c ${CoreNum}&quot;fiRefCmd=${RefCmd}&quot; &gt; &quot;${outtxtRef}RawCmd=${RawCmd}&quot; &gt; &quot;${outtxtAnchor}##原始可执行文件解码echo ${RawCmd}eval ${RawCmd}if [ #? -ne 0 ];then    echo &quot;========Anchor Dec Failure!=========&quot;    echo &quot;${AnchorDemo} cannot dec: $file, ret:$?&quot; &gt;&gt; ${pAnchor_Ndectxt}    AnchorNdec=1else    echo &quot;********Anchor Dec Success!*********&quot;fi## 参考可执行文件解码if [ x&quot;RefDemo&quot; != x&quot;0&quot; ];then    echo ${RefCmd}    eval ${RefCmd}    if [ #? -ne 0 ];then        echo &quot;========Ref Dec Failure!=========&quot;        echo &quot;${RefDemo} cannot dec: $file, ret:$?&quot; &gt;&gt; ${pRef_Ndectxt}        RefNdec=1    else        echo &quot;********Ref Dec Success!*********&quot;    fielse    RefNdec=1fi##[3]. ref and anchor filecmp for coherence testif [[ ${AnchorNdec} -ne 1 &amp;&amp; ${RefNdec} -ne 1 &amp;&amp; ${YUVflag} -eq 1]];then ##两者都解码成功才进行yuv比较    cmpCmd=${YUVCompare}&quot; &quot;${outyuvAnchor}&quot; &quot;${outyuvRef}    eval ${cmpCmd}    if [ $? -eq 0 ];then        echo &quot;**********YUV MATCH!***********&quot;        echo &quot;[$filename]${spacesone}MATCH!&quot; &gt;&gt;${pMatchtxt}        rm -f ${outyuvAnchor}        rm -f ${outyuvRef}    else        echo &quot;=========YUV DISMATCH!=========&quot;        echo &quot;[$filename]${spacesone}DISMATCH!&gt;&gt;${pNotMatchtxt}&quot;    fifi##[4]. Performance collectif [ ${AnchorNdec} -ne 1 ];then    result=`cat $outtxtAnchor | grep -e loop` #查找文件中含有loop字符串的行    framenum=${result%%frames*} ##delete right side    framenum=${framenum##*,} ##delete left side    fps=${result%%fps*}    fps=${fps##*,}    echo &quot;$filename(Anchor) ${spacestwo} $framenum  $fps&quot; &gt;&gt; ${pPerformancetxt}    rm -f ${outtxtAnchor}fiif [ ${RefNdec} -ne 1 ];then    result=`cat $outtxtRef | grep -e loop` #查找文件中含有loop字符串的行    framenum=${result%%frames*} ##delete right side    framenum=${framenum##*,} ##delete left side    fps=${result%%fps*}    fps=${fps##*,}    echo &quot;${spacesthr}   (Ref) ${spacestwo} $framenum  $fps&quot; &gt;&gt; ${pPerformancetxt}    rm -f ${outtxtRef}fiAnchorNdec=0  ##恢复原始不解码标记RefNdec=0  ##恢复参考不解码标记doneecho &quot;This shell script run successfully!&quot;exit 0</code></pre><h2 id="3、关于该脚本中的diffyuv"><a href="#3、关于该脚本中的diffyuv" class="headerlink" title="3、关于该脚本中的diffyuv"></a>3、关于该脚本中的diffyuv</h2><h3 id="3-1-方法一"><a href="#3-1-方法一" class="headerlink" title="3.1 方法一"></a>3.1 方法一</h3><p><a href="https://blog.csdn.net/SoaringLee_fighting/article/details/80867857" target="_blank" rel="noopener">https://blog.csdn.net/SoaringLee_fighting/article/details/80867857</a></p><h3 id="3-2-方法二"><a href="#3-2-方法二" class="headerlink" title="3.2 方法二"></a>3.2 方法二</h3><p>YUV比较的C实现可以参考：</p><pre><code class="c">#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;int compareFile(FILE* file_compared, FILE* file_checked);int main(int argc, char **argv){    int ret;    FILE *file1=fopen(argv[1],&quot;rb&quot;);    FILE *file2=fopen(argv[2],&quot;rb&quot;);    if(NULL==file1 || NULL==file2)        printf(&quot;file1 or file2 open error!\n&quot;);    ret = compareFile(file1,file2);    if(ret)        printf(&quot;Different!\n&quot;);    else        printf(&quot;Same!\n&quot;);    return ret;}int compareFile(FILE* file_compared, FILE* file_checked){    int diff=0;    int N=30;    char* b1 = (char*) calloc(1,N+1);    char* b2 = (char*) calloc(1,N+1);    size_t s1,s2;    do{        s1 = fread(b1,1,N,file_compared);        s2 = fread(b2,1,N,file_checked);        if(s1 != s2 || memcmp(b1,b2,s1))        {            diff = 1;            break;        }    }while(!feof(file_compared)||!feof(file_checked));    free(b1);    free(b2);    if(diff)   return 1;    else       return 0;}</code></pre><hr><h2 id="THE-END"><a href="#THE-END" class="headerlink" title="THE END!"></a><font color="red"><strong>THE END!</strong></font></h2>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
          <category> 自动化脚本 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> shell </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Performance Profile Tools——perf and gprof</title>
      <link href="/2018/09/04/%E3%80%90Tools%E7%B3%BB%E5%88%97%E3%80%91Performance%20Profile%20Tools%E2%80%94%E2%80%94perf%20and%20gprof/"/>
      <url>/2018/09/04/%E3%80%90Tools%E7%B3%BB%E5%88%97%E3%80%91Performance%20Profile%20Tools%E2%80%94%E2%80%94perf%20and%20gprof/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="1、参考"><a href="#1、参考" class="headerlink" title="1、参考"></a>1、参考</h2><p><a href="https://www.ibm.com/developerworks/cn/linux/l-cn-perf1/" target="_blank" rel="noopener">https://www.ibm.com/developerworks/cn/linux/l-cn-perf1/</a><br><a href="https://www.cnblogs.com/arnoldlu/p/6241297.html" target="_blank" rel="noopener">https://www.cnblogs.com/arnoldlu/p/6241297.html</a><br><a href="https://sourceware.org/binutils/docs/gprof/" target="_blank" rel="noopener">https://sourceware.org/binutils/docs/gprof/</a><br><a href="https://baike.baidu.com/item/gprof/8995496" target="_blank" rel="noopener">https://baike.baidu.com/item/gprof/8995496</a></p><p><a href="https://blog.csdn.net/viphong/article/details/70176604" target="_blank" rel="noopener">https://blog.csdn.net/viphong/article/details/70176604</a><br><a href="https://www.cnblogs.com/andashu/p/6378000.html" target="_blank" rel="noopener">https://www.cnblogs.com/andashu/p/6378000.html</a><br><a href="https://blog.csdn.net/zsl_oo7/article/details/71310444?utm_source=itdadao&amp;utm_medium=referral" target="_blank" rel="noopener">https://blog.csdn.net/zsl_oo7/article/details/71310444?utm_source=itdadao&amp;utm_medium=referral</a></p><h2 id="2、perf-tool"><a href="#2、perf-tool" class="headerlink" title="2、perf tool"></a>2、perf tool</h2><p>perf ：Linux下系统性能调优工具.<br>系统级的性能优化，包括性能剖析和代码优化，性能剖析的关键在于找到程序耗时和瓶颈所在，这时就可以利用perf这把瑞士军刀了。<br>perf的功能是很强大的，<br>具体使用方法可以参考：<a href="https://www.ibm.com/developerworks/cn/linux/l-cn-perf1/" target="_blank" rel="noopener">https://www.ibm.com/developerworks/cn/linux/l-cn-perf1/</a></p><h2 id="3、gprof-tool"><a href="#3、gprof-tool" class="headerlink" title="3、gprof tool"></a>3、gprof tool</h2><h3 id="3-1、gprof简介"><a href="#3-1、gprof简介" class="headerlink" title="3.1、gprof简介"></a>3.1、gprof简介</h3><p>gprof： GNU提供的性能调试工具。可以打印出程序运行中各个函数消耗的时间。对于分析程序性能瓶颈很好帮助。<br>gprof是GNU profile工具，可以运行于linux、AIX、Sun等操作系统进行C、C++、Pascal、Fortran程序的性能分析，用于程序的性能优化以及程序瓶颈问题的查找和解决。通过分析应用程序运行时产生的“flat profile”，可以得到每个函数的调用次数，每个函数消耗的处理器时间，也可以得到函数的“调用关系图”，包括函数调用的层次关系，每个函数调用花费了多少时间。</p><h3 id="3-2、gprof具有以下优缺点"><a href="#3-2、gprof具有以下优缺点" class="headerlink" title="3.2、gprof具有以下优缺点"></a>3.2、gprof具有以下优缺点</h3><p>1） 优点：</p><ul><li>GNU工具，人手一个；</li><li>混合方法采集信息。</li></ul><p>2） 缺点：</p><ul><li>需要编译选项支持：<ul><li>使用gcc/cc编译和链接时需要加入-pg选项</li><li>使用ld链接时需要用/lib/gcrt0.o代替crt0.o作为第一个input文件</li><li>如果要调试libc库需要使用-lc_p代替-lc参数</li></ul></li><li>调试多线程程序只能统计主线程的信息（所以不能用于kingbase）。</li></ul><h3 id="3-3、gprof分析方法："><a href="#3-3、gprof分析方法：" class="headerlink" title="3.3、gprof分析方法："></a>3.3、gprof分析方法：</h3><p>1、编译、链接时均加上-pg，生成demo；<br>2、执行生成gmon.out文件；<br>3、gprof分析前一步生成的gmon.out文件，查看生成 txt文件中各个函数所占比例；</p><pre><code> $gprof  ./demo  gmon.out  &gt; profile.txt</code></pre><p>注： gprof只能在linxu64位下对可执行文件进行分析。</p><h3 id="3-4、实例分析"><a href="#3-4、实例分析" class="headerlink" title="3.4、实例分析"></a>3.4、实例分析</h3><p>为了进一步说明gprof的使用方法，<br>（1）对mpeg4开源编解码库xvid解码器中的各函数进行性能分析：<br>测试程序：解码器程序xvid_decraw<br>xvid的编译可以参见：<a href="https://blog.csdn.net/SoaringLee_fighting/article/details/68942330" target="_blank" rel="noopener">https://blog.csdn.net/SoaringLee_fighting/article/details/68942330</a><br>在编译生成解码器xvid_decraw时需要修改对应makefile，在编译和链接时都加上-pg参数。</p><pre><code>make./xvid_decraw -i input.m4vgprof  ./xvid_decraw gmon.out &gt;profile.txt</code></pre><p>生成分析结果profile.txt：<br><img src="/img/20180905221928550.jpg" alt="生成分析结果"></p><p><strong><em>性能分析结论：</em></strong><br>从分析结果可知，transfer8x8_copy_c函数占比42%，decode_pframe函数占比28%，get_inter_block_h263函数占比114%，get_pmv2函数占比14%，这几个函数的占比较大，通过优化这几个函数可以显著提升性能。由此看出插值，反dct等模块的复杂度是很高的。</p><p>（2）对H264标准开源编码器x264中的各个函数进行性能分析：<br>测试程序： x264<br>x264的编译可以参考：<a href="https://blog.csdn.net/SoaringLee_fighting/article/details/78882801" target="_blank" rel="noopener">https://blog.csdn.net/SoaringLee_fighting/article/details/78882801</a></p><pre><code>./configure对configure之后生成的config.mak中的CFLAGS和LDFLAGS增加-pg选项，另外需要去掉-fomit-frame-pointer选项make./x264 -o out.264 input.yuvgprof  ./x264 gmon.out &gt;profile.txt</code></pre><p>生成分析结果profile.txt：<br><img src="/img/20180905224500971.jpg" alt="生成分析结果profile"></p><p><strong><em>性能分析结论：</em></strong><br>主要耗时的函数有：</p><pre><code>get_refx264_pixel_satd_8x4x264_pixel_satd_x4_16x16x264_pixel_satd_x4_8x8mc_chroma</code></pre><p>说明对于编码器，运动估计的复杂度是很高的。</p><p><strong>gprof 产生的信息解释：</strong></p><p>| time | Cumulatve seconds| Self Seconds|Calls|Self TS/call|Total TS/call|name|<br>|—|—|—|—|—|—|—|—|<br>|该函数消耗时间占程序总时间百分比|程序的累积执行时间|该函数本身执行时间|函数被调用次数|函数平均执行次数|函数平均执行时间|函数名</p><hr><h2 id="THE-END"><a href="#THE-END" class="headerlink" title="THE END! "></a><font color="red"><strong>THE END!</strong> </font></h2>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
          <category> 调试工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> gprof </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GDB调试方法</title>
      <link href="/2018/08/31/%E3%80%90Tools%E7%B3%BB%E5%88%97%E3%80%91GDB%E8%B0%83%E8%AF%95%E6%96%B9%E6%B3%95/"/>
      <url>/2018/08/31/%E3%80%90Tools%E7%B3%BB%E5%88%97%E3%80%91GDB%E8%B0%83%E8%AF%95%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="1、参考"><a href="#1、参考" class="headerlink" title="1、参考"></a>1、参考</h2><p><a href="https://blog.csdn.net/listener51/article/details/81950131" target="_blank" rel="noopener">https://blog.csdn.net/listener51/article/details/81950131</a><br><a href="https://www.cnblogs.com/qigaohua/p/6077790.html" target="_blank" rel="noopener">https://www.cnblogs.com/qigaohua/p/6077790.html</a><br><a href="https://blog.csdn.net/yangzhongxuan/article/details/6901477" target="_blank" rel="noopener">https://blog.csdn.net/yangzhongxuan/article/details/6901477</a><br><a href="https://blog.csdn.net/linuxheik/article/details/17380767" target="_blank" rel="noopener">https://blog.csdn.net/linuxheik/article/details/17380767</a><br><a href="http://blog.chinaunix.net/uid-20593827-id-1918499.html" target="_blank" rel="noopener">http://blog.chinaunix.net/uid-20593827-id-1918499.html</a></p><h2 id="2、GDB调试基本命令"><a href="#2、GDB调试基本命令" class="headerlink" title="2、GDB调试基本命令"></a>2、GDB调试基本命令</h2><pre><code>(gdb) start    ： 运行程序(gdb) continue ： 从断点位置继续运行(gdb) r(un)    ： 运行准备调试的程序，在它后面可以跟随发给该程序的任何参数，包括标准输入和标准输出说明符(&lt;和&gt;)和shell通配符（*、？、[、]）在内。(gdb) n(ext)   ： 单步运行,逐过程调试，C Style(gdb) s(tep)   ： 单步运行,逐语句调试，C Style(gdb) n(ext)i  ： 单步运行,逐过程调试, asm Style(gdb) s(tep)i  ： 单步运行,逐语句调试, asm Stylefinish           ： 如果已经进入了某函数，而想退出该函数返回到它的调用函数中，可使用命令finishuntil           ： 结束当前循环whatis           ： 显示变量或函数类型quit           ： 退出gdb</code></pre><h2 id="3、布局和显示数据"><a href="#3、布局和显示数据" class="headerlink" title="3、布局和显示数据"></a>3、布局和显示数据</h2><pre><code>display /i $pc    ：命令可以在调试时显示每条汇编命令。info win        ：显示窗口的大小layout next        ：切换到下一个布局模式layout prev        ：切换到上一个布局模式layout src        ：只显示源代码，退出方法为Ctrl+X+Alayout asm        ：只显示汇编代码layout split    ：显示源代码和汇编代码layout regs        ：增加寄存器内容显示focus cmd/src/asm/regs/next/prev    ：切换当前窗口refresh    /Ctrl+L    ：刷新所有窗口tui reg next    ：显示下一组寄存器tui reg system    ：显示系统寄存器update            ：更新源代码窗口和当前执行点print bb        ：打印变量print $bb        ：打印寄存器print gdb_test(22)：将以整数22作为参数调用 gdb_test() 函数print gdb_test(a)：将以变量 a 作为参数调用 gdb_test() 函数display 表达式：在单步运行时将非常有用，使用display命令设置一个表达式后，它将在每次单步进行指令后，紧接着输出被设置的表达式及值。如： display awatch 表达式：设置一个监视点，一旦被监视的“表达式”的值改变，gdb将强行终止正在被调试的程序。如： watch a//查看源代码list(l)            ：查看当前代码附近的代码行list ：简记为 l ，其作用就是列出程序的源代码，默认每次显示10行。list 行号：将显示当前文件以“行号”为中心的前后10行代码，如：list 12list 函数名：将显示“函数名”所在函数的源代码，如：list mainlist ：不带参数，将接着上一次 list 命令的，输出下边的内容。</code></pre><h2 id="4、查询运行信息"><a href="#4、查询运行信息" class="headerlink" title="4、查询运行信息"></a>4、查询运行信息</h2><pre><code>where/bt                    ：当前运行的堆栈列表bt /backtrace/info stack    ：显示当前调用堆栈bt full                     ：查看完整的调用堆栈信息，包括每个栈帧中所有变量和参数的信息。up/down                        ：改变堆栈显示的深度set args                     ：指定运行时的参数set args [arguments]        ：传递命令行参数show args                    ：查看设置好的参数info program                ：查看程序的是否在运行，进程号，被暂停的原因。</code></pre><h2 id="5、设置断点和清除断点"><a href="#5、设置断点和清除断点" class="headerlink" title="5、设置断点和清除断点"></a>5、设置断点和清除断点</h2><pre><code>break  &lt;function&gt;    ：在进入指定函数时停住。C++中可以使用class::function或function(type,type)格式来指定函数名。break                        ：在指定行号停住。break +offset / break -offset    ：在当前行号的前面或后面的offset行停住。offiset为自然数。break filename：linenum        ：在源文件filename的linenum行处停住。break filename：function        ：在源文件filename的function函数的入口处停住。break *address                    ：在程序运行的内存地址处停住。break                            ：break命令没有参数时，表示在下一条指令处停住。break … if &lt; condition &gt;    …可以是上述的参数，condition表示条件，在条件成立时停住。比如在循环体中，可以设置break if i==100，表示当i为100时停住程序。b fn1 if a＞b                   ：条件断点设置info break [n]                   ：显示当前gdb的断点信息delete    [n]                       ：清除指定断点disable breakpoint [n]       ：禁止指定断点enable breakpoint [n]        ：允许指定断点</code></pre><p>参考自： <a href="https://linuxtools-rst.readthedocs.io/zh_CN/latest/tool/gdb.html" target="_blank" rel="noopener">https://linuxtools-rst.readthedocs.io/zh_CN/latest/tool/gdb.html</a></p><p>以十进制的方式查看寄存器的值：</p><pre><code> p/d $pc</code></pre><p>参考网址：<a href="https://ftp.gnu.org/old-gnu/Manuals/gdb-5.1.1/html_node/gdb_54.html" target="_blank" rel="noopener">https://ftp.gnu.org/old-gnu/Manuals/gdb-5.1.1/html_node/gdb_54.html</a></p><blockquote><p>技巧 ：交互模式下直接回车的作用是重复上一指令，对于单步调试非常方便；</p></blockquote><h2 id="6、示例"><a href="#6、示例" class="headerlink" title="6、示例"></a>6、示例</h2><pre><code>gdb ./demo(gdb) set args -i input.svac2(gdb) start(gdb) b 1201(gdb) info b(gdb) c(gdb) step(gdb) finish(gdb) layout src(gdb) list(gdb) print a(gdb) print $r0(gdb) q</code></pre><blockquote><p>注意：  想要使用gdb调试程序，在使用gcc编译程序时需要加上 -g 选项 。<br>一般调试崩溃程序时，是利用gdb+core dump文件进行调试分析的。 设置ulimit -c unlimited，之后运行程序，等生成core dump，  最后gdb  core_file   <exec file> 进行调试分析，bt查看crash之后的调用栈，定位到crash在了哪个位置。关于Core dump分析，更多可参考：<br><a href="https://blog.csdn.net/SoaringLee_fighting/article/details/81081717" target="_blank" rel="noopener">Linux中Core Dump分析</a><br><a href="https://blog.csdn.net/SoaringLee_fighting/article/details/70239732" target="_blank" rel="noopener">关于Segmentation fault (core dumped)几个简单问题</a><br>另外，针对segment fault的错误，可以采用linux下strace工具进行诊断。使用strace execfile，运行程序，出错时会显示哪个系统调用出错了。详细可以参看：<a href="https://blog.csdn.net/SoaringLee_fighting/article/details/82843848" target="_blank" rel="noopener">Linux下系统调用调试分析工具：strace</a>。</exec></p></blockquote><hr><h2 id="THE-END"><a href="#THE-END" class="headerlink" title=" THE END!"></a><font color="red"> THE END!</font></h2>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
          <category> 调试工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GDB </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CPU进程绑定技术（指定当前运行的CPU核）</title>
      <link href="/2018/08/25/%E3%80%90PE%E7%B3%BB%E5%88%97%E3%80%91CPU%E8%BF%9B%E7%A8%8B%E7%BB%91%E5%AE%9A%E6%8A%80%E6%9C%AF%EF%BC%88%E6%8C%87%E5%AE%9A%E5%BD%93%E5%89%8D%E8%BF%90%E8%A1%8C%E7%9A%84CPU%E6%A0%B8%EF%BC%89/"/>
      <url>/2018/08/25/%E3%80%90PE%E7%B3%BB%E5%88%97%E3%80%91CPU%E8%BF%9B%E7%A8%8B%E7%BB%91%E5%AE%9A%E6%8A%80%E6%9C%AF%EF%BC%88%E6%8C%87%E5%AE%9A%E5%BD%93%E5%89%8D%E8%BF%90%E8%A1%8C%E7%9A%84CPU%E6%A0%B8%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="1、参考"><a href="#1、参考" class="headerlink" title="1、参考"></a>1、参考</h2><p><a href="https://linux.die.net/man/3/cpu_zero" target="_blank" rel="noopener">https://linux.die.net/man/3/cpu_zero</a><br><a href="http://www.man7.org/linux/man-pages/man3/CPU_SET.3.html#top_of_page" target="_blank" rel="noopener">http://www.man7.org/linux/man-pages/man3/CPU_SET.3.html#top_of_page</a><br><a href="https://www.linuxidc.com/Linux/2015-04/116867.htm" target="_blank" rel="noopener">https://www.linuxidc.com/Linux/2015-04/116867.htm</a><br><a href="http://blog.163.com/liaoxiangui@126/blog/static/7956964020127204171138/" target="_blank" rel="noopener">http://blog.163.com/liaoxiangui@126/blog/static/7956964020127204171138/</a><br><a href="https://blog.csdn.net/honey_yyang/article/details/7848608/" target="_blank" rel="noopener">https://blog.csdn.net/honey_yyang/article/details/7848608/</a></p><h2 id="2、将进程绑定到特定CPU核心上"><a href="#2、将进程绑定到特定CPU核心上" class="headerlink" title="2、将进程绑定到特定CPU核心上"></a>2、将进程绑定到特定CPU核心上</h2><p>目的： 为了能够让程序拥有更好的性能，有时候需要将进程或线程绑定到特定的CPU，这样可以减少调度的开销和保护关键进程或线程。</p><h3 id="2-1、进程绑定到特定CPU"><a href="#2-1、进程绑定到特定CPU" class="headerlink" title="2.1、进程绑定到特定CPU"></a>2.1、<strong>进程绑定到特定CPU</strong></h3><p>Linux提供一个接口，可以将进程绑定到特定的CPU：</p><pre><code class="c">#define _GNU_SOURCE#include &lt;sched.h&gt;int sched_setaffinity(pid_t pid, size_t cpusetsize, const cpu_set_t *mask);int sched_getaffinity(pid_t pid, size_t cpusetsize, cpu_set_t *mask);</code></pre><p>参数</p><blockquote><p>pid：进程的id号，如果pid为0，则表示本进程<br>cpusetsize：mask的大小<br>mask：运行进程的CPU，可以通过以下函数操作mask</p></blockquote><pre><code class="c">#define CPU_SET(cpu, cpusetp) //设置cpu#define CPU_CLR(cpu, cpusetp) //删除cpu#define CPU_ISSET(cpu, cpusetp) //判断cpu#define CPU_ZERO(cpusetp) //初始化为0</code></pre><p><strong>示例代码:</strong></p><pre><code class="c">#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &lt;math.h&gt;#include &lt;sched.h&gt;void WasteTime(){    int abc = 10000000;    while(abc--)    {        int tmp = 10000*10000;    }    sleep(1);}int main(int argc, char **argv){    cpu_set_t mask;    while(1)    {        CPU_ZERO(&amp;mask);        CPU_SET(0, &amp;mask);        if (sched_setaffinity(0, sizeof(mask), &amp;mask) &lt; 0) {            perror(&quot;sched_setaffinity&quot;);        }        WasteTime();        CPU_ZERO(&amp;mask);        CPU_SET(1, &amp;mask);        if (sched_setaffinity(0, sizeof(mask), &amp;mask) &lt; 0) {            perror(&quot;sched_setaffinity&quot;);        }        WasteTime();        CPU_ZERO(&amp;mask);        CPU_SET(2, &amp;mask);        if (sched_setaffinity(0, sizeof(mask), &amp;mask) &lt; 0) {            perror(&quot;sched_setaffinity&quot;);        }        WasteTime();        CPU_ZERO(&amp;mask);        CPU_SET(3, &amp;mask);        if (sched_setaffinity(0, sizeof(mask), &amp;mask) &lt; 0) {            perror(&quot;sched_setaffinity&quot;);        }        WasteTime();    }}</code></pre><h3 id="2-2-对于arm设备指定cpu核心的方法："><a href="#2-2-对于arm设备指定cpu核心的方法：" class="headerlink" title="2.2 对于arm设备指定cpu核心的方法："></a>2.2 <strong>对于arm设备指定cpu核心的方法：</strong></h3><pre><code class="c">#if CONFIG_CORE#define _GNU_SOURCE   //启动CPU_ZERO和CPU_SET等系统函数#include &lt;sys/ioctl.h&gt;#include &lt;sys/mman.h&gt;#include &lt;sys/syscall.h&gt;#inlcude &lt;sched.h&gt;#include &lt;pthread.h&gt;#include &lt;fcntl.h&gt;#inlcude &lt;unistd.h&gt;#include &lt;errno.h&gt;static void __setAffinity_CPU_0(pid_t tid){  cpu_set_t cs;  CPU_ZERO(&amp;cs);  CPU_SET(&amp;cs,0);//设置CPU核心为0  sched_setaffinity(tid,sizeof(cs),&amp;cs);}#endifint main(int argc, char **argv){#if CONFIG_CORE    int coreindex = 3;    pid_t tid = null;    tid = syscall(SYS_gettid);    setAffinity_CPU(tid, coreindex);#endif}//指定cpu核pid_t tid = syscall(SYS_gettid);//获取当前进程pid__setAffinity_CPU_0(tid);//指定在CPU为0的核上运行，不指定时，运行的cpu随机分配，在不同的核上运行性能会有所差异。</code></pre><p><strong>结果查看：</strong><br>查看具体进程情况可以在执行时在另一个窗口使用top -h来查看线程的情况，查看各个核上的情况请使用top命令然后按数字“1”来查看。这样就可以知道当前进程是在哪个CPU核心上运行的了。</p><hr><h2 id="THE-END"><a href="#THE-END" class="headerlink" title="THE  END!"></a><font color="red"><strong>THE  END!</strong></font></h2>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 工程化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Some ways of Migrating code from ARM32 to AArch64</title>
      <link href="/2018/08/18/%E3%80%90ARM%E7%B3%BB%E5%88%97%E3%80%91Some%20ways%20of%20Migrating%20code%20from%20ARM32%20to%20AArch64/"/>
      <url>/2018/08/18/%E3%80%90ARM%E7%B3%BB%E5%88%97%E3%80%91Some%20ways%20of%20Migrating%20code%20from%20ARM32%20to%20AArch64/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="1、参考"><a href="#1、参考" class="headerlink" title="1、参考"></a>1、参考</h2><p><a href="https://www.nxp.com/docs/en/application-note/AN12212.pdf" target="_blank" rel="noopener">https://www.nxp.com/docs/en/application-note/AN12212.pdf</a><br><a href="https://blog.linuxplumbersconf.org/2014/ocw/system/presentations/2343/original/08%20-%20Migrating%20code%20from%20ARM%20to%20ARM64.pdf" target="_blank" rel="noopener">https://blog.linuxplumbersconf.org/2014/ocw/system/presentations/2343/original/08%20-%20Migrating%20code%20from%20ARM%20to%20ARM64.pdf</a><br><a href="https://stackoverflow.com/questions/41749005/convert-arm-32-bit-neon-to-arm-64-bit-neon" target="_blank" rel="noopener">https://stackoverflow.com/questions/41749005/convert-arm-32-bit-neon-to-arm-64-bit-neon</a><br><a href="http://infocenter.arm.com/help/topic/com.arm.doc.ihi0055b/IHI0055B_aapcs64.pdf" target="_blank" rel="noopener">http://infocenter.arm.com/help/topic/com.arm.doc.ihi0055b/IHI0055B_aapcs64.pdf</a><br><a href="http://users.ece.utexas.edu/~valvano/EE345M/Arm_EE382N_4.pdf" target="_blank" rel="noopener">http://users.ece.utexas.edu/~valvano/EE345M/Arm_EE382N_4.pdf</a></p><h2 id="2、Migrate-code-from-ARM32-to-AArch64"><a href="#2、Migrate-code-from-ARM32-to-AArch64" class="headerlink" title="2、Migrate code from ARM32 to AArch64"></a>2、Migrate code from ARM32 to AArch64</h2><p>在ARM汇编开发过程中，我们往往是先开发arm32位优化代码或者arm Intrinsic优化代码，为了适应64位架构，还需要开发arm64位下优化代码。<br>在项目紧急的情况下，可以在32位优化代码基础上通过“direct translation”快速开发出arm64位下的优化代码，但这种方法并不建议，因为通过直接翻译开发出的arm64位优化性能可能并不是最优的，并且有可能性能还会下降！但是重写的开销是很高的。<br>下面讲述在“direct translation”方法基础上进一步优化的方法：</p><h3 id="2-1-The-steps-of-“direct-translation”"><a href="#2-1-The-steps-of-“direct-translation”" class="headerlink" title="2.1  The steps of   “direct translation”"></a>2.1  The steps of   “direct translation”</h3><p>1、在进行代码迁移时，可以首先通过下面的<strong>指令集对比手册</strong>查找arm64下对应的指令，然后再查找官方指令手册查看该指令的详细用法。<br><a href="https://www.element14.com/community/servlet/JiveServlet/previewBody/41836-102-1-229511/ARM.Reference_Manual.pdf（指令集对比手册）" target="_blank" rel="noopener">https://www.element14.com/community/servlet/JiveServlet/previewBody/41836-102-1-229511/ARM.Reference_Manual.pdf（指令集对比手册）</a><br>2、在代码迁移时，需要注意ARM指令在32位下和在64位下并不是完全一致的，大部分指令是通用的，比如</p><pre><code>mov  r2, r1,    lsl    #2</code></pre><p>该指令只在arm32位下支持，在arm64下并不支持。<br>该指令等效于：</p><pre><code>lsl    r2,    r1,    #2</code></pre><p>因此在64位下可以直接采用上述指令进行替换！<br>3、另外，还有一些32位存在的指令在64位下是不存在的，比如vswp指令，条件执行指令subgt,addle等。<br>此时，就需要其他指令进行替换了。<br>4、arm32位和arm64位架构部分区别详见3。<br>5、另外需要特别注意的一点是：在进行代码迁移的过程中，一定要注意需要保存的ARM寄存器和neon寄存器，否则会引起堆栈问题，产生不可预期的结果。<br><strong>需要保存的ARM寄存器和NEON寄存器：</strong><br>对于ARM32位：r4~r11 , d8~d15(q4~q7)<br>对于ARM64位：x19~x29 , v8~v15</p><h3 id="2-2-further-optimization"><a href="#2-2-further-optimization" class="headerlink" title="2.2  further optimization"></a>2.2  further optimization</h3><p>1、调整优化策略和思路<br>2、在迁移基础上，减少数据依赖</p><h2 id="3、AArch32与AArch64的区别"><a href="#3、AArch32与AArch64的区别" class="headerlink" title="3、AArch32与AArch64的区别"></a>3、AArch32与AArch64的区别</h2><h3 id="3-1-入栈和出栈："><a href="#3-1-入栈和出栈：" class="headerlink" title="3.1 入栈和出栈："></a>3.1 入栈和出栈：</h3><p><strong><em>arm64位（aarch64架构）：</em></strong><br>（1）arm寄存器入栈和出栈：</p><pre><code>入栈：    sub  sp, sp, #0x10    stp  x8, x9, [sp] // 寄存器成对入栈出栈：    ldp  x8,  x9, [sp]    add  sp,  sp, #0x10 //寄存器成对出栈</code></pre><p>原则：<br>1、堆栈入栈和出栈后，SP指针应该保持不变（ARM和ARM64调用规则中被调用者实现栈平衡）<br>2、LIFO。<br>3、特别注意是，从SP位置存取数据都是从低地址开始的。</p><p>（2）neon寄存器入栈和出栈：<br><strong>ARM64位三种入栈出栈方法：</strong><br>方法一：</p><pre><code>stp        d8,d9,     [sp,    #-64]!stp        d10,d11,[sp,    #16]!stp        d12,d13,[sp,    #16]!stp        d14,d15,[sp,    #16]!ldp        d14,d15,[sp],    #-16ldp        d12,d13,[sp],    #-16ldp        d10,d11,[sp],    #-16ldp        d8,d9,[sp],        #64        //恢复sp位置</code></pre><p>方法二：</p><pre><code>stp        d8,d9,     [sp,    #-16]!stp        d10,d11,[sp,    #-16]!stp        d12,d13,[sp,    #-16]!stp        d14,d15,[sp,    #-16]!ldp        d14,d15,[sp],    #16ldp        d12,d13,[sp],    #16ldp        d10,d11,[sp],    #16ldp        d8,d9,[sp],        #16        //恢复sp位置</code></pre><p>方法三：</p><pre><code>.macro push_v_regs_dsub        sp,    sp,    #128st1        {v8.8H, v9.8H}, [sp],   #32st1        {v10.8H, v11.8H}, [sp], #32st1        {v12.8H, v13.8H}, [sp], #32st1        {v14.8H, v15.8H}, [sp].endm.macro pop_v_regs_dld1        {v14.8H, v15.8H}, [sp]sub        sp,    sp,        #32ld1        {v12.8H, v13.8H}, [sp]sub        sp,    sp,        #32ld1        {v10.8H, v11.8H}, [sp]sub        sp,    sp,        #32ld1        {v8.8H, v9.8H}, [sp]add        sp,    sp,        #128.endm</code></pre><p><strong><em>arm32位：</em></strong></p><pre><code>push    {r4-r11,  lr}vpush    {d8-d15}vpop    {d8-d15}pop        {r4-r11,  pc}</code></pre><h3 id="3-2-4x4矩阵转置："><a href="#3-2-4x4矩阵转置：" class="headerlink" title="3.2  4x4矩阵转置："></a>3.2  4x4矩阵转置：</h3><p><em>arm64位（aarch64架构）：</em></p><pre><code>.macro transpose4x4B  r0,r1,r2,r3,t4,t5,t6,t7trn1    \t4\().8B,    \r0\().8B,    \r1\().8Btrn2    \t5\().8B,    \r0\().8B,    \r1\().8Btrn1    \t6\().8B,    \r2\().8B,    \r3\().8Btrn2    \t7\().8B,    \r2\().8B,    \r3\().8Btrn1    \r0\().8B,    \t4\().8B,    \t6\().8Btrn1    \r1\().8B,    \t5\().8B,    \t7\().8Btrn2    \r2\().8B,    \t4\().8B,    \t6\().8Btrn3    \r3\().8B,    \t5\().8B,    \t7\().8B.endm</code></pre><p><em>arm32位：</em></p><pre><code>vtrn.16 q0,    q1vtrn.8    d0,    d1vtrn.8    d2,    d3</code></pre><h3 id="3-3-Difference-between-AArch64-and-AArch32"><a href="#3-3-Difference-between-AArch64-and-AArch32" class="headerlink" title="3.3 Difference between AArch64 and AArch32"></a>3.3 Difference between AArch64 and AArch32</h3><p><img src="/img/20180829224558921.jpg" alt="Difference between AARCH64 and AARCH32"></p><p>来源参考：<a href="https://www.nxp.com/docs/en/application-note/AN12212.pdf" target="_blank" rel="noopener">https://www.nxp.com/docs/en/application-note/AN12212.pdf</a></p><hr><h2 id="THE-END"><a href="#THE-END" class="headerlink" title=" THE END! "></a><font color="red"> THE END! </font></h2>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 优化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ARM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ARM架构64位入门基础：架构分析、寄存器、调用规则、指令集、程序调试以及参考手册</title>
      <link href="/2018/08/18/%E3%80%90arm%E3%80%91arm%E6%9E%B6%E6%9E%8464%E4%BD%8D%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%EF%BC%9A%E6%9E%B6%E6%9E%84%E5%88%86%E6%9E%90%E3%80%81%E5%AF%84%E5%AD%98%E5%99%A8%E3%80%81%E8%B0%83%E7%94%A8%E8%A7%84%E5%88%99%E3%80%81%E6%8C%87%E4%BB%A4%E9%9B%86%E3%80%81%E7%A8%8B%E5%BA%8F%E8%B0%83%E8%AF%95%E4%BB%A5%E5%8F%8A%E5%8F%82%E8%80%83%E6%89%8B%E5%86%8C/"/>
      <url>/2018/08/18/%E3%80%90arm%E3%80%91arm%E6%9E%B6%E6%9E%8464%E4%BD%8D%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%EF%BC%9A%E6%9E%B6%E6%9E%84%E5%88%86%E6%9E%90%E3%80%81%E5%AF%84%E5%AD%98%E5%99%A8%E3%80%81%E8%B0%83%E7%94%A8%E8%A7%84%E5%88%99%E3%80%81%E6%8C%87%E4%BB%A4%E9%9B%86%E3%80%81%E7%A8%8B%E5%BA%8F%E8%B0%83%E8%AF%95%E4%BB%A5%E5%8F%8A%E5%8F%82%E8%80%83%E6%89%8B%E5%86%8C/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="1、参考"><a href="#1、参考" class="headerlink" title="1、参考"></a>1、参考</h2><p><a href="https://developer.arm.com/products/architecture/instruction-sets" target="_blank" rel="noopener">https://developer.arm.com/products/architecture/instruction-sets</a><br><a href="https://developer.arm.com/docs/ddi0487/a" target="_blank" rel="noopener">https://developer.arm.com/docs/ddi0487/a</a></p><h2 id="2、ARM64位架构分析"><a href="#2、ARM64位架构分析" class="headerlink" title="2、ARM64位架构分析"></a>2、ARM64位架构分析</h2><p>ARM64位采用ARMv8架构，64位操作长度，对应处理器有Cortex-A53、Cortex-A57、Cortex-A73、iphones的A7和A8等。</p><p>AARCH64是全新32位固定长度指令集，支持64位操作数的新指令，大多数指令可以具有32位或64位参数。</p><p><strong>ARM64位架构有两种主要的执行状态：</strong></p><ol><li>AArch64 ——64 位执行状态，包括该状态的异常模型、内存模型、程序员模型和指令集支持</li><li>AArch32 ——32 位执行状态，包括该状态的异常模型、内存模型、程序员模型和指令集支持</li></ol><p><strong>这些执行状态支持三个主要指令集：</strong></p><ol><li>A32（或 ARM）：32 位固定长度指令集，通过不同架构变体增强部分 32 位架构执行环境现在称为 AArch32。</li><li>T32 (Thumb) 是以 16 位固定长度指令集的形式引入的，随后在引入 Thumb-2 技术时增强为 16 位和 32 位混合长度指令集。部分 32 位架构执行环境现在称为 AArch32。</li><li>A64：提供与 ARM 和 Thumb 指令集类似功能的 32 位固定长度指令集。随 ARMv8-A 一起引入，它是一种 全新的AArch64 指令集。<br>ARM ISA 不断改进，以满足前沿应用程序开发人员日益增长的要求，同时保留了必要的向后兼容性，以保护软件开发投资。在 ARMv8-A 中，对 A32 和 T32 进行了一些增补，以保持与 A64 指令集一致。</li></ol><h2 id="3、ARM64位寄存器"><a href="#3、ARM64位寄存器" class="headerlink" title="3、ARM64位寄存器"></a>3、ARM64位寄存器</h2><p>主要包括64位下的ARM寄存器和NEON寄存器。<br><strong>ARM架构64位寄存器：</strong><br>31个通用寄存器X0~X30,以及SP（x31）和PC，共33个。其中W0~W31分别是X0~X31的低32位，如下图所示：<br><img src="/img/20180822213240381.jpg" alt="ARM架构64位寄存器"><br><strong><em>64位下通用寄存器关系图</em></strong></p><p><strong>ARM64位参数调用规则</strong>遵循AAPCS64，规定堆栈为满递减堆栈。<br> 寄存器调用规则如下：</p><ul><li>X0~X7：用于传递子程序参数和结果，使用时不需要保存，多余参数采用堆栈传递，64位返回结果采用X0表示，128位返回结果采用X1:X0表示。</li><li>X8：用于保存子程序返回地址，<font color="red">  尽量不要使用 </font>。</li><li>X9~X15：临时寄存器，使用时不需要保存。</li><li>X16~X17：子程序内部调用寄存器，使用时不需要保存，<font color="red">尽量不要使用</font>。</li><li>X18：平台寄存器，它的使用与平台相关，<font color="red">尽量不要使用</font>。</li><li>X19~X28：临时寄存器，使用时必须保存。</li><li>X29：帧指针寄存器，用于连接栈帧，使用时需要保存。</li><li>X30：链接寄存器LR</li><li>X31：堆栈指针寄存器SP或零寄存器ZXR</li></ul><blockquote><p>注意：<br>子程序调用时必须要保存的寄存器：X19~X29和SP(X31)。<br>不需要保存的寄存器：X0~X7,X9~X15</p></blockquote><p><strong>64位下NEON寄存器：</strong></p><ul><li><p>32个B寄存器（B0~B31）,8bit</p></li><li><p>32个H寄存器（H0~H31）,半字 16bit</p></li><li><p>32个S寄存器（S0~S31）,单子 32bit</p></li><li><p>32个D寄存器（D0~D31）,双字 64bit</p></li><li><p>32个Q寄存器（V0~V31）,四字 128bit</p><p>不同位数下寄存器之间的关系如下图所示：<br><img src="/img/20180822213447950.jpg" alt="不同位数下寄存器之间的关系"></p></li></ul><p>其中S0是D0的低半部分，D0是V0的低半部分 。</p><blockquote><p>注意：<br>64位下NEON寄存器与32位下NEON寄存器之间的关系不同！<br>neon寄存器 v0~v31使用说明：<br>v0~v7:用于参数传递和返回值，子程序不需要保存；<br>v8~v15:子程序调用时必须入栈保存（低64位）；<br>v16~v31:子程序使用时不需要保存。<br>具体可参考：<br><a href="http://infocenter.arm.com/help/topic/com.arm.doc.ihi0055b/IHI0055B_aapcs64.pdf" target="_blank" rel="noopener">http://infocenter.arm.com/help/topic/com.arm.doc.ihi0055b/IHI0055B_aapcs64.pdf</a>  5.1.2 SIMD and Floating-Point Registers</p></blockquote><h2 id="4、ARM64位指令集A64以及参考手册"><a href="#4、ARM64位指令集A64以及参考手册" class="headerlink" title="4、ARM64位指令集A64以及参考手册"></a>4、ARM64位指令集A64以及参考手册</h2><p>ARMv8-a指令集参考手册：<br><a href="https://developer.arm.com/docs/ddi0487/a" target="_blank" rel="noopener">https://developer.arm.com/docs/ddi0487/a</a><br><a href="https://static.docs.arm.com/ddi0487/a/DDI0487A_j_armv8_arm.pdf（官方标准手册）" target="_blank" rel="noopener">https://static.docs.arm.com/ddi0487/a/DDI0487A_j_armv8_arm.pdf（官方标准手册）</a><br><a href="https://developer.arm.com/products/architecture/cpu-architecture/a-profile/docs/den0024/latest/porting-to-a64" target="_blank" rel="noopener">https://developer.arm.com/products/architecture/cpu-architecture/a-profile/docs/den0024/latest/porting-to-a64</a><br><a href="https://community.arm.com/processors/b/blog/posts/porting-to-arm-64-bit" target="_blank" rel="noopener">https://community.arm.com/processors/b/blog/posts/porting-to-arm-64-bit</a><br><a href="https://www.element14.com/community/servlet/JiveServlet/previewBody/41836-102-1-229511/ARM.Reference_Manual.pdf（指令集对比手册）" target="_blank" rel="noopener">https://www.element14.com/community/servlet/JiveServlet/previewBody/41836-102-1-229511/ARM.Reference_Manual.pdf（指令集对比手册）</a><br><a href="http://profsite.um.ac.ir/~shoraka/ARMInstructionSet.pdf" target="_blank" rel="noopener">http://profsite.um.ac.ir/~shoraka/ARMInstructionSet.pdf</a><br><a href="http://infocenter.arm.com/help/topic/com.arm.doc.ihi0055b/IHI0055B_aapcs64.pdf" target="_blank" rel="noopener">http://infocenter.arm.com/help/topic/com.arm.doc.ihi0055b/IHI0055B_aapcs64.pdf</a><br><a href="http://infocenter.arm.com/help/topic/com.arm.doc.ihi0056c/IHI0056C_beta_aaelf64.pdf" target="_blank" rel="noopener">http://infocenter.arm.com/help/topic/com.arm.doc.ihi0056c/IHI0056C_beta_aaelf64.pdf</a><br><a href="http://infocenter.arm.com/help/topic/com.arm.doc.den0024a/DEN0024A_v8_architecture_PG.pdf" target="_blank" rel="noopener">http://infocenter.arm.com/help/topic/com.arm.doc.den0024a/DEN0024A_v8_architecture_PG.pdf</a> （Programmer’s Guide）</p><h2 id="5、ARM64位程序调试-非常有用"><a href="#5、ARM64位程序调试-非常有用" class="headerlink" title="5、ARM64位程序调试(非常有用)"></a>5、ARM64位程序调试(非常有用)</h2><p> <strong>方法一: 直接打印数据</strong></p><p>ARM64位下打印数据的方法：<br>(1). 打印V寄存器：</p><pre><code>mov        w0,    v0.s[0]mov        w1,    v0.s[1]mov        w2,    v0.s[2]mov        w3,    v0.s[3]bl        _print</code></pre><p>(2). 打印V寄存器的低64位：</p><pre><code>mov        w0,    v2.s[0]mov        w1,    v2.s[1]bl        _print</code></pre><p>(3). 打印w寄存器</p><pre><code>mov        w0,    w12mov        w1,    w3bl        _print</code></pre><p>其中print函数的定义如下：</p><pre><code class="c">void print(int a, int b, int c, int d){    printf(&quot;%08x %08x %08x %08x\n&quot;,a,b,c,d);}</code></pre><p>(4).将V寄存器打印到内存的方法</p><pre><code>.macro printf_m in1=x0, in2=x1    st1  {\in2\().2D}, [\in1\()]    mov  x0,  \in1    bl     cprintf.endm</code></pre><p>cprintf定义如下：</p><pre><code class="c">void cprint(unsigned char *src8){ signed char* srcs8 = (signed char*)src8; short* srcs16 = (short*)src8; unsigned short* srcu16 = (unsigned short*)src8; int* srcs32 = (int*)src8; printf(&quot;u8:\n&quot;); for(int i=0; i &lt; 16; i++)  {   printf(&quot;%d&quot;, src8[i]);  }   printf(&quot;s8:\n&quot;); for(int i=0; i &lt; 16; i++)  {   printf(&quot;%d&quot;, srcs8[i]);  }   printf(&quot;u16:\n&quot;);   for(int i=0; i &lt; 8; i++)  {   printf(&quot;%d&quot;, srcu16[i]);  }     printf(&quot;s16:\n&quot;);   for(int i=0; i &lt; 8; i++)  {   printf(&quot;%d&quot;, srcs16[i]);  }  printf(&quot;s32:\n&quot;);   for(int i=0; i &lt; 4; i++)  {   printf(&quot;%d&quot;, srcs32[i]);  }}</code></pre><p><strong>方法二: GDB调试</strong><br>详细调试方法可以参考：<a href="https://blog.csdn.net/SoaringLee_fighting/article/details/82251334" target="_blank" rel="noopener">GDB调试方法</a><br>对于neon寄存器入栈：</p><pre><code>.macro push_v_regs    stp    d8,  d9,  [sp, #-16]!    stp    d10, d11, [sp, #-16]!    stp    d12, d13, [sp, #-16]!    stp    d14, d15, [sp, #-16]!.endm.macro pop_v_regs    ldp    d14, d15, [sp], #16    ldp    d12, d13, [sp], #16    ldp    d10, d11, [sp], #16    ldp    d8,  d9,  [sp], #16.endm</code></pre><p><font color="red">  至于要用的是v8~v15寄存器，为什么成了压d8~d15？ </font>具体原因可以参考：<a href="http://infocenter.arm.com/help/topic/com.arm.doc.ihi0055b/IHI0055B_aapcs64.pdf" target="_blank" rel="noopener">http://infocenter.arm.com/help/topic/com.arm.doc.ihi0055b/IHI0055B_aapcs64.pdf</a> 5.1.2小节 SIMD and Floating-Point Registers</p><blockquote><p>Registers v8-v15 must be preserved by a callee across subroutine calls; the remaining registers (v0-v7, v16-v31) do not need to be preserved (or should be preserved by the caller). Additionally, <strong>only the bottom 64-bits of each value stored in v8-v15 need to be preserved; it is the responsibility of the caller to preserve larger values</strong>.</p></blockquote><p><strong>在采用gdb调试程序时遇到以下两个问题：</strong></p><p> <font color="red">问题一：在对v寄存器(v8~v15)入栈后，采用gdb调试会出现下面的问题：</font></p><blockquote><p>/build/gdb-qLNsm9/gdb-7.11.1/gdb/aarch64-tdep.c:334: internal-error: aarch64_analyze_prologue: Assertion <code>inst.operands[0].type == AACH64_OPAND_Rt</code> failed.</p></blockquote><p><strong>解决方案：</strong><br>　　通过分析可知，在对neon寄存器（v8~v15）进行入栈后采用gdb调试会出现报错，无法实现在存在对neon寄存器入栈的汇编代码进行gdb调试。这是当前gdb版本7.11.1存在的堆栈问题，是属于gdb本身存在的bug，可以通过升级gdb版本实现调试。<br>　　另外可以采用st1，ld1对SP存取数据的方式进行临时替换，当然该方案仅用于调试，通过测试可知，采用该方式替代stp,ldp入栈出栈后子程序可以得到正确的结果，<font color="red">并且不会影响调用者中的值。对于这点尚存在疑问？</font></p><blockquote><p>关于采用st1,ld1方式入栈出栈的说明：<br>单独采用st1，ld1方式进行入栈出栈，测试可知不会影响调用者中的值。<br>采用st1,ld1方式进行入栈出栈，中间存在大量汇编代码，进行测试可知：可能会影响调用者的值。打印输出时间信息为0，不能正常显示调用者的值，但是子程序可以得到正确的值。</p></blockquote><pre><code>.macro push_v_regs_dsub        sp,    sp,    #128st1        {v8.8H, v9.8H}, [sp],   #32st1        {v10.8H, v11.8H}, [sp], #32st1        {v12.8H, v13.8H}, [sp], #32st1        {v14.8H, v15.8H}, [sp].endm.macro pop_v_regs_dld1        {v14.8H, v15.8H}, [sp]sub        sp,    sp,        #32ld1        {v12.8H, v13.8H}, [sp]sub        sp,    sp,        #32ld1        {v10.8H, v11.8H}, [sp]sub        sp,    sp,        #32ld1        {v8.8H, v9.8H}, [sp]add        sp,    sp,        #128.endm</code></pre><p>关于SP入栈、出栈更多可参考：</p><ol><li><a href="https://community.arm.com/processors/b/blog/posts/using-the-stack-in-aarch64-implementing-push-and-pop" target="_blank" rel="noopener">https://community.arm.com/processors/b/blog/posts/using-the-stack-in-aarch64-implementing-push-and-pop</a></li><li><a href="https://community.arm.com/processors/b/blog/posts/using-the-stack-in-aarch32-and-aarch64" target="_blank" rel="noopener">https://community.arm.com/processors/b/blog/posts/using-the-stack-in-aarch32-and-aarch64</a></li><li><a href="https://stackoverflow.com/questions/40271180/push-and-pop-a-full-128-bit-neon-register-to-from-the-stack-in-aarch64" target="_blank" rel="noopener">https://stackoverflow.com/questions/40271180/push-and-pop-a-full-128-bit-neon-register-to-from-the-stack-in-aarch64</a></li></ol><p><font color="red">问题二：程序出现 segmention fault后，采用gdb调试</font><br><strong>可能原因分析：</strong><br>1、段错误一般是由于堆栈被破环，在存取数据时引起SIGSEGV crash，通常是由于内存读写越界导致。关于SIGSEGV的解释可以详见<a href="https://blog.csdn.net/SoaringLee_fighting/article/details/82842251" target="_blank" rel="noopener">SIGSEGV与SIGBUS的区别分析</a>。<br>2、堆栈可能是正确的，但是在存取数据时访问的地址不对（即指针所对应的地址是无效地址，没有物理内存对应该地址），造成访问越界引起crash，比如含有指针地址的函数声明与函数实现不一致会引起段错误。（2018.9.25 调试svac2dec库总结经验）</p><h2 id="6、IOS64和ARM64的参数传递差异和编译差异"><a href="#6、IOS64和ARM64的参数传递差异和编译差异" class="headerlink" title="6、IOS64和ARM64的参数传递差异和编译差异"></a>6、IOS64和ARM64的参数传递差异和编译差异</h2><p>（1）ARM64参数入栈都要保证8字节对齐，跟数据类型无关，而IOS64的参数入栈跟数据类型有关；<br>（2）ARM64参数传递是成对传递的，比如(x0,x1),(x2,x3)等，而IOS64的参数传递并不应遵守这一准则；<br>（3）ARM和IOS编译的差别：<br>ARM在Linux下编译gcc早期版本函数名前需要添加下划线，目前最新版本的gcc（4.4.7）不需要添加，这与gcc编译版本相关；<br>IOS平台下编译都需要添加下划线：“_”。</p><h2 id="7、ARM64位加载和存储数据的几种格式"><a href="#7、ARM64位加载和存储数据的几种格式" class="headerlink" title="7、ARM64位加载和存储数据的几种格式"></a>7、ARM64位加载和存储数据的几种格式</h2><pre><code>ld1 {v20.8H, v21.8H}, [x1]  @ 从x1指向的存储单元位置一次性加载128*2位数据到v20和v21中ld1 {v1.8B},    [x1],    x2  @ 从x1指向的存储单元位置加载64位数据到v1的低64位中，然后x1=x1+x2ld1    {v18.S}[0],    [x0],    x1  @ 将x0地址里面的数据取32位加载到v18的最低32位，然后x0=x0+x1ld1r {v30.8H},    [x1]        @ 从x1地址中以16位为单位取128位加载到v30中。st1    {v30.8H},    [x1],    #16    @ 将 寄存器v30中128位数据存储到x1地址处，然后x1=x1+16st1    {v0.S}[0],    [x0],    x2    @ 将 寄存器v0的低32位数据存储到x0地址处吗，然后x0=x0+x2</code></pre><h2 id="8、ARM64位下程序注释"><a href="#8、ARM64位下程序注释" class="headerlink" title="8、ARM64位下程序注释"></a>8、ARM64位下程序注释</h2><p>在ARM32位下，单行注释采用@或者//，多行注释可以采用/* */；<br>在ARM64位下，单行注释采用//，多行注释采用/* */；<br>因此为了程序注释的统一，建议在ARM32位和ARM64位程序中注释都采用//的格式。</p><hr><h2 id="THE-END"><a href="#THE-END" class="headerlink" title="THE END! "></a><font color="red"><strong>THE END!</strong> </font></h2>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 优化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ARM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ARM与Thumb之间的状态转换</title>
      <link href="/2018/08/18/%E3%80%90ARM%E7%B3%BB%E5%88%97%E3%80%91Thumb%E7%8A%B6%E6%80%81%E5%88%86%E6%9E%90%E4%BB%A5%E5%8F%8AARM%E4%B8%8EThumb%E4%B9%8B%E9%97%B4%E7%9A%84%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2/"/>
      <url>/2018/08/18/%E3%80%90ARM%E7%B3%BB%E5%88%97%E3%80%91Thumb%E7%8A%B6%E6%80%81%E5%88%86%E6%9E%90%E4%BB%A5%E5%8F%8AARM%E4%B8%8EThumb%E4%B9%8B%E9%97%B4%E7%9A%84%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="1、参考"><a href="#1、参考" class="headerlink" title="1、参考"></a>1、参考</h2><p><a href="https://blog.csdn.net/beyond702/article/details/51201027" target="_blank" rel="noopener">ARM指令在Thumb模式和arm模式之间跳转</a></p><p><a href="https://blog.csdn.net/czg13548930186/article/details/78643445" target="_blank" rel="noopener">ARM与Thumb之间的状态转换</a></p><p><a href="https://www.cnblogs.com/yygsj/p/5428500.html" target="_blank" rel="noopener">ARM状态和THUMB状态</a></p><p><a href="https://blog.csdn.net/yuanzhihua126/article/details/78982600" target="_blank" rel="noopener">Thumb和ARM指令的区别</a></p><h2 id="2、Thumb状态分析"><a href="#2、Thumb状态分析" class="headerlink" title="2、Thumb状态分析"></a>2、Thumb状态分析</h2><p>在ARM的体系结构中，可以工作在三种不同的状态，一是ARM状态，二是Thumb状态及Thumb-2状态，三是调试状态。其中Thumb指令集可以看做是ARM指令集的子集。</p><ul><li>ARM状态：arm处理器工作于32位指令的状态，所有指令均为32位；</li><li>Thumb状态： arm执行16位指令的状态，即16位状态；</li><li>Thumb-2状态：这个状态是ARM7版本的ARM处理器所具有的新的状态，新的thumb-2内核技术兼有16位及32位指令，实现了更高的性能，更有效的功耗及更少地占用内存。总的来说，感觉这个状态除了兼有arm和thumb的优点外，还在这两种状态上有所提升，优化。</li><li>调试状态：arm处理器停机时进入调试状态。</li></ul><h2 id="3、ARM与Thumb之间的状态转换"><a href="#3、ARM与Thumb之间的状态转换" class="headerlink" title="3、ARM与Thumb之间的状态转换"></a>3、ARM与Thumb之间的状态转换</h2><p>根据arm spec, 跳转地址最低位( lsb ) 为0表示 arm 指令；最低位为1表示thumb指令。</p><p>下面部分参考自：<a href="https://blog.csdn.net/czg13548930186/article/details/78643445" target="_blank" rel="noopener">https://blog.csdn.net/czg13548930186/article/details/78643445</a><br>ARM/Thumb之间的状态切换是通过一条专用的转移交换指令BX来实现的。BX指令以通用寄存器位操作数，通过拷贝Rn到PC来实现4GB空间范围内的一个绝对跳转。BX利用Rn寄存器中目的地址值的最后一位来判断跳转后的状态。当最后一位为0时，表示转移到ARM状态；当最后一位为1时，表示转移到Thumb状态。如下图所示：<br><img src="/img/20190807200809398.png" alt="ARM与Thumb之间的状态转换"></p><h3 id="3-1-ARM切换到Thumb"><a href="#3-1-ARM切换到Thumb" class="headerlink" title="3.1 ARM切换到Thumb"></a>3.1 ARM切换到Thumb</h3><p>状态将寄存器的最低位设置为1</p><p>BX指令：R0[0]=1，则执行BX<br>R0指令将进入thumb状态。</p><h3 id="3-2-Thumb切换到ARM"><a href="#3-2-Thumb切换到ARM" class="headerlink" title="3.2 Thumb切换到ARM"></a>3.2 Thumb切换到ARM</h3><p>寄存器最低位设置为0</p><p>BX指令：R0[0]=0，则执行BX<br>R0指令将进入arm状态。</p><ul><li>当处理器进行异常处理时，则从异常向量地址开始执行，将自动进入ARM状态。</li><li>ARM处理器复位后开始执行代码时总是只处于ARM状态</li></ul><p>总结一下，arm状态与Thumb状态的本质区别就是指令的位数不同，arm是32位的指令状态，而thumb是16位的指令状态，而thumb-2状态是arm状态和thumb状态的结合和优化。</p><h2 id="4、Thumb和ARM指令的主要区别"><a href="#4、Thumb和ARM指令的主要区别" class="headerlink" title="4、Thumb和ARM指令的主要区别"></a>4、Thumb和ARM指令的主要区别</h2><p>Thumb指令可以看做是ARM指令压缩形式的子集，是针对代码密度的问题而提出的，它具有16位的代码密度。Thumb不是一个完整的体系结构，不能指望处理程序只执行Thumb指令而不支持ARM指令集。因此，Thumb指令只需要支持通用功能，必要时，可借助完善的ARM指令集，例如：所有异常自动进入ARM状态。</p><p>在编写Thumb指令时，先要使用伪指令CODE16声明，而且在ARM指令中要使用BX指令跳转到Thumb指令，以切换处理器状态。编写ARM指令时，可使用伪指令CODE32声明。</p><p>Thumb指令集没有协处理器指令、信号量指令以及访问CPSR或SPSR的指令，没有乘加指令及64位乘法指令等，且指令的第二操作数受到限制；除了跳转指令B有条件执行功能外，其他指令均为无条件执行；大多数Thumb数据处理指令采用2地址格式。</p><hr><h2 id="THE-END"><a href="#THE-END" class="headerlink" title=" THE END! "></a><font color="red"> THE END! </font></h2>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 优化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ARM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ARM架构64位(AArch64)汇编优化总结</title>
      <link href="/2018/08/18/%E3%80%90arm%E3%80%91arm%E6%9E%B6%E6%9E%8464%E4%BD%8D%EF%BC%88AArch64%EF%BC%89%E6%B1%87%E7%BC%96%E4%BC%98%E5%8C%96%E6%80%BB%E7%BB%93/"/>
      <url>/2018/08/18/%E3%80%90arm%E3%80%91arm%E6%9E%B6%E6%9E%8464%E4%BD%8D%EF%BC%88AArch64%EF%BC%89%E6%B1%87%E7%BC%96%E4%BC%98%E5%8C%96%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="1、参考"><a href="#1、参考" class="headerlink" title="1、参考"></a>1、参考</h2><p><a href="https://blog.csdn.net/SoaringLee_fighting/article/details/81906495" target="_blank" rel="noopener">https://blog.csdn.net/SoaringLee_fighting/article/details/81906495</a><br><a href="https://blog.csdn.net/SoaringLee_fighting/article/details/82155608" target="_blank" rel="noopener">https://blog.csdn.net/SoaringLee_fighting/article/details/82155608</a><br><a href="https://blog.csdn.net/u011514906/article/details/38142177" target="_blank" rel="noopener">https://blog.csdn.net/u011514906/article/details/38142177</a><br><a href="https://blog.csdn.net/listener51/article/details/82530464" target="_blank" rel="noopener">https://blog.csdn.net/listener51/article/details/82530464</a></p><h2 id="2、前言"><a href="#2、前言" class="headerlink" title="2、前言"></a>2、前言</h2><p> &ensp; &ensp;   &ensp;本文是arm架构64位(AArch64执行状态) neon优化的总结文档，主要包括arm架构64位优化的基础知识，特殊用法，打印调试和常用指令使用注意事项以及资料来源等相关知识。前文已有<a href="https://blog.csdn.net/SoaringLee_fighting/article/details/81906495" target="_blank" rel="noopener">arm架构32位汇编优化总结</a>对arm架构32位neon优化进行了全面总结，并且讲述了arm汇编语法,下面主要以gnu asm汇编语法为例讲述。<br>　　下图为arm架构汇编优化总结的思维导图：<br>　　<img src="/img/20180915233002170.jpg" alt="arm架构汇编优化总结">　　</p><h2 id="3、arm架构64位优化基础知识"><a href="#3、arm架构64位优化基础知识" class="headerlink" title="3、arm架构64位优化基础知识"></a>3、arm架构64位优化基础知识</h2><p>&ensp;  <a href="https://blog.csdn.net/SoaringLee_fighting/article/details/81906495" target="_blank" rel="noopener">【arm】arm架构64位入门基础：架构分析、寄存器、调用规则、指令集以及参考手册</a><br>&ensp;    该博客已经分析了arm架构64位汇编优化的入门基础知识,主要包括<strong>架构分析,寄存器,调用规则,指令集和程序打印调试</strong>相关知识,可以作为入门arm64位汇编优化的基础知识。　　</p><h2 id="4、ARMv8-AArch64-neon指令格式"><a href="#4、ARMv8-AArch64-neon指令格式" class="headerlink" title="4、ARMv8/AArch64 neon指令格式"></a>4、ARMv8/AArch64 neon指令格式</h2><p>　　In the AArch64 execution state, the syntax of NEON instruction has changed. It can be described as follows:</p><pre><code class="c">　　{&lt;prefix&gt;}&lt;op&gt;{&lt;suffix&gt;}  Vd.&lt;T&gt;, Vn.&lt;T&gt;, Vm.&lt;T&gt;　　</code></pre><blockquote><p>Where:<br>&lt; prefix&gt; - prefix, such as using S/U/F/P to represent signed/unsigned/float/bool data type.<br>&lt; op&gt; – operation, such as ADD, AND etc.<br>&lt; suffix&gt; - suffix<br>P: “pairwise” operations, such as ADDP，LDP，STP.<br>V: the new reduction (across-all-lanes) operations, such as ADDV，SMAXV，FMAXV.<br>2：new widening/narrowing “second part” instructions, such as ADDHN2, SADDL2，SMULL2.<br>&lt; T&gt; - data type, 8B/16B/4H/8H/2S/4S/2D. B represents byte (8-bit). H represents half-word (16-bit). S represents word (32-bit). D represents a double-word (64-bit). 　</p><pre><code class="c">For example:UADDLP    V0.8H, V0.16BFADD V0.4S, V0.4S, V0.4S</code></pre><p> 参考自：<br> <a href="https://community.arm.com/android-community/b/android/posts/arm-neon-programming-quick-reference" target="_blank" rel="noopener">https://community.arm.com/android-community/b/android/posts/arm-neon-programming-quick-reference</a></p></blockquote><h2 id="5、ARM相关编译参数"><a href="#5、ARM相关编译参数" class="headerlink" title="5、ARM相关编译参数"></a>5、ARM相关编译参数</h2><p>　　嵌入式设备（即arm架构的板子）在编译时，最好加上 -fsigned-char 因为嵌入式设备默认类型为unsigned char类型，非char 类型。此外在编译arm汇编优化代码时，编译选项需要加上-c 。-c都表示编译或汇编源文件,但是不进行链接。<br>　　ARM相关或者硬件相关编译参数一般以-m开头,常用ARM平台编译选项包括:</p><blockquote><p>-mcpu = cortex-a7<br>-mabi = atpcs<br>-march = armv7<br>-mtune = cortex-a53<br>-mfpu = neon, neon-vfpv4<br>-mfloat-api = soft, softfp, hard</p></blockquote><p>更多详细内容可以参考:<a href="https://gcc.gnu.org/onlinedocs/gcc-5.2.0/gcc.pdf" target="_blank" rel="noopener">https://gcc.gnu.org/onlinedocs/gcc-5.2.0/gcc.pdf</a> 3.17.1小节AArch64 option和3.17.4小节 ARM options.</p><h2 id="6、查看状态标记位NZCV的方法"><a href="#6、查看状态标记位NZCV的方法" class="headerlink" title="6、查看状态标记位NZCV的方法"></a>6、查看状态标记位NZCV的方法</h2><pre><code class="c">mrs  x15, nzcvmov  w0,  w15bl    print</code></pre><h2 id="7、A64指令集特有的指令及其用法"><a href="#7、A64指令集特有的指令及其用法" class="headerlink" title="7、A64指令集特有的指令及其用法"></a>7、A64指令集特有的指令及其用法</h2><h3 id="7-1-shl和ushr指令"><a href="#7-1-shl和ushr指令" class="headerlink" title="7.1.  shl和ushr指令"></a>7.1.  shl和ushr指令</h3><pre><code class="c">    shl  &lt;V&gt;.&lt;d&gt;, &lt;V&gt;.&lt;n&gt;, #&lt;shift&gt;    ushr  &lt;V&gt;.&lt;d&gt;, &lt;V&gt;.&lt;n&gt;, #&lt;shift&gt;    ushr  d2， d2,  #8</code></pre><p> 使用注意事项：这两条指令只能操作64位数据，即只能对D寄存器进行处理。<br> ushr最多只能进行64位数据的右移，并且右移时会影响V2寄存器的高64位数据（清零），因此高64位数据需要在右移前保存，否则相关数据会被修改。</p><h3 id="7-2-INS指令"><a href="#7-2-INS指令" class="headerlink" title="7.2. INS指令"></a>7.2. INS指令</h3><p> 用法与MOV指令基本一样,可以实现neon标量与neon标量之间的传送,以及ARM寄存器与neon标量之间的传送。</p><pre><code class="c">INS   &lt;Vd&gt;.&lt;Ts&gt;[index1], &lt;Vn&gt;.&lt;Ts&gt;[index2]INS   &lt;Vd&gt;.&lt;Ts&gt;[index1], Rn</code></pre><h3 id="7-3-SUQADD、USQADD指令"><a href="#7-3-SUQADD、USQADD指令" class="headerlink" title="7.3. SUQADD、USQADD指令"></a>7.3. SUQADD、USQADD指令</h3><pre><code>    既有标量用法,也有矢量用法。</code></pre><pre><code class="c">SUQADD &lt;V&gt;&lt;d&gt;, &lt;V&gt;&lt;d&gt;     // signed saturating accumulate of unsigned valueSUQADD &lt;Vd&gt;.&lt;T&gt;, &lt;Vn&gt;.&lt;T&gt;USQADD &lt;V&gt;&lt;d&gt;, &lt;V&gt;&lt;d&gt;    // unsigned saturating accumulate of signed valueUSQADD &lt;Vd&gt;.&lt;T&gt;, &lt;Vn&gt;.&lt;T&gt;</code></pre><h3 id="7-4-RBIT、REV指令"><a href="#7-4-RBIT、REV指令" class="headerlink" title="7.4. RBIT、REV指令"></a>7.4. RBIT、REV指令</h3><pre><code class="c"> RBIT &lt;Wd&gt;, &lt;Wn&gt; //reverse bits REV &lt;Wd&gt;, &lt;Wn&gt;  //reverse bytes</code></pre><h3 id="7-5-ADDV-SADDLV-SMAXV-SMINV-Vector-Reduce（across-lanes）"><a href="#7-5-ADDV-SADDLV-SMAXV-SMINV-Vector-Reduce（across-lanes）" class="headerlink" title="7.5. ADDV,SADDLV,SMAXV,SMINV (Vector Reduce（across lanes）)"></a>7.5. ADDV,SADDLV,SMAXV,SMINV (Vector Reduce（across lanes）)</h3><pre><code class="c">ADDV &lt;V&gt;&lt;d&gt;, &lt;Vn&gt;&lt;T&gt;    // Integer sum element to scalar(vector)SADDLV &lt;V&gt;&lt;d&gt;, &lt;Vn&gt;&lt;T&gt;  // Signed Interger sum elements to long scalar(vector)SMAXV &lt;V&gt;&lt;d&gt;, &lt;Vn&gt;&lt;T&gt;   // Signed Interger maximum elements to scalar(vector)SMINV &lt;V&gt;&lt;d&gt;, &lt;Vn&gt;&lt;T&gt;   // Signed Interger minimum elements to scalar(vector)eg.:addv B0, v1.8B            // 将v1寄存器中的低64位中8个8位数据相加求和后，赋给v0的最低8位。</code></pre><p>更多详细解释可以参考：<a href="https://static.docs.arm.com/ddi0487/a/DDI0487A_j_armv8_arm.pdf" target="_blank" rel="noopener">https://static.docs.arm.com/ddi0487/a/DDI0487A_j_armv8_arm.pdf</a><br><img src="/img/20180914155719641.jpg" alt="SIMD reduce"></p><h3 id="7-6-sxtw使用注意事项"><a href="#7-6-sxtw使用注意事项" class="headerlink" title="7.6. sxtw使用注意事项"></a>7.6. sxtw使用注意事项</h3><p> 负数在使用时必须进行符号扩展！<br> 比如：</p><pre><code class="c">sxtw   x4, w4</code></pre><h3 id="7-7-w寄存器到v寄存器"><a href="#7-7-w寄存器到v寄存器" class="headerlink" title="7.7. w寄存器到v寄存器"></a>7.7. w寄存器到v寄存器</h3><p>直接使用dup指令</p><pre><code class="c">dup        v0.8B,  w2</code></pre><h3 id="7-8-常用指令对应关系-arm32—-gt-arm64"><a href="#7-8-常用指令对应关系-arm32—-gt-arm64" class="headerlink" title="7.8.常用指令对应关系(arm32—-&gt;arm64)"></a>7.8.常用指令对应关系(arm32—-&gt;arm64)</h3><pre><code class="c"> vmovl------&gt;uxtl/sxtl vqmovn-----&gt;sqxtn vqmovun-----&gt;sqxtun vqrshrun----&gt;sqrshrun vceq-------&gt;cmeq vcge-------&gt;cmge vadd------&gt;add vsub------&gt;sub vaddl-----&gt;saddl,uaddl vaddw-----&gt;saddw,uaddw,sw2addw2,uadd vmull-----&gt;smull,smull2,umull,umull2 vmax,vmin-----&gt;smax,umax,smin,umin vmlal--------&gt; smlal,smlal2,umlal,umlal2 vrshl--------&gt; urshl,srshl vtrn---------&gt; trn1,trn2 vstm/vstr----&gt; stp/str vld1.32 {d0[]}, [r0], r2-----&gt; ld1r {v0.S}[0], [x0], x2 addgt,addle,subgt,suble-----&gt;csel,csetm,cset,csinc,csinv</code></pre><p>更多可参考:<br><a href="https://www.element14.com/community/servlet/JiveServlet/previewBody/41836-102-1-229511/ARM.Reference_Manual.pdf" target="_blank" rel="noopener">https://www.element14.com/community/servlet/JiveServlet/previewBody/41836-102-1-229511/ARM.Reference_Manual.pdf</a></p><h2 id="8、资料文档查阅"><a href="#8、资料文档查阅" class="headerlink" title="8、资料文档查阅"></a>8、资料文档查阅</h2><p>&ensp; &ensp; 在进行arm64位汇编语言编写之前，建议首先阅读学习arm官方英文手册(<a href="https://static.docs.arm.com/ddi0487/ca/DDI0487C_a_armv8_arm.pdf）" target="_blank" rel="noopener">https://static.docs.arm.com/ddi0487/ca/DDI0487C_a_armv8_arm.pdf）</a> ，重点阅读C7 AArch64 neon指令部分以及C3 ARM指令部分，在了解了基本指令和arm64位汇编格式之后就可以尝试编写了。<br>&ensp; &ensp; 对于已有arm32位代码的情况下，从arm32位代码迁移到arm64时，可以参考(<a href="https://www.element14.com/community/servlet/JiveServlet/previewBody/41836-102-1-229511/ARM.Reference_Manual.pdf）" target="_blank" rel="noopener">https://www.element14.com/community/servlet/JiveServlet/previewBody/41836-102-1-229511/ARM.Reference_Manual.pdf）</a> 中 5.7.23小节的指令对照表。</p><p> &ensp; &ensp;  对于代码迁移方法，可以参考我的博客：<a href="https://blog.csdn.net/SoaringLee_fighting/article/details/82155608" target="_blank" rel="noopener">Some ways of Migrating code from ARM32 to AArch64</a>。</p><p>&ensp; &ensp; 对于快速查找指令，可以参考指令速查卡：<br><a href="https://courses.cs.washington.edu/courses/cse469/18wi/Materials/arm64.pdf" target="_blank" rel="noopener">https://courses.cs.washington.edu/courses/cse469/18wi/Materials/arm64.pdf</a></p><h2 id="9、优化经验总结（满满的干货）"><a href="#9、优化经验总结（满满的干货）" class="headerlink" title="9、优化经验总结（满满的干货）"></a>9、优化经验总结（满满的干货）</h2><ol><li>关于参数入栈和寄存器入栈<br>建议将入栈的参数取出之后，再对ARM寄存器或者NEON寄存器进行入栈。</li><li>尽量去除数据依赖 ，使指令并行<br> 不要将当前指令的目的寄存器作为下一条指令的源寄存器，尤其对于vmul指令，vmla指令。  不要将当前指令的目的寄存器作为下一条指令的源寄存器，尤其对于vmul指令，vmla指令。</li><li>尽量减少分支跳转<br> 可以采用条件执行指令或逻辑运算指令替代分支跳转，比如addgt,suble,vceq,vcge,vbit,vbsl等。</li><li>关注指令周期延迟<br>对于乘法指令，指令周期比较长，尽量不要立即使用指令计算结果，否则会等待耗时。</li><li>数据运算尽量在neon寄存器中，避免在arm寄存器和neon寄存器之间的运算。</li><li>尽量减少存取数据的次数。</li><li>尽量使用不需要保存的寄存器，寄存器出入栈很耗时。</li><li>对于宽度为4的倍数的情况下，尽量在宽度方向上处理，这样可以提高cache命中率。</li><li>使用尽量少的指令来编写代码，因为arm指令是精简指令，大部分指令都是单周期指令。</li><li>如果寄存器够用的话，尽量将一行的数据处理拆成两行或是四行来并行处理；尽量避免大数据之间的运算，可以将大数据的运算拆成小数据的运算。</li><li>减少循环判断和条件比较<br>在数据处理过程中，在循环判断或条件判断较多时，可以适当展开分支，可以在一定程度上提升性能。</li></ol><hr><h2 id="THE-END"><a href="#THE-END" class="headerlink" title=" THE END! "></a><font color="red"> THE END! </font></h2>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 优化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ARM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>arm32位和arm64位架构、寄存器和指令差异分析总结</title>
      <link href="/2018/08/18/%E3%80%90arm%E3%80%91arm32%E4%BD%8D%E5%92%8Carm64%E4%BD%8D%E6%9E%B6%E6%9E%84%E3%80%81%E5%AF%84%E5%AD%98%E5%99%A8%E5%92%8C%E6%8C%87%E4%BB%A4%E5%B7%AE%E5%BC%82%E5%88%86%E6%9E%90%E6%80%BB%E7%BB%93/"/>
      <url>/2018/08/18/%E3%80%90arm%E3%80%91arm32%E4%BD%8D%E5%92%8Carm64%E4%BD%8D%E6%9E%B6%E6%9E%84%E3%80%81%E5%AF%84%E5%AD%98%E5%99%A8%E5%92%8C%E6%8C%87%E4%BB%A4%E5%B7%AE%E5%BC%82%E5%88%86%E6%9E%90%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="1、参考"><a href="#1、参考" class="headerlink" title="1、参考"></a>1、参考</h2><p><a href="https://soaringleefighting.github.io/2018/08/18/%E3%80%90ARM%E7%B3%BB%E5%88%97%E3%80%91Some%20ways%20of%20Migrating%20code%20from%20ARM32%20to%20AArch64/">Some ways of Migrating code from ARM32 to AArch64</a><br><a href="https://soaringleefighting.github.io/2018/08/18/%E3%80%90arm%E3%80%91arm%E6%9E%B6%E6%9E%8432%E4%BD%8D%E6%B1%87%E7%BC%96%E4%BC%98%E5%8C%96%E6%80%BB%E7%BB%93/">arm架构32位汇编优化总结</a><br><a href="https://soaringleefighting.github.io/2018/08/18/%E3%80%90arm%E3%80%91arm%E6%9E%B6%E6%9E%8464%E4%BD%8D%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%EF%BC%9A%E6%9E%B6%E6%9E%84%E5%88%86%E6%9E%90%E3%80%81%E5%AF%84%E5%AD%98%E5%99%A8%E3%80%81%E8%B0%83%E7%94%A8%E8%A7%84%E5%88%99%E3%80%81%E6%8C%87%E4%BB%A4%E9%9B%86%E3%80%81%E7%A8%8B%E5%BA%8F%E8%B0%83%E8%AF%95%E4%BB%A5%E5%8F%8A%E5%8F%82%E8%80%83%E6%89%8B%E5%86%8C/">arm架构64位入门基础：架构分析、寄存器、调用规则、指令集、程序调试以及参考手册</a><br><a href="https://soaringleefighting.github.io/2018/08/18/%E3%80%90arm%E3%80%91arm%E6%9E%B6%E6%9E%8464%E4%BD%8D%EF%BC%88AArch64%EF%BC%89%E6%B1%87%E7%BC%96%E4%BC%98%E5%8C%96%E6%80%BB%E7%BB%93/">arm架构64位（AArch64）汇编优化总结</a></p><h2 id="2、前言"><a href="#2、前言" class="headerlink" title="2、前言"></a>2、前言</h2><p>&ensp;   最近三个月的时间，都在进行解码库的arm架构汇编优化，包括arm32位汇编优化和arm64位汇编优化。在arm32位入门之后，只要掌握了两种架构的寄存器和指令集差异之后，就可以很快上手编写arm64位汇编代码了。下面就arm32位和arm64位架构、寄存器和指令差异进行分析总结。</p><h2 id="3、架构差异"><a href="#3、架构差异" class="headerlink" title="3、架构差异"></a>3、架构差异</h2><p>&ensp;   ARM是RISC（精简指令集）处理器，不同于x86指令集（CISC,复杂指令集）。<br>&ensp;    Arm32位是<strong>ARMV7架构</strong>，32位的，对应处理器为Cortex-A15等； iphone5以前均是32位的；<br>需要注意：ARMV7-A和ARMV7-R系列支持neon指令集，ARMv7-M系列不支持neon指令集。<br>&ensp;  ARM64位采用<strong>ARMv8架构</strong>，64位操作长度，对应处理器有Cortex-A53、Cortex-A57、Cortex-A73、iphones的A7和A8等，苹果手机从iphone 5s开始使用64位的处理器。</p><h2 id="4、寄存器差异"><a href="#4、寄存器差异" class="headerlink" title="4、寄存器差异"></a>4、寄存器差异</h2><h3 id="4-1-ARM通用寄存器"><a href="#4-1-ARM通用寄存器" class="headerlink" title="4.1 ARM通用寄存器"></a>4.1 ARM通用寄存器</h3><p>ARM32位通用寄存器和ARM64位通用寄存器差异详见：<a href="https://blog.csdn.net/SoaringLee_fighting/article/details/81287824" target="_blank" rel="noopener">ARM寄存器及其说明</a></p><h3 id="4-2-NEON寄存器"><a href="#4-2-NEON寄存器" class="headerlink" title="4.2  NEON寄存器"></a>4.2  NEON寄存器</h3><p>ARM32位neon寄存器和ARM64位neon寄存器差异：</p><h4 id="4-2-1-32位下-NEON寄存器："><a href="#4-2-1-32位下-NEON寄存器：" class="headerlink" title="4.2.1 32位下 NEON寄存器："></a>4.2.1 <strong>32位下 NEON寄存器：</strong></h4><p>包括：</p><ul><li>32个S寄存器，S0~S31,（单字，32bit）</li><li>32个D寄存器，D0~D31，（双字，64bit）</li><li>16个Q寄存器，Q0~Q15，（四字，128bit）</li></ul><p><img src="/img/20180921160117517.png" alt="32位下 NEON寄存器"></p><blockquote><p>使用注意：<br>1、NEON寄存器将每个寄存器均视为一个向量，该向量又包含1，2，4，8或16个大小和类型均相同的元素。也可以将各个元素当做标量访问。<br><strong>NEON的这三种寄存器是重叠的，物理地址是一样的。</strong><br>2、NEON寄存器在使用时，如果用到d8~d15寄存器，需要先入栈保存vpush {d8-d15}，使用完之后要出栈vpop {d8-d15}。</p></blockquote><h4 id="4-2-2-64位下NEON寄存器："><a href="#4-2-2-64位下NEON寄存器：" class="headerlink" title="4.2.2 64位下NEON寄存器："></a>4.2.2 <strong>64位下NEON寄存器：</strong></h4><p>包括：</p><ul><li>32个B寄存器（B0~B31）,8bit</li><li>32个H寄存器（H0~H31）,半字 16bit</li><li>32个S寄存器（S0~S31）,单字 32bit</li><li>32个D寄存器（D0~D31）,双字 64bit</li><li>32个Q寄存器（V0~V31）,四字 128bit</li></ul><p>不同位数下寄存器之间的关系如下图所示：<br><img src="/img/20180822213447950.jpg" alt="不同位数下寄存器之间的关系"></p><p>其中S0是D0的低半部分，D0是V0的低半部分 。</p><blockquote><p>注意：<br>64位下NEON寄存器与32位下NEON寄存器之间的关系不同！<br>neon寄存器 v0~v31使用说明：<br>v0~v7:用于参数传递和返回值，子程序不需要保存；<br>v8~v15:子程序调用时必须入栈保存（低64位）；<br>v16~v31:子程序使用时不需要保存。<br>具体可参考：<br><a href="http://infocenter.arm.com/help/topic/com.arm.doc.ihi0055b/IHI0055B_aapcs64.pdf" target="_blank" rel="noopener">http://infocenter.arm.com/help/topic/com.arm.doc.ihi0055b/IHI0055B_aapcs64.pdf</a>  5.1.2 SIMD and Floating-Point Registers</p></blockquote><h2 id="5、A64指令集特有的指令及其用法（指令差异）"><a href="#5、A64指令集特有的指令及其用法（指令差异）" class="headerlink" title="5、A64指令集特有的指令及其用法（指令差异）"></a>5、A64指令集特有的指令及其用法（指令差异）</h2><p>AARCH64是全新32位固定长度指令集，支持64位操作数的新指令，大多数指令可以具有32位或64位参数。</p><ul><li><p>32位neon指令都是以V开头，而64位neon指令没有V;</p></li><li><p>32位寄存器需要保存的是r4~r11，q4~q7，而64位寄存器需要保存的是x19~x29 , v8~v15；</p></li><li><p>64位下NEON寄存器与32位下NEON寄存器之间的关系不同，32位下d寄存器和q寄存器是重叠映射的，而64下的d寄存器和v寄存器是一一对应的，具体详见4.1；</p></li><li><p>向64位或者更低位的矢量寄存器中写数据时，会将高位置零；</p></li><li><p>在AArch64中，没有通用寄存器的SIMD和饱和算法指令。只有neon寄存器才有SIMD或饱和算法指令；</p></li><li><p>ARM64下没有swap指令和条件执行指令。</p></li><li><p>关于指令中立即数取值范围的说明：</p><p>不同指令中的#&lt;imm&gt;或者#&lt;const&gt;具有不同的取值范围，这个取决于所使用的指令，比如：</p><pre><code>mov        &lt;wd&gt;, #&lt;imm&gt;  //该指令中立即数范围为-65536~65535。cmp        &lt;wn&gt;, #&lt;imm&gt;  //该指令中#&lt;imm&gt;为无符号立即数，取值范围为0~4095（12 bit）。</code></pre><blockquote><p>特别说明：大部分ARM指令中的立即数不能是负数，需要注意不同指令的取值范围。</p></blockquote></li><li><p>更多ARM32和ARM64位对应关系可以参考文档： <a href="https://www.element14.com/community/servlet/JiveServlet/previewBody/41836-102-1-229511/ARM.Reference_Manual.pdf" target="_blank" rel="noopener">ARM.Reference_Manual</a>中5.7.23小节 。</p></li></ul><h3 id="5-1-shl和ushr指令"><a href="#5-1-shl和ushr指令" class="headerlink" title="5.1.  shl和ushr指令"></a>5.1.  shl和ushr指令</h3><pre><code>    shl  &lt;V&gt;.&lt;d&gt;, &lt;V&gt;.&lt;n&gt;, #&lt;shift&gt;    ushr  &lt;V&gt;.&lt;d&gt;, &lt;V&gt;.&lt;n&gt;, #&lt;shift&gt;    ushr  d2， d2,  #8</code></pre><p>使用注意事项：这两条指令只能操作64位数据，即只能对D寄存器进行处理。<br>ushr最多只能进行64位数据的右移，并且右移时会影响V2寄存器的高64位数据（清零），因此高64位数据需要在右移前保存，否则相关数据会被修改。</p><h3 id="5-2-INS指令"><a href="#5-2-INS指令" class="headerlink" title="5.2. INS指令"></a>5.2. INS指令</h3><p>用法与MOV指令基本一样,可以实现neon标量与neon标量之间的传送,以及ARM寄存器与neon标量之间的传送。</p><pre><code>INS   &lt;Vd&gt;.&lt;Ts&gt;[index1], &lt;Vn&gt;.&lt;Ts&gt;[index2]INS   &lt;Vd&gt;.&lt;Ts&gt;[index1], Rn</code></pre><h3 id="5-3-SUQADD、USQADD指令"><a href="#5-3-SUQADD、USQADD指令" class="headerlink" title="5.3. SUQADD、USQADD指令"></a>5.3. SUQADD、USQADD指令</h3><p>既有标量用法,也有矢量用法。</p><pre><code>SUQADD &lt;V&gt;&lt;d&gt;, &lt;V&gt;&lt;d&gt;     // signed saturating accumulate of unsigned valueSUQADD &lt;Vd&gt;.&lt;T&gt;, &lt;Vn&gt;.&lt;T&gt;USQADD &lt;V&gt;&lt;d&gt;, &lt;V&gt;&lt;d&gt;    // unsigned saturating accumulate of signed valueUSQADD &lt;Vd&gt;.&lt;T&gt;, &lt;Vn&gt;.&lt;T&gt;</code></pre><h3 id="5-4-RBIT、REV指令"><a href="#5-4-RBIT、REV指令" class="headerlink" title="5.4. RBIT、REV指令"></a>5.4. RBIT、REV指令</h3><pre><code> RBIT &lt;Wd&gt;, &lt;Wn&gt; //reverse bits REV &lt;Wd&gt;, &lt;Wn&gt;  //reverse bytes</code></pre><h3 id="5-5-ADDV-SADDLV-SMAXV-SMINV-Vector-Reduce（across-lanes）"><a href="#5-5-ADDV-SADDLV-SMAXV-SMINV-Vector-Reduce（across-lanes）" class="headerlink" title="5.5. ADDV,SADDLV,SMAXV,SMINV (Vector Reduce（across lanes）)"></a>5.5. ADDV,SADDLV,SMAXV,SMINV (Vector Reduce（across lanes）)</h3><p>后缀带V指令：</p><pre><code>ADDV &lt;V&gt;&lt;d&gt;, &lt;Vn&gt;&lt;T&gt;    // Integer sum element to scalar(vector)SADDLV &lt;V&gt;&lt;d&gt;, &lt;Vn&gt;&lt;T&gt;  // Signed Interger sum elements to long scalar(vector)SMAXV &lt;V&gt;&lt;d&gt;, &lt;Vn&gt;&lt;T&gt;   // Signed Interger maximum elements to scalar(vector)SMINV &lt;V&gt;&lt;d&gt;, &lt;Vn&gt;&lt;T&gt;   // Signed Interger minimum elements to scalar(vector)eg.:addv B0, v1.8B            // 将v1寄存器中的低64位中8个8位数据相加求和后，赋给v0的最低8位。addv H2, v1.8B            // 将v1寄存器中的低64位中8个字节依次相加求和，并将结果赋给v1第2个16位标量中。</code></pre><blockquote><p>用法说明：<br>vector reduce instrunctions perform arithmetic  operations horizontally, that is  across all lanes  of the input  vector. they deliver a single scalar result.  对矢量中每个元素进行水平方向的算术运算，并产生一个标量结果。</p></blockquote><p>更多详细解释可以参考：<a href="https://static.docs.arm.com/ddi0487/a/DDI0487A_j_armv8_arm.pdf" target="_blank" rel="noopener">https://static.docs.arm.com/ddi0487/a/DDI0487A_j_armv8_arm.pdf</a><br><img src="/img/20180914155719641.jpg" alt="Vector Reduce（across lanes）"></p><h3 id="5-6-sxtw使用注意事项"><a href="#5-6-sxtw使用注意事项" class="headerlink" title="5.6. sxtw使用注意事项"></a>5.6. sxtw使用注意事项</h3><p>负数在使用时必须进行符号扩展！<br>比如：</p><pre><code>sxtw   x4, w4</code></pre><h3 id="5-7-w寄存器到v寄存器"><a href="#5-7-w寄存器到v寄存器" class="headerlink" title="5.7. w寄存器到v寄存器"></a>5.7. w寄存器到v寄存器</h3><p>直接使用dup指令</p><pre><code>dup        v0.8B,  w2</code></pre><h3 id="5-8-常用指令对应关系-arm32—-gt-arm64"><a href="#5-8-常用指令对应关系-arm32—-gt-arm64" class="headerlink" title="5.8.常用指令对应关系(arm32—-&gt;arm64)"></a>5.8.常用指令对应关系(arm32—-&gt;arm64)</h3><pre><code> vmovl------&gt;uxtl/sxtl vqmovn-----&gt;sqxtn vqmovun-----&gt;sqxtun vqrshrun----&gt;sqrshrun vceq-------&gt;cmeq vcge-------&gt;cmge vadd------&gt;add vsub------&gt;sub vaddl-----&gt;saddl,uaddl vaddw-----&gt;saddw,uaddw,sw2addw2,uadd vmull-----&gt;smull,smull2,umull,umull2 vmax,vmin-----&gt;smax,umax,smin,umin vmlal--------&gt; smlal,smlal2,umlal,umlal2 vrshl--------&gt; urshl,srshl vtrn---------&gt; trn1,trn2 vstm/vstr----&gt; stp/str vld1.32 {d0[]}, [r0], r2-----&gt; ld1r {v0.S}[0], [x0], x2 addgt,addle,subgt,suble-----&gt;csel,csetm,cset,csinc,csinv</code></pre><p>更多可参考:<br><a href="https://www.element14.com/community/servlet/JiveServlet/previewBody/41836-102-1-229511/ARM.Reference_Manual.pdf" target="_blank" rel="noopener">https://www.element14.com/community/servlet/JiveServlet/previewBody/41836-102-1-229511/ARM.Reference_Manual.pdf</a></p><h3 id="5-9-指令结尾带“2”的寄存器高64位操作："><a href="#5-9-指令结尾带“2”的寄存器高64位操作：" class="headerlink" title="5.9. 指令结尾带“2”的寄存器高64位操作："></a>5.9. 指令结尾带“2”的寄存器高64位操作：</h3><pre><code> smull2 v0.4S,    v1.4H, v2.4H //将v1和v2高64位中每一个16位相乘，并将结果放在v0的每个32位中。 sqxtn2  v5.8H, v4.4S  //将v4中的每个32位元素，饱和缩进到v5高64位的每个16位中。 sxtl2  v16.4S, v17.4H //将v17高64位中的每个16位元素，扩展到v16的每个32位元素中。</code></pre><h3 id="5-10-ADDP，SMAXP，SMINP，UMAXP，UMINP"><a href="#5-10-ADDP，SMAXP，SMINP，UMAXP，UMINP" class="headerlink" title="5.10. ADDP，SMAXP，SMINP，UMAXP，UMINP"></a>5.10. ADDP，SMAXP，SMINP，UMAXP，UMINP</h3><p>后缀带P指令：</p><pre><code>addp  v1.8B, v2.8B, v3.8B   // add pairwise</code></pre><blockquote><p>用法说明：<br>the SIMD pairwise arthmetic instructions perform operations on pairs of adjacent element and deliver a  vector result.  对矢量中的相邻元素两两进行算术运算，并产生一个矢量结果。</p></blockquote><h3 id="5-11-替代arm32下条件执行指令的arm64位指令："><a href="#5-11-替代arm32下条件执行指令的arm64位指令：" class="headerlink" title="5.11. 替代arm32下条件执行指令的arm64位指令："></a>5.11. 替代arm32下条件执行指令的arm64位指令：</h3><p>arm32位：</p><pre><code>    bgt，addgt,suble等</code></pre><p>arm64位：</p><pre><code>   b.gt，csinc, csel, cset, csetm,  csnev</code></pre><p>说明： 在ARM64下没有条件执行指令。</p><h2 id="6、AArch32与AArch64的区别"><a href="#6、AArch32与AArch64的区别" class="headerlink" title="6、AArch32与AArch64的区别"></a>6、AArch32与AArch64的区别</h2><h3 id="6-1-入栈和出栈："><a href="#6-1-入栈和出栈：" class="headerlink" title="6.1 入栈和出栈："></a>6.1 入栈和出栈：</h3><p><em>arm64位（aarch64架构）：</em><br>（1）arm寄存器入栈和出栈：</p><pre><code>入栈：    sub  sp, sp, #0x10    stp  x8, x9, [sp] // 寄存器成对入栈出栈：    ldp  x8,  x9, [sp]    add  sp,  sp, #0x10 //寄存器成对出栈</code></pre><p>原则：1、堆栈入栈和出栈后，SP指针应该保持不变（栈平衡）。2、LIFO。 3、特别注意是，从SP位置存取数据都是从低地址开始的。<br>（2）neon寄存器入栈和出栈：<br><strong>ARM64位三种入栈出栈方法：</strong><br>方法一：</p><pre><code>stp        d8,d9,     [sp,    #-64]!stp        d10,d11,[sp,    #16]!stp        d12,d13,[sp,    #16]!stp        d14,d15,[sp,    #16]!ldp        d14,d15,[sp],    #-16ldp        d12,d13,[sp],    #-16ldp        d10,d11,[sp],    #-16ldp        d8,d9,[sp],        #64        //恢复sp位置</code></pre><p>方法二：</p><pre><code>stp        d8,d9,     [sp,    #-16]!stp        d10,d11,[sp,    #-16]!stp        d12,d13,[sp,    #-16]!stp        d14,d15,[sp,    #-16]!ldp        d14,d15,[sp],    #16ldp        d12,d13,[sp],    #16ldp        d10,d11,[sp],    #16ldp        d8,d9,[sp],        #16        //恢复sp位置</code></pre><p>方法三：</p><pre><code>.macro push_v_regs    stp    d8,  d9,  [sp, #-16]!    stp    d10, d11, [sp, #-16]!    stp    d12, d13, [sp, #-16]!    stp    d14, d15, [sp, #-16]!.endm.macro pop_v_regs    ldp    d14, d15, [sp], #16    ldp    d12, d13, [sp], #16    ldp    d10, d11, [sp], #16    ldp    d8,  d9,  [sp], #16.endm</code></pre><p><em>arm32位：</em></p><pre><code>push    {r4-r11,  lr}vpush    {d8-d15}vpop    {d8-d15}pop        {r4-r11,  pc}</code></pre><h3 id="6-2-4x4矩阵转置："><a href="#6-2-4x4矩阵转置：" class="headerlink" title="6.2  4x4矩阵转置："></a>6.2  4x4矩阵转置：</h3><p><em>arm64位（aarch64架构）：</em></p><pre><code>.macro transpose4x4B  r0,r1,r2,r3,t4,t5,t6,t7trn1    \t4\().8B,    \r0\().8B,    \r1\().8Btrn2    \t5\().8B,    \r0\().8B,    \r1\().8Btrn1    \t6\().8B,    \r2\().8B,    \r3\().8Btrn2    \t7\().8B,    \r2\().8B,    \r3\().8Btrn1    \r0\().8B,    \t4\().8B,    \t6\().8Btrn1    \r1\().8B,    \t5\().8B,    \t7\().8Btrn2    \r2\().8B,    \t4\().8B,    \t6\().8Btrn3    \r3\().8B,    \t5\().8B,    \t7\().8B.endm</code></pre><p><em>arm32位：</em></p><pre><code>vtrn.16 q0,    q1vtrn.8    d0,    d1vtrn.8    d2,    d3</code></pre><h3 id="6-3-Difference-between-AArch64-and-AArch32"><a href="#6-3-Difference-between-AArch64-and-AArch32" class="headerlink" title="6.3  Difference between AArch64 and AArch32"></a>6.3  Difference between AArch64 and AArch32</h3><p>来源参考：<a href="https://www.nxp.com/docs/en/application-note/AN12212.pdf" target="_blank" rel="noopener">https://www.nxp.com/docs/en/application-note/AN12212.pdf</a></p><h3 id="6-4-加载数据和存储数据差异"><a href="#6-4-加载数据和存储数据差异" class="headerlink" title="6.4  加载数据和存储数据差异"></a>6.4  加载数据和存储数据差异</h3><p><strong>ARM32位存取数据的格式：</strong><br>vld1加载和vst1存储：</p><pre><code>vld1.8 {d0,d1} , [r1], r2  // 将r1地址里面的连续的128bits数据依次赋给d0和d1，然后r1+r2。这里的.8表示以8bit为单位。vld1.16 {d0[],d1[]}, [r0:16] //这里d0和d1中的数据相同，将地址r0中取4个16位数据加载到d0和d1中。vst1.8  {d0,d1}, [r2], r3  //将d0和d1中32个bytes数据存储到r2地址处。</code></pre><p><strong>ARM64位存取数据的格式：</strong></p><pre><code>ld1 {v20.8H, v21.8H}, [x1]  // 从x1指向的存储单元位置一次性加载128*2位数据到v20和v21中ld1 {v1.8B},    [x1],    x2  // 从x1指向的存储单元位置加载64位数据到v1的低64位中，然后x1=x1+x2ld1    {v18.S}[0],    [x0],    x1  // 将x0地址里面的数据取32位加载到v18的最低32位，然后x0=x0+x1ld1r {v30.8H},    [x1]        // 从x1地址中以16位为单位取128位加载到v30中。st1    {v30.8H},    [x1],    #16    // 将 寄存器v30中128位数据存储到x1地址处，然后x1=x1+16st1    {v0.S}[0],    [x0],    x2    // 将 寄存器v0的低32位数据存储到x0地址处吗，然后x0=x0+x2</code></pre><h3 id="6-5-补充知识"><a href="#6-5-补充知识" class="headerlink" title="6.5 补充知识"></a>6.5 补充知识</h3><ol><li>关于调用规则和SP<br>ARM32位的调用规则遵循ATPCS(The ARM-THUMB Procedure Call Standarfd)调用规则，从2007年开始ARM公司正式推出AAPCS(Procedure Call Standard for the ARM Architecture)标准，是ATPCS的改进版，目前两者都是可用的标准。<br>AAPCS调用规则规定，栈任何时候必须4字节对齐，在调用入口需8字节对齐。<br>ARM64位下，SP在公共接口或访问内存时均必须保证16字节对齐，这是硬件要求的。</li><li>指令编码长度<br>不管是aarch32还是aarch64，指令在arm指令集模式下，指令固定编码长度为32bit。</li><li>获取标签地址的方法<br>arm32位下可以使用adr指令、adrl(伪指令)和ldr指令获取标签地址，需要注意使用adr、adrl指令的标签要在同一代码节中，ldr可以在不同节中。<br>arm64位下，可以使用adr和adrp采用相对寻址的方式来实现，64位下不支持伪指令adrl。</li><li>EL0没有权限进行AArch64和AArch32状态切换。因此A64指令无法切换到A32和T16指令。因此ARM64位指令无法在ARM32位设备上运行。<br>疑问： Android 64位指令可以在32位设备上运行？</li><li>关于PC<br>ARM32位下：PC=当前指令地址+8，具体跟arm处理器多级流水线机制相关，不可用作通用寄存器。<br>ARM64位下：PC不能直接访问，但可以通过伪指令间接使用。需要注意的是：与32位不同的是，64位下当通过指令读取PC相对地址时，其值即为当前指令的地址。<br>(1). 64位可读取PC值的情况有：<br>计算相对地址，如adr，adrp，文字池加载以及直接分支；<br>子程序返回地址，比如bl，blr<br>(2). 可修改pc的方式为：<br>使用控制流指令，如条件跳转、无条件跳转、异常生成和异常返回指令。</li></ol><h2 id="THE-END"><a href="#THE-END" class="headerlink" title="THE END! "></a><font color="red"><strong>THE END!</strong> </font></h2>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 优化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ARM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ARM架构32位汇编优化总结</title>
      <link href="/2018/08/18/%E3%80%90arm%E3%80%91arm%E6%9E%B6%E6%9E%8432%E4%BD%8D%E6%B1%87%E7%BC%96%E4%BC%98%E5%8C%96%E6%80%BB%E7%BB%93/"/>
      <url>/2018/08/18/%E3%80%90arm%E3%80%91arm%E6%9E%B6%E6%9E%8432%E4%BD%8D%E6%B1%87%E7%BC%96%E4%BC%98%E5%8C%96%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="1、参考"><a href="#1、参考" class="headerlink" title="1、参考"></a>1、参考</h2><p><a href="https://blog.csdn.net/SoaringLee_fighting/article/details/80764811" target="_blank" rel="noopener">【arm】arm优化基本知识（寄存器、指令集、调用规则以及汇编格式）</a><br><a href="https://blog.csdn.net/SoaringLee_fighting/article/details/81287824" target="_blank" rel="noopener">【arm】ARM寄存器以及使用说明</a><br><a href="https://blog.csdn.net/SoaringLee_fighting/article/details/81058147" target="_blank" rel="noopener">【arm】arm的汇编指令及特点</a><br><a href="https://blog.csdn.net/SoaringLee_fighting/article/details/80770034" target="_blank" rel="noopener">【Optimization】ARM的寻址方式（详细）</a><br><a href="http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.den0018a/index.html" target="_blank" rel="noopener">ARM Center Information</a></p><h2 id="2、Arm汇编架构和Reference-Manuals"><a href="#2、Arm汇编架构和Reference-Manuals" class="headerlink" title="2、Arm汇编架构和Reference Manuals"></a>2、Arm汇编架构和Reference Manuals</h2><p>ARM是RISC（精简指令集）处理器，不同于x86指令集（CISC,复杂指令集）。<br>Arm32位是ARMV7架构，32位的，对应处理器为Cortex-A15；<br>iphone5以前均是32位的；<br>需要注意：ARMV7-A和ARMV7-R系列支持neon指令集，ARMv7-M系列不支持neon指令集。</p><p><strong><em>ARMV7架构A和R系列参考手册下载地址：</em></strong><br><a href="https://static.docs.arm.com/ddi0406/cd/DDI0406C_d_armv7ar_arm.pdf" target="_blank" rel="noopener">https://static.docs.arm.com/ddi0406/cd/DDI0406C_d_armv7ar_arm.pdf</a></p><p>Arm64位是ARMV8架构，64位的，对应处理器有Cortex-A53、Cortex-A57、iphone5s的A7、iphone6的A8等。<br><strong><em>ARMV8架构参考手册下载地址：</em></strong><br><a href="https://developer.arm.com/docs/ddi0487/latest/arm-architecture-reference-manual-armv8-for-armv8-a-architecture-profile" target="_blank" rel="noopener">https://developer.arm.com/docs/ddi0487/latest/arm-architecture-reference-manual-armv8-for-armv8-a-architecture-profile</a><br><a href="https://static.docs.arm.com/ddi0487/ca/DDI0487C_a_armv8_arm.pdf" target="_blank" rel="noopener">https://static.docs.arm.com/ddi0487/ca/DDI0487C_a_armv8_arm.pdf</a><br><strong><em>所有ARM参考文档地址：</em></strong><br><a href="https://developer.arm.com/docs" target="_blank" rel="noopener">https://developer.arm.com/docs</a><br><a href="http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.ddi0403e.b/index.html" target="_blank" rel="noopener">http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.ddi0403e.b/index.html</a></p><p><strong><em>中文手册：</em></strong><br><a href="https://developer.arm.com/products/software-development-tools/compilers/arm-compiler-5/docs/dui0529/j/overview-of-arm-compiler/about-the-toolchain-documentation" target="_blank" rel="noopener">https://developer.arm.com/products/software-development-tools/compilers/arm-compiler-5/docs/dui0529/j/overview-of-arm-compiler/about-the-toolchain-documentation</a></p><h2 id="3、Arm32位寄存器"><a href="#3、Arm32位寄存器" class="headerlink" title="3、Arm32位寄存器"></a>3、Arm32位寄存器</h2><p>主要分为ARM寄存器和NEON寄存器。<br>ARM32寄存器包括15个通用寄存器R0~R14和一个程序计数器PC，共16个，均为32位宽。<br>ARM32位寄存器的调用规则：遵循ATPCS调用规则，详细参见<br><a href="https://blog.csdn.net/SoaringLee_fighting/article/details/81287824" target="_blank" rel="noopener">https://blog.csdn.net/SoaringLee_fighting/article/details/81287824</a></p><p>32位 NEON寄存器：<br>包括：32个S寄存器，S0~S31,（单字，32bit）<br>         32个D寄存器，D0~D31，（双字，64bit）<br>         16个Q寄存器，Q0~Q15，（四字，128bit）</p><p>寄存器的对应关系如下图所示：<br><img src="/img/20180818125854882.jpg" alt="32位NEON寄存器"></p><blockquote><p>使用注意：<br>1、NEON寄存器将每个寄存器均视为一个向量，该向量又包含1，2，4，8或16个大小和类型均相同的元素。也可以将各个元素当做标量访问。<br>NEON的这三种寄存器是重叠的，物理地址是一样的。<br>2、NEON寄存器在使用时，如果用到d8~d15寄存器，需要先入栈保存vpush {d8-d15}，使用完之后要出栈vpop {d8-d15}</p></blockquote><h2 id="4、ARM指令寻址方式"><a href="#4、ARM指令寻址方式" class="headerlink" title="4、ARM指令寻址方式"></a>4、ARM指令寻址方式</h2><p>ARM指令集的寻址方式与x86指令集大部分相同，但也有其特有的寻址方式，比如寄存器偏移寻址，多寄存器寻址和堆栈寻址。<br>ARM指令共有9种寻址方式，具体参见：<br><a href="https://blog.csdn.net/SoaringLee_fighting/article/details/80770034" target="_blank" rel="noopener">https://blog.csdn.net/SoaringLee_fighting/article/details/80770034</a></p><h2 id="5、ARM指令特点以及优化技巧"><a href="#5、ARM指令特点以及优化技巧" class="headerlink" title="5、ARM指令特点以及优化技巧"></a>5、ARM指令特点以及优化技巧</h2><p><strong>ARM汇编特点1：LDR/STR架构</strong><br>ARM采用RISC架构，CPU本身不能直接读取内存，而需要先将内存中内容加载入CPU中通用寄存器中才能被CPU处理。<br>ldr（load register）指令将内存内容加载入通用寄存器。<br>str（store register）指令将寄存器内容存入内存空间中。<br>ldr/str组合用来实现 ARM CPU和内存数据交换。</p><p><strong>ARM汇编特点2：指令后缀</strong><br>同一指令经常附带不同后缀，变成不同的指令。经常使用的后缀有：<br>B（byte）功能不变，操作长度变为8位<br>H（half word）功能不变，长度变为16位<br>S（signed）功能不变，操作数变为有符号<br>如 ldr ldrb ldrh ldrsb ldrsh<br>S（S标志）功能不变，影响CPSR标志位<br>W（宽型）<br>L（长型）<br>N（窄型）<br>S（饱和）<br>Q（舍入取整）</p><p><strong>ARM汇编特点3：条件执行</strong><br>subgt,addle等，只有在上一条指令执行之后相应标志位满足条件之后，当前指令才会执行，通过使用条件执行指令可以减少分支跳转。</p><p><strong>ARM汇编特点4：多级流水线技术</strong><br>ARM7处理器（对应架构armv3或armv4）采用<strong>3级流水线</strong>的冯·诺伊曼结构；而ARM9（对应架构armv4或armv5）用<strong>5级流水线</strong>的哈佛结构，ARM11（对应架构armv6）为<strong>8级流水线</strong>哈佛结构(从arm9开始都采用了哈佛结构)。增加的流水线设计提高了时钟频率和并行处理能力。5级流水线能够将每一个指令处理分配到5个时钟周期内，在每一个时钟周期内同时有5个指令在执行。在常用的芯片生产工艺下，ARM7一般运行在100MHz左右，而ARM9则至少在200MHz以上.ARM11首先推出350M~500MHz时钟频率的内核，目前上升到1GHz时钟频率。<br>参考：<a href="https://blog.csdn.net/SoaringLee_fighting/article/details/81411760" target="_blank" rel="noopener">arm】ARM流水线技术与指令使用建议</a></p><p><strong>ARM NEON优化技巧总结</strong>，参见：<br><a href="https://blog.csdn.net/SoaringLee_fighting/article/details/81265865" target="_blank" rel="noopener">【arm】arm neon 优化技巧</a><br><a href="https://blog.csdn.net/SoaringLee_fighting/article/details/81705311" target="_blank" rel="noopener">【arm】arm通用指令及优化技巧</a></p><h2 id="6、ARM和NEON指令集-常用指令汇总"><a href="#6、ARM和NEON指令集-常用指令汇总" class="headerlink" title="6、ARM和NEON指令集 常用指令汇总"></a>6、ARM和NEON指令集 常用指令汇总</h2><p>ARM指令集：32位，工作在ARM模式下。<br>Thumb指令集：16位，工作在Thumb模式下。<br>NEON指令集：以v开头，基于ARMv7架构的SIMD和向量浮点VFPv3指令集。<br>ARM算术指令：</p><pre><code>add, adc, sub, subs, rsb, mul, udiv等</code></pre><p>ARM移位指令：</p><pre><code>lsl, lsr, ror，asr等</code></pre><p>ARM饱和指令：</p><pre><code>ssat, usat,qadd,qsub</code></pre><p>ARM逻辑运算指令：</p><pre><code>orr，and，orn，eor</code></pre><p>NEON逻辑运算和比较指令：</p><pre><code>vand，vorr, vbic, vornvbif，bsl，vbitvmov，vmvnvceq，vcge，vcgt，vcle，vcltvtst</code></pre><p>NEON移位指令：</p><pre><code>vshr，vshl，vqshl，vqrshrunvsli，vsri</code></pre><p>NEON通用算术指令：</p><pre><code>vabs，vabd，vneg， vadd，vsub，vqadd，vqsub，vaddl，vaddw，vsubl，vsubwvaddhn，vsubhnvhadd，vhsubvpadd，vpadalvmax，vmin，vpmax，vpmin</code></pre><p>NEON乘法指令：</p><pre><code>vmul，vmla，vmls</code></pre><p>vext指令：向量提取</p><pre><code>vext.8        d2,    d0, d1, #3</code></pre><blockquote><p>说明：取d1寄存器中低3位向量作为高位，d0寄存器的高5位向量作为低位，构成目标向量。</p></blockquote><p>asr和lsr的区别：</p><pre><code>asr  r0， r1, #5  //算术右移，符号位填充左侧空出的位lsr   r0,     r1, #5 //逻辑右移，0填充左侧空出的位</code></pre><p>vpadd：向量按对加</p><p>vceq,vcgt,vcge, vcle,vclt指令:</p><blockquote><p>向量比较，获取向量中每个元素的值，并将其与另一个向量重相应元素或零进行比较。如果条件为真，则将目标向量中的全部元素设置为1，否则设置为0。</p></blockquote><p>vrshr指令：舍入右移 ，可以实现（a+(1&lt;&lt;(b-1))）&gt;&gt;b的操作。</p><p>vaddl和vaddw指令：加法长指令、加法宽指令</p><p>vqmovun指令：有无符号操作数，无符号结果</p><pre><code>vqmovun.s16        d0,  q0</code></pre><blockquote><p>说明： 将q0中每个16位有符号向量饱和到d0中每个8位无符号向量。</p></blockquote><h2 id="7、Arm32位加载数据的两种格式"><a href="#7、Arm32位加载数据的两种格式" class="headerlink" title="7、Arm32位加载数据的两种格式"></a>7、Arm32位加载数据的两种格式</h2><p>1）、vld1加载：</p><pre><code>vld1.8 {d0,d1} , [r1], r2</code></pre><p>说明： 将r1地址里面的连续的128bits数据依次赋给d0和d1，然后r1+r2。这里的.8表示以8bit为单位。<br>2）、</p><pre><code>vld1.16 {d0[],d1[]}, [r0:16]</code></pre><p>说明：这里d0和d1中的数据相同，将地址r0中取4个16位数据加载到d0和d1中。</p><h2 id="8、Arm32位汇编编写demo"><a href="#8、Arm32位汇编编写demo" class="headerlink" title="8、Arm32位汇编编写demo"></a>8、Arm32位汇编编写demo</h2><p><a href="https://blog.csdn.net/SoaringLee_fighting/article/details/81150083" target="_blank" rel="noopener">【arm】arm32汇编编写示例demo</a></p><p>ARM汇编格式主要有两种，arm asm汇编格式和gnu asm汇编格式。<br>gnu asm汇编格式：</p><pre><code>    .arm    .text    .align  4    .global     name    .type       %functionname:     FUNCTION STATEMENT  @注释行     /* 多行注释 */     //单行注释，用于.S汇编文件     bx lr</code></pre><p>arm asm汇编格式：</p><pre><code>EXPORT |name|ARMAREA ||.text||, CODE, READONLY,ALIGN=2|name| PROC  ;注释ENDPEND</code></pre><h2 id="9、注意事项"><a href="#9、注意事项" class="headerlink" title="9、注意事项"></a>9、注意事项</h2><p>1）标签名称不能以数字开始，但是可以使用纯数字的局部标签。<br>2）ld1连续存储数据时，所用的寄存器必须是连续的。<br>3）Arm32位下数据在不同寄存器之间转换：<br>从r寄存器到d寄存器：</p><pre><code>vmov        d0, r0, r1vmov.u32    d0[0], r1</code></pre><p>从d寄存器到r寄存器：</p><pre><code>vmov        r0, r1, d0vmov.u32    r1,    d0[0]</code></pre><p>从标量寄存器d[x]到矢量寄存器d：</p><pre><code>vdup.16        d1,     d6[0]vdup.16        d1, r12</code></pre><p>4）Arm32位下替代判断的命令：<br>vceq，vbsl，vbit， vbif</p><p>5）Arm32下取数据地址问题<br>arm下默认地址r0加1，是加一个字节，如果r0对应的数据是int类型的，则取idx位置的数据则为：r0+idx*4</p><h2 id="10、汇编优化基本准则"><a href="#10、汇编优化基本准则" class="headerlink" title="10、汇编优化基本准则"></a>10、汇编优化基本准则</h2><h3 id="10-1-C代码优化"><a href="#10-1-C代码优化" class="headerlink" title="10.1 C代码优化"></a>10.1 C代码优化</h3><ul><li>减少计算量，将重复计算的部分提取出来；</li><li>深入剖析C代码的实现原理，更改结构，把可以合并的代码进行合并，简化计算，减少分支判断。</li></ul><h3 id="10-2-汇编代码优化"><a href="#10-2-汇编代码优化" class="headerlink" title="10.2 汇编代码优化"></a>10.2 汇编代码优化</h3><ul><li>精简指令，大部分arm指令都是单周期指令，尽量使用较少的指令编写代码；</li><li>减少寄存器之间的依赖，充分利用多级流水线，使指令并行执行；</li><li>对于乘法指令，指令周期比较长，尽量不要立即使用指令计算结果，否则会等待耗时；</li><li>尽量将数据都存放在neon寄存器中；</li><li>尽量减少存取数据的次数。</li></ul><h2 id="11、ARM程序调试"><a href="#11、ARM程序调试" class="headerlink" title="11、ARM程序调试"></a>11、ARM程序调试</h2><p>下面是最基本的方法：</p><p>汇编文件中添加如下宏代码：</p><pre><code>.macro print_m in1=r0, in2=d0       push {r0-r3, lr}       vstl.u64       {\in2\()}, [\in1\()]       mov     r0, \in1       bl cprintf       pop {r0-r3, pc}.endm</code></pre><p>C文件中添加cprintf实现代码：</p><pre><code>void cprintf(unsigned char *srcu8){  int i=0;  char *srcs8 = (char *)srcu8;  for(i=0; i &lt; 16; i++){       printf(&quot;%d &quot;, srcu8[i])  }  for(i=0; i &lt; 16; i++){      printf(&quot;%d &quot;, srcs8[i])  }  printf(&quot;\n&quot;);}</code></pre><p>关于arm寄存器的打印调试方法，参见：<br><a href="https://blog.csdn.net/SoaringLee_fighting/article/details/80834098" target="_blank" rel="noopener">【arm】arm-assembly-print-register-value-in-decimal</a></p><p>除了上述基本方法以外，可以借助RVDS或GDB软件进行调试。</p><blockquote><p>注意事项：<br>1、RVDS只能用于ARM32位调试，ARMV8架构不支持RVDS。<br>2、采用GDB调试的前提是ARM开发板上已经安装好了GDB，采用GDB进行调试是很方便的。</p></blockquote><hr><h2 id="THE-END"><a href="#THE-END" class="headerlink" title=" THE END! "></a><font color="red"> <strong>THE END!</strong> </font></h2>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 优化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ARM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ARM汇编优化常见问题汇总</title>
      <link href="/2018/08/18/%E3%80%90ARM%E7%B3%BB%E5%88%97%E3%80%91ARM%E6%B1%87%E7%BC%96%E4%BC%98%E5%8C%96%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB/"/>
      <url>/2018/08/18/%E3%80%90ARM%E7%B3%BB%E5%88%97%E3%80%91ARM%E6%B1%87%E7%BC%96%E4%BC%98%E5%8C%96%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在编写ARM32和ARM64汇编优化代码时，常常由于指令使用导致产生一些bug，在此汇总遇到的常见问题，记录于此以备忘。</p><h2 id="1、有符号和无符号引入的问题"><a href="#1、有符号和无符号引入的问题" class="headerlink" title="1、有符号和无符号引入的问题"></a>1、有符号和无符号引入的问题</h2><p>在从ARM32位代码移植到ARM64位时（参考我的博文<a href="https://blog.csdn.net/SoaringLee_fighting/article/details/82155608" target="_blank" rel="noopener">【arm】Some ways of Migrating code from ARM32 to AArch64</a>），遇到如下问题：</p><p>在ARM32位代码中使用vcgt比较两个d寄存器的值，如下</p><pre><code class="arm">vcgt.u8          d1,          d2</code></pre><p>在使用vcgt比较时，可以是有符号数s8，也可以是无符号数u8。</p><p>迁移后使用了cmgt，</p><pre><code class="arm">cmgt          v1.8B,    v2.8B</code></pre><p>出现不一致！</p><p>经过分析，</p><pre><code>cmgt：Compare signed greater than(vector and scalar form)</code></pre><p>该指令是针对有符号数比较，因此会不一致。<br>需要使用指令CMHI指令（Compare unsigned higher(vector and scalar form)）。</p><p>SIMD比较指令对应关系：</p><table><thead><tr><th>SIMD比较指令</th><th>ARM32</th><th>ARM64</th></tr></thead><tbody><tr><td>–</td><td>VCEQ</td><td>CMEQ</td></tr><tr><td>–</td><td>VCGE.u8</td><td>CMHS</td></tr><tr><td>–</td><td>VCGE.s8</td><td>CMGE</td></tr><tr><td>–</td><td>VCGT.u8</td><td>CMHI</td></tr><tr><td>–</td><td>VCGT.s8</td><td>CMGT</td></tr><tr><td>–</td><td>VCLE</td><td>CMLE</td></tr><tr><td>–</td><td>CVLT</td><td>CMLT</td></tr></tbody></table><h2 id="2、架构未指定导致的编译问题"><a href="#2、架构未指定导致的编译问题" class="headerlink" title="2、架构未指定导致的编译问题"></a>2、架构未指定导致的编译问题</h2><p><strong>问题现象：</strong></p><pre><code>Error: selected processor does not support ARM mode</code></pre><p><strong>解决方案：</strong><br>汇编编译选项中添加如下选项：</p><pre><code>SFLAGS += -march=armv8-a -mtune=cortex-a53 -mfloat-abi=softfp -mfpu=neon-vfpv4</code></pre><p>参考网址：<br>&lt;1&gt;、<a href="https://stackoverflow.com/questions/18216055/error-selected-processor-does-not-support-arm-mode" target="_blank" rel="noopener">Error: selected processor does not support ARM mode</a><br>&lt;2&gt;、<a href="https://stackoverflow.com/questions/41131432/cross-compiling-error-selected-processor-does-not-support-fmrx-r3-fpexc-in" target="_blank" rel="noopener">Cross compiling - Error: selected processor does not support `fmrx r3,fpexc’ in ARM mode - Beaglebone</a></p><h2 id="3、汇编编译器指定错误导致的编译问题"><a href="#3、汇编编译器指定错误导致的编译问题" class="headerlink" title="3、汇编编译器指定错误导致的编译问题"></a>3、汇编编译器指定错误导致的编译问题</h2><p><strong>问题现象：</strong><br>在一个汇编文件（test.S）中包含ffmpeg中的asm.S公共汇编头文件，如下所示</p><pre><code>#include &quot;asm.S&quot;</code></pre><p>但是编译报错，如下所示：</p><pre><code>Error: unknown mnemonic &quot;function&quot;Error: unknown mnemonic &quot;endfunc&quot;</code></pre><p><strong>解决方案：</strong><br>修改汇编编译器cross-as为cross-gcc即可。</p><p><strong>原因分析：</strong><br>汇编文件中使用#include &lt;&gt; 时，在as之前，会先调用预处理器来进行预处理（宏替换啥的）。<br>注意此时汇编文件名需要以.S作为结尾。<br>汇编文件中也可以使用.include &lt;&gt;, 此种include不会调用预处理器。<br>因此，在含有需要预处理.S汇编文件代码时，需要使用cross-gcc，而不是cross-as。</p><p>参考网址：<br><a href="https://community.arm.com/cn/f/discussions/5628/x264-arm-arm-s" target="_blank" rel="noopener">调用x264中arm汇编文件arm.S文件，编译报错</a></p><hr><h2 id="THE-END"><a href="#THE-END" class="headerlink" title=" THE END! "></a><font color="red"> THE END! </font></h2>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 优化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ARM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>毕业一年的总结和思考20180805</title>
      <link href="/2018/08/05/%E3%80%90Think%E7%B3%BB%E5%88%97%E3%80%91%E6%AF%95%E4%B8%9A%E4%B8%80%E5%B9%B4%E7%9A%84%E6%80%BB%E7%BB%93%E5%92%8C%E6%80%9D%E8%80%8320180805/"/>
      <url>/2018/08/05/%E3%80%90Think%E7%B3%BB%E5%88%97%E3%80%91%E6%AF%95%E4%B8%9A%E4%B8%80%E5%B9%B4%E7%9A%84%E6%80%BB%E7%BB%93%E5%92%8C%E6%80%9D%E8%80%8320180805/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>转眼间，毕业已经一年零一个月了。最近总有一个声音在告诉我，是时候该好好思考和总结一下工作这一年的收获、遗憾和思考了。<br>前几天，刚刚经过了晋升答辩，也正好对这一年的工作做了一个总结。在项目的处理上，感觉有些会有一些畏缩，难道是对自己不自信吗，还是因为初入职场？在这一年的工作中，我主要是重点关注技术学习，其他方面，比如认知、人脉、个人品牌建立等方面没有太多关注，后面应该也要更加关注其他方面能力的培养。在技术学习方面，主要通过写博客的方式整理相关知识点，但是对知识点的深入和整体把握方面还不够，也就是眼界不够宽，对问题的深入程度不够。对于眼界的培养，应该涉猎一些其他领域的书籍，多读书，会少走一些弯路的。</p><h2 id="总结和思考"><a href="#总结和思考" class="headerlink" title="总结和思考"></a>总结和思考</h2><p>下面以<br><strong>总结、现状、收获/成长、遗憾、认知/认识自己/反思、目标/方向、第二年规划</strong><br>为提纲总结梳理和分析一下这一年的工作吧。<br><strong>一、总结：</strong><br>下面梳理一下这一年做的主要事情吧(2017.7~2018.7)。<br><strong>2017年3月~8月：</strong><br>主要是mpeg4标准学习和智能编码项目参数调优，接触到了硬件编解码相关知识，以及从标准层面完整地梳理一个标准以及实现，这段时间主要是从学生过渡到职场人，基本适应工作节奏。<br><strong>2017年9月~2018年5月：</strong><br>这半年多的时间重点是在SVAC1标准学习和维护完善，增加场解码功能以及cabac熵编解码功能，以及增加SVAC1编码器客观评测工具，这三个工作的完成对模块开发以及问题解决更加熟悉，基本可以独立完成相关模块的开发。但是对标准整体框架的把握不够深入。<br><strong>2018年6月~2018年8月：</strong><br>这几个月的重点在SVAC2解码器arm架构32位优化，后续还会进行aarch64架构优化。完成了插值、去块滤波、SAO和ALF模块的arm优化，基本掌握了arm优化方法，可以进行一般模块的arm优化。</p><p>展望这一年的工作，其实总结起来主要做了3个事情，<strong>编解码标准学习、算法模块开发和ARM优化</strong>。</p><p><strong>二、现状：</strong><br>坐标杭州，安防民企，编解码算法工程师，有房无车，依旧单身。开始还贷中，压力还好。从工作中深深体会到，需要学习的知识还有很多，技术学习永无止境，另外除了技术学习需要更加关注架构层面。</p><p><strong>三、收获、成长:</strong><br>工作这一年最大的收获就是编解码技术更加深入，对自己的工作和职业发展有了初步的认识，感谢工作这一年以来帮助过我的同事和朋友，还有支持我的家人。<br>这一年的成长还是很多的，无论是工作还是感情，工作逐渐适应，感情方面我也逐渐意识到还是需要，谈一场真正的恋爱，遇到自己喜欢就要勇敢去追。另外这一年买了房，经历了买房办贷款的各种事情，让我明白了赚钱是很重要的，用了2个口袋的积累才买了现在的房子（虽然还没有见到），不知道这个突然的选择是否正确？！ 在经历这些事情的过程中，我逐渐变得遇事更加耐心和淡定，有了更多对家人和未来的思考，以及对自己人生的思考。</p><p><strong>四、遗憾：</strong><br>想想这一年，其实也没有啥遗憾的。自从6月底，从宁大毕业后就直接进入工作了。工作过程中，在学习、成长过程中，也遇到过一些困难，不过后面也顺利解决了。要说有遗憾，也许就是没有和家人一起去旅游，去看看外面的世界，我相信这个愿望不久就会实现的！</p><p><strong>五、认知、反思：</strong><br>工作这一年逐渐认识到自己知识架构不够扎实，解决问题的能力不够强，对事情的理解和整体把握不够深入，需要提高分析问题、解决问题的能力，以及架构层面的理解和深入。遇事可能会有些畏怯，需要增强自信，相信办法总比困难多。<br>对自己的认识：学生时代着重关注学习了，工作后着重关注技术学习了，也许应该更加关注生活、家庭和自己的感情了。<br>下面几点是值得反思和提高的方面：<br><strong>价值、认知、职业观、主动请教和分享、个人品牌、技术能力、视野，人脉</strong></p><p><strong>六、目标和方向：</strong><br>还记得工作初给自己制定的目标是2017~2022 5年时间里着重技术发展，现在也是朝着这个方向在努力。现在暂制定一个3年的短期目标，将这个5年目标进行细化，在工作3年时间里，掌握编解码技术相关的各方面知识并能够主导一般项目的开发，能够从更高层面上理解问题和解决问题，技术能力得到很大提升。后面2年时间，根据目标完成情况，继续深入编解码领域技术提升或者探索新的技术领域或者在进行编解码技术发展过程中，更加关注管理方面的发展。</p><p><strong>七、工作第二年规划：</strong><br>至于第二年规划，</p><ol><li><p>技术发展<br>基本掌握编解码技术方面的各种知识，能够从更高层面分析问题。</p></li><li><p>平台优势学习<br>了解公司业务发展方向和编解码的各种业务需求。</p></li><li><p>公司管理方法学习<br>初步了解管理学和管理方法。</p></li></ol><hr><h2 id="THE-END"><a href="#THE-END" class="headerlink" title="THE END!"></a><font color="red"><strong>THE END!</strong></font></h2>]]></content>
      
      
      <categories>
          
          <category> 生活 </category>
          
          <category> 规划 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Think </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用xstart远程连接linux图形用户界面以及rxvt终端配置</title>
      <link href="/2018/07/28/%E3%80%90Tools%E7%B3%BB%E5%88%97%E3%80%91%E4%BD%BF%E7%94%A8xstart%E8%BF%9C%E7%A8%8B%E8%BF%9E%E6%8E%A5linux%E5%9B%BE%E5%BD%A2%E7%94%A8%E6%88%B7%E7%95%8C%E9%9D%A2/"/>
      <url>/2018/07/28/%E3%80%90Tools%E7%B3%BB%E5%88%97%E3%80%91%E4%BD%BF%E7%94%A8xstart%E8%BF%9C%E7%A8%8B%E8%BF%9E%E6%8E%A5linux%E5%9B%BE%E5%BD%A2%E7%94%A8%E6%88%B7%E7%95%8C%E9%9D%A2/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="1、使用xstart远程连接linux图形用户界面"><a href="#1、使用xstart远程连接linux图形用户界面" class="headerlink" title="1、使用xstart远程连接linux图形用户界面"></a>1、使用xstart远程连接linux图形用户界面</h2><p>主要参考：<br><a href="https://blog.csdn.net/linghao00/article/details/8768435" target="_blank" rel="noopener">XShell+Xmanager实现在XShell中显示远程服务器的图形界面</a><br><a href="https://blog.csdn.net/huangyanlong/article/details/45021981" target="_blank" rel="noopener">远程使用x-manager中Xstart工具报缺少xterm包错误</a><br><a href="http://blog.sina.com.cn/s/blog_5112c0a60100rmpp.html" target="_blank" rel="noopener">Xmanager使用的几个问题</a><br><a href="https://blog.csdn.net/yabingshi_tech/article/details/51839379" target="_blank" rel="noopener">用xstart远程连接linux图形用户界面</a></p><p><img src="/img/20190729220409132-.png" alt="Xstart配置界面"></p><p><img src="/img/2019072922043922-.png" alt="Xrcmd远程执行结果"><br><img src="/img/20190729220507270-.png" alt="独立连接界面"></p><p>使用xstart已经成功远程连接到了Linux中，但是界面看起来有些丑，下面通过rxvt终端配置进行美化。</p><h2 id="2、rxvt终端配置："><a href="#2、rxvt终端配置：" class="headerlink" title="2、rxvt终端配置："></a>2、rxvt终端配置：</h2><p><a href="https://sourceforge.net/projects/rxvt/" target="_blank" rel="noopener">下载地址</a><br><a href="https://blog.csdn.net/Alex_15/article/details/61414796" target="_blank" rel="noopener">使用并设置urxvt终端</a></p><p>URXVT界面配置 参考：</p><p><a href="http://blog.sina.com.cn/s/blog_6bd162c10101dszc.html" target="_blank" rel="noopener">我的URXVT设置</a><br><a href="http://blog.chinaunix.net/uid-12888785-id-2384164.html" target="_blank" rel="noopener">urxvt配置及实现真透明的方法</a><br><a href="https://www.cnblogs.com/chjbbs/p/6389987.html" target="_blank" rel="noopener">rxvt-unicode配置</a><br><a href="https://www.cnblogs.com/vachester/p/5649813.html" target="_blank" rel="noopener">Archlinux下i3wm与urxvt的配置</a><br><a href="https://www.linuxidc.com/Linux/2013-03/81029.htm" target="_blank" rel="noopener">urxvt及vim配色方案</a><br><a href="https://bbs.archlinuxcn.org/viewtopic.php?pid=34515" target="_blank" rel="noopener">大家是如何配置Urxvt的啊？</a></p><pre><code>!!color setEmacs.FontBackend:xftEmacs.xim:fcitxEmacs.background:blackEmacs.foreground:greenURxvt.preeditType:Root!!调整此处设置输入法URxvt.inputMethod:ibusURxvt.title:soaringlee-rxvt-unicode!!颜色设置URxvt.depth:32!!中括号内数表示透明度URxvt.inheritPixmap:trueURxvt.background:#000000URxvt.foreground:#ffffffURxvt.colorBD:Gray95URxvt.colorUL:GreenURxvt.color1:Red2URxvt.color4:RoyalBlueURxvt.color5:Magenta2URxvt.color8:Gray50URxvt.color10:Green2URxvt.color12:DodgerBlueURxvt.color14:Cyan2URxvt.color15:Gray95!!URL操作URxvt.urlLauncher:chromiumURxvt.matcher.button:1Urxvt.perl-ext-common:matcher!!滚动条设置URxvt.scrollBar:trueURxvt.scrollBar_right:trueURxvt.scrollBar_floating:FalseURxvt.scrollstyle:plain!!滚屏设置URxvt.mouseWheelScrollPage:TrueURxvt.scrollTtyOutput:FalseURxvt.scrollWithBuffer:TrueURxvt.scrollTtyKeypress:True!!开启标签功能URxvt.perl-lib:/usr/lib/urxvt/perlURxvt.perl-ext-common: default,tabbed,digital-clock,readline,xim-onthespot,option-popup,selection-pastebin,selection-popup,default,tabbed,searchable-scrollback,selection-autotransformURxvt.tabbed.tab-fg: 12URxvt.tabbed.tab-bg: 0URxvt.tabbed.tabbar-fg:5!!光标闪烁URxvt.cursorBlink:TrueURxvt.saveLines:3000!!边框URxvt.borderLess:False!!字体设置Xft.dpi:96Xft.rgba:rgbXft.hinting:true!!URxvt.boldfont:xft:Liberation Mono:pixelsize=18:antialias=false:Bold,xft:Microsoft YaHei:pixelsize=18:Bold!!URxvt.font:xft:Liberation Mono:pixelsize=18,xft:Microsoft YaHei:pixelsize=18URxvt.font: xft:DejaVu Sans Mono:style=Regular:antialias=True:pixelsize=18,xft:WenQuanYi Micro Hei Mono:style=Regular:pixelsize=18URxvt.boldFont: xft:DejaVu Sans Mono:style=Bold:antialias=True:pixelsize=18,xft:WenQuanYi Micro Hei Mono:style=Bold:pixelsize=18!!URxvt.font:xft:Bitstream Vera Sans Mono-12,xft:Microsoft Yahei:pixelsize=16!!URxvt.boldFont:xft:Bitstream Vera Sans Mono-12:Bold,xft:Microsoft Yahei:pixelsize=16:BoldURxvt.visualBell:FalseURxvt.tintColor:white</code></pre><p><font color="red">但是存在一个问题就是：通过xrdb .Xresources命令配置生效后，界面并没有变化？</font></p><pre><code>LC_ALL=en_US.UTF-8 /usr/bin/urxvt  -ls -display $DISPLAY</code></pre><p>问题已经解决，配置好的界面如下：<br><img src="/img/20190731223937879-.png" alt="Urxvt配置界面"></p><p>当前也找到了另外一种方式使用独立的图形用户界面：<br>采用gnome-terminal的方式：<br>xstart中发送命令：</p><pre><code>/usr/bin/gnome-terminal --display $DISPLAY</code></pre><p>界面如下所示：</p><p><img src="/img/20190730215835282-.png" alt="Gnome终端配置界面"></p><p>颜值控的我，感觉这个界面还不错哦~</p><hr><h2 id="THE-END"><a href="#THE-END" class="headerlink" title=" THE  END! "></a><font color="red"> THE  END! </font></h2>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> Tools </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>颜色空间转换CSconvert：YUV420PtoRGB24</title>
      <link href="/2018/07/12/%E3%80%90Codecs%E7%B3%BB%E5%88%97%E3%80%91%E9%A2%9C%E8%89%B2%E7%A9%BA%E9%97%B4%E8%BD%AC%E6%8D%A2CSconvert%EF%BC%9AYUV420PtoRGB24/"/>
      <url>/2018/07/12/%E3%80%90Codecs%E7%B3%BB%E5%88%97%E3%80%91%E9%A2%9C%E8%89%B2%E7%A9%BA%E9%97%B4%E8%BD%AC%E6%8D%A2CSconvert%EF%BC%9AYUV420PtoRGB24/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="1、参考"><a href="#1、参考" class="headerlink" title="1、参考"></a>1、参考</h2><p><a href="http://www.360doc.com/content/16/0831/17/28378250_587310305.shtm" target="_blank" rel="noopener">http://www.360doc.com/content/16/0831/17/28378250_587310305.shtm</a><br><a href="https://blog.csdn.net/liyuanbhu/article/details/68951683l" target="_blank" rel="noopener">https://blog.csdn.net/liyuanbhu/article/details/68951683l</a><br><a href="https://blog.csdn.net/Alger_magic/article/details/52487582" target="_blank" rel="noopener">https://blog.csdn.net/Alger_magic/article/details/52487582</a><br><a href="https://blog.csdn.net/MikeDai/article/details/64215860" target="_blank" rel="noopener">https://blog.csdn.net/MikeDai/article/details/64215860</a></p><h2 id="2、功能"><a href="#2、功能" class="headerlink" title="2、功能"></a>2、功能</h2><p>yuv420toRGB24.c<br>1). 支持将单帧yuv转换成单幅rgb24格式的bmp图像；<br>2). 支持将多帧yuv转换成rgb24格式的视频文件。<br>3). 单帧yuv的获取可以采用：<br>extractYUV（<a href="https://blog.csdn.net/soaringlee_fighting/article/details/80503240）" target="_blank" rel="noopener">https://blog.csdn.net/soaringlee_fighting/article/details/80503240）</a></p><h2 id="3、C实现"><a href="#3、C实现" class="headerlink" title="3、C实现"></a>3、C实现</h2><pre><code class="c">/***************************************************************//函数：YUV420PtoRGB24.c//功能：//1). 支持将单帧yuv转换成单幅rgb24格式的bmp图像；//2). 支持将多帧yuv转换成rgb24格式的视频文件。//时间：2018.6.10****************************************************************/#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string&gt;#include &lt;windows.h&gt;int bmp24_write(unsigned char *image, int xsize, int ysize, FILE *pfile){    BITMAPFILEHEADER bmpFileHeader; //++BMP文件头    BITMAPINFOHEADER bmpInfoHeader; //++BMP信息头    bmpInfoHeader.biBitCount = 24; //++像素位数    //设置BMP文件头    bmpFileHeader.bfType = 0x04D42;    bmpFileHeader.bfSize = sizeof(bmpFileHeader)+sizeof(bmpInfoHeader)+bmpInfoHeader.biBitCount;    bmpFileHeader.bfReserved1 = 0;    bmpFileHeader.bfReserved2 = 0;    bmpFileHeader.bfOffBits = 54;//位图像素位置的起始地址    //设置BMP信息头    bmpInfoHeader.biSize = 40;    bmpInfoHeader.biWidth = xsize;    bmpInfoHeader.biHeight = ysize;    bmpInfoHeader.biPlanes = 1;    bmpInfoHeader.biCompression = 0;//压缩类型，0即不压缩    bmpInfoHeader.biSizeImage = 0;    bmpInfoHeader.biXPelsPerMeter = 0;    bmpInfoHeader.biYPelsPerMeter = 0;    bmpInfoHeader.biClrUsed = 0;    bmpInfoHeader.biClrImportant = 0;    fwrite(&amp;bmpFileHeader, 1, sizeof(bmpFileHeader), pfile);    fwrite(&amp;bmpInfoHeader, 1, sizeof(bmpInfoHeader), pfile);    fwrite(image, 1, xsize*ysize * 3, pfile);    return 0;}int rgb24_write(unsigned char *image, int xsize, int ysize, FILE *pfile){    fwrite(image, 1, xsize*ysize * 3, pfile);    return 0;}int yuv420toRGB24(unsigned char* yuv420, unsigned char*rgb24, int width, int height,int bmp_flag){    //++参数检查    if (NULL == yuv420 || NULL == rgb24 || width &lt; 1 || height &lt; 1)    {        printf(&quot;ERROR: input para error!!\n&quot;);        return -1;    }    int Y, U, V, R, G, B;    int i, j;    int cwidth = width &gt;&gt; 1;    for (i = 0; i &lt; height; ++i)    {        for (j = 0; j &lt; width; ++j)        {            Y = *(yuv420 + i * width + j);            U = *(yuv420 + width * height + (i &gt;&gt; 1) * cwidth + (j &gt;&gt; 1));            V = *(yuv420 + width * height * 5 / 4 + (i &gt;&gt; 1) * cwidth + (j &gt;&gt; 1));            R = Y + 1.403 * (V - 128);            G = Y - 0.344 * (U - 128) - 0.714 * (V - 128);            B = Y + 1.772 * (U - 128);            if (R &lt;= 0 || R &gt;= 255)            {                R = (R &lt; 0) ? 0 : 255;            }            if (G &lt;= 0 || G &gt;= 255)            {                G = (G &lt; 0) ? 0 : 255;            }            if (B &lt;= 0 || B &gt;= 255)            {                B = (B &lt; 0) ? 0 : 255;            }            if (bmp_flag)            {                //BMP图像的存放是从最后一行(从下往上)开始按照B\G\R的顺序进行存放的                *(rgb24 + ((height - i - 1)*width + j) * 3) = B;                *(rgb24 + ((height - i - 1)*width + j) * 3 + 1) = G;                *(rgb24 + ((height - i - 1)*width + j) * 3 + 2) = R;            }            else            {                *(rgb24 + (i * width + j) * 3) = B;                *(rgb24 + (i * width + j) * 3 + 1) = G;                *(rgb24 + (i* width + j) * 3 + 2) = R;            }        }    }    return 0;}int main(int argc, char** argv){    int width, height, filelen, frameno, framenum, bmp_flag;    FILE *yuv_file, *rgb_file;    unsigned char *yuv420, *rgb24;    char filename[50];    if (argc &lt; 5)    {        printf(&quot;Usage: yuv420ptoRGB24.exe yuv420_file rgb24_filename width height\n\n&quot;);    }    yuv_file = fopen(argv[1], &quot;rb&quot;);    if (NULL == yuv_file)    {        printf(&quot;ERROR: open %s fail!\n&quot;, argv[1]);        return -1;    }    width = atoi(argv[3]);    height = atoi(argv[4]);    yuv420 = (unsigned char *)malloc(width*height * 3 / 2);    if (NULL == yuv420)    {        printf(&quot;ERROR: malloc yuv420 fail!\n&quot;);        return -1;    }    rgb24 = (unsigned char *)malloc(width*height * 3);    if (NULL == rgb24)    {        printf(&quot;ERROR: malloc rgb24 fail!\n&quot;);        return -1;    }    fseek(yuv_file, 0, SEEK_END);    filelen = ftell(yuv_file);    frameno = filelen / (width*height * 3 / 2);    fseek(yuv_file, 0, SEEK_SET); //++将文件指针重新指向文件开始位置    if (frameno == 1)    {        sprintf(filename, &quot;%s_rgb24.bmp&quot;, argv[2]);    }    else    {        sprintf(filename, &quot;%s.rgb24&quot;, argv[2]);    }    rgb_file = fopen(filename, &quot;wb&quot;);    if (NULL == rgb_file)    {        printf(&quot;ERROR: open %s fail!\n&quot;, filename);        return -1;    }    framenum = 0;    bmp_flag = (frameno == 1) ? 1 : 0;    while (fread(yuv420, sizeof(unsigned char), width*height * 3 / 2, yuv_file) == width*height * 3 / 2)    {        yuv420toRGB24(yuv420, rgb24, width, height, bmp_flag);        printf(&quot;%dth frames ok!!!\n&quot;, framenum);        framenum++;        if (bmp_flag)//++单帧yuv转成bmp图像        {            bmp24_write(rgb24, width, height, rgb_file);        }        else//++多帧yuv转成rgb24格式视频        {            rgb24_write(rgb24, width, height, rgb_file);        }    }    printf(&quot;yuv420p to RGB24 succeessfully!!,total frames: %d\n&quot;, frameno);    free(yuv420);    yuv420 = NULL;    free(rgb24);    rgb24 = NULL;    fclose(yuv_file);    fclose(rgb_file);    return 0;}</code></pre><h2 id="4、实验结果"><a href="#4、实验结果" class="headerlink" title="4、实验结果"></a>4、实验结果</h2><p>单帧yuv转换成bmp图像：<br><img src="/img/20180610112127919.jpg" alt="单帧yuv转换成bmp图像"></p><p>多帧yuv转换成rgb24格式视频：<br><img src="/img/20180610112517143.jpg" alt="多帧yuv转换成rgb24格式视频"></p><hr><h2 id="THE-END"><a href="#THE-END" class="headerlink" title=" THE  END! "></a><font color="red"> <strong>THE  END!</strong> </font></h2>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 视频处理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Video </tag>
            
            <tag> CSConvert </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GnuWin32使用以及windows下gnu makefile编写</title>
      <link href="/2018/06/22/%E3%80%90Tools%E7%B3%BB%E5%88%97%E3%80%91GnuWin32%E4%BD%BF%E7%94%A8%E4%BB%A5%E5%8F%8Awindows%E4%B8%8Bgnu%20makefile%E7%BC%96%E5%86%99/"/>
      <url>/2018/06/22/%E3%80%90Tools%E7%B3%BB%E5%88%97%E3%80%91GnuWin32%E4%BD%BF%E7%94%A8%E4%BB%A5%E5%8F%8Awindows%E4%B8%8Bgnu%20makefile%E7%BC%96%E5%86%99/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="1、GnuWin32下载地址"><a href="#1、GnuWin32下载地址" class="headerlink" title="1、GnuWin32下载地址"></a>1、GnuWin32下载地址</h2><p><a href="https://sourceforge.net/projects/getgnuwin32/files/latest/download" target="_blank" rel="noopener">https://sourceforge.net/projects/getgnuwin32/files/latest/download</a></p><p><a href="http://gnuwin32.sourceforge.net/x86_32" target="_blank" rel="noopener">http://gnuwin32.sourceforge.net/x86_32</a></p><h2 id="2、GnuWin32官方说明及使用方法"><a href="#2、GnuWin32官方说明及使用方法" class="headerlink" title="2、GnuWin32官方说明及使用方法"></a>2、GnuWin32官方说明及使用方法</h2><h3 id="2-1、说明"><a href="#2-1、说明" class="headerlink" title="2.1、说明"></a>2.1、说明</h3><p>The GnuWin project provides Win32-versions of GNU tools, or tools with a similar open source licence. <strong>The ports are native ports, that is they rely only on libraries provided with any standard 32-bits MS-Windows operating system,</strong> such as MS-Windows 95 / 98 / ME / NT / 2000 / XP / 2003 / Vista. Unlike CygWin or Msys, native ports do not rely on some kind of Unix emulation, so that there is no need to install additional emulation libraries. At present, all developments have been done under MS-Windows-XP, using the Mingw port of the GNU C and C++ (GCC) compilers. Utilities and libraries provided by GnuWin, are used and distributed with packages such as GNU Emacs and KDE-Windows.</p><h3 id="2-2、安装和使用方法"><a href="#2-2、安装和使用方法" class="headerlink" title="2.2、安装和使用方法"></a>2.2、安装和使用方法</h3><p>下载网址：<a href="http://gnuwin32.sourceforge.net/packages/make.htm" target="_blank" rel="noopener">http://gnuwin32.sourceforge.net/packages/make.htm</a><br>其他组件包：<a href="http://gnuwin32.sourceforge.net/packages.html" target="_blank" rel="noopener">http://gnuwin32.sourceforge.net/packages.html</a><br>具体安装可参考：<a href="https://stackoverflow.com/questions/2532234/how-to-run-a-makefile-in-windows" target="_blank" rel="noopener">https://stackoverflow.com/questions/2532234/how-to-run-a-makefile-in-windows</a><br>或：<a href="https://www.cnblogs.com/April-Chou-HelloWorld/p/7636300.html" target="_blank" rel="noopener">https://www.cnblogs.com/April-Chou-HelloWorld/p/7636300.html</a></p><h2 id="3、windows下gnu-makefile自动化编译"><a href="#3、windows下gnu-makefile自动化编译" class="headerlink" title="3、windows下gnu makefile自动化编译"></a>3、windows下gnu makefile自动化编译</h2><p><strong>方法一：</strong> 采用GnuWin32提供的工具（<a href="https://sourceforge.net/projects/gnuwin32/files/make)，解析makefile" target="_blank" rel="noopener">https://sourceforge.net/projects/gnuwin32/files/make)，解析makefile</a><br>或者直接将MinGW中的make.exe拷贝到脚本所在目录下，运行脚本即可。<br>参考自：<a href="https://blog.csdn.net/listener51/article/details/84933876" target="_blank" rel="noopener">https://blog.csdn.net/listener51/article/details/84933876</a></p><h3 id="3-1、编写config-win-mk"><a href="#3-1、编写config-win-mk" class="headerlink" title="3.1、编写config_win.mk"></a>3.1、编写config_win.mk</h3><p>存放相关系统宏和编译flags:</p><pre><code>ifeq ($(strip $(platform)), x86_32)    CC    := cl.exe    LD    := link.exe    AR    := lib.exe    RC    := rc.exe    EXTRA_CFLAGS := -W3 -nologo -DWIN32    EXTRA_CFLAGS += -D_CRT_SECURE_NO_WARNINGS -O2    EXTRA_LDFLAGS :=    EXTRA_RCFLAGS := -DWIN32endififeq ($(strip $(platform)), x86_64)    CC    := cl.exe    LD    := link.exe    AR    := lib.exe    RC    := rc.exe    EXTRA_CFLAGS := -W3 -nologo -DWIN64    EXTRA_CFLAGS += -D_CRT_SECURE_NO_WARNINGS -O2    EXTRA_LDFLAGS :=    EXTRA_RCFLAGS := -DWIN64endifCFLAGS := $(EXTRA_CFLAGS)LDFLAGS := $(EXTRA_LDFLAGS)RCFLAGS := $(EXTRA_RCFLAGS)ARFLAGS :=</code></pre><h3 id="3-2、编写makefile-win-mk"><a href="#3-2、编写makefile-win-mk" class="headerlink" title="3.2、编写makefile_win.mk"></a>3.2、编写makefile_win.mk</h3><pre><code>###windows gnu make### 假设库的目录结构如下且同一“-”长度的属于同一目录###  -3rdparty         #第三方库相关的库文件###  -src                  #源码路径（包含C文件及头文件）###  -build              #build目录下有各平台相关的文件夹###  --windows          #windows文件夹###  ---makefile      #windows下的makefile###  ---dll_info.rc     #资源文件###  --objs               #obj文件输出目录###  --out               #库输出目录include config_win.mk##库的名字在此设置LIB_NAME := xxx##指定相关路径关系ROOT_DIR := ../../C_SRCS_DIR := $(ROOT_DIR)/srcINCS_DIR := $(ROOT_DIR)/srcOBJS_DIR := $(ROOT_DIR)/objsINC_FLAGS := -I$(ROOT_DIR)/src \             -I$(ROOT_DIR)/3rdparty#设置动态库静态库生成路径TARGET_S := $(ROOT_DIR)/out/lib_$(LIB_NAME).lib #静态库TARGET_D := $(ROOT_DIR)/out/$(LIB_NAME).dll        #动态库DLL_IMPLIB := $(ROOT_DIR)/out/$(LIB_NAME).lib    #动态库导入库DLL_LIBPDB := $(ROOT_DIR)/out/$(LIB_NAME).pdb    #动态库的PDB文件#设置资源文件路径RC_SRCS := $(ROOT_DIR)/build/windows/dll_info.rc#设置相关源文件C_SRCS := $(C_SRCS_DIR)/xxx.c#设置编译过程输出日志OUTPUT = &gt;&gt;compile.log 2&gt;&amp;1##目标文件OBJS := $(patsubat %.s, %.obj, $(patsubat %.c, %.obj, $(patsubat %.cpp, %.obj, $(C_SRCS))))OBJS_PATH := $(addprefix $(OBJS_DIR)/, $(notdir $(OBJS)))##资源文件OBJRES := $(patsubat %.rc, %.res, $(RC_SRCS))OBJRES_PATH := $(addprefix $(OBJS_DIR)/, $(notdir $(OBJRES)))all: clean $(TARGET_S) $(TARGET_D)#静态库$(TARGET_S):$(OBJS)    $(AR) $(ARFLAGS) -out:$@ $(OBJS_PATH) $(OUTPUT)    #动态库$(TARGET_D):$(OBJS)    $(LD) $(LDFLAGS) -dll -implib:$(DLL_IMPLIB) -out:$@ $(OBJS_PATH) $(OBJRES_PATH) -debug -PDB:$(DLL_LIBPDB)%.obj:%.c    $(CC) $(CFLAGS) $(INC_FLAGS) -Fo$(addprefix $(OBJ_DIR)/, $(@F)) -c $^%.obj:%.cpp    $(CPP) $(CFLAGS) $(INC_FLAGS) -Fo$(addprefix $(OBJ_DIR)/, $(@F)) -c $^%.res:%.rc    ###SubWCRev.exe ../ ../dll_info.t ../dll_info.rc    $(RC) $(RCFLAGS) -Fo $(addprefix $(OBJS_PATH)/, $(@F)) $^clean:    where -F -R . *.obj *.log | grep -e .obj -e .log | xargs rm -rf    rm -f $(OBJRES_PATH)    rm -f $(OBJS_PATH)</code></pre><p><strong>方法二：</strong><br><a href="https://blog.csdn.net/SoaringLee_fighting/article/details/84894352" target="_blank" rel="noopener">在MinGW环境下进行Windows 平台GNU makefile的编写</a></p><h3 id="3-3、参考"><a href="#3-3、参考" class="headerlink" title="3.3、参考"></a>3.3、参考</h3><p><a href="https://cognitivewaves.wordpress.com/makefiles-windows/" target="_blank" rel="noopener">https://cognitivewaves.wordpress.com/makefiles-windows/</a><br><a href="https://opensourceforu.com/2012/06/gnu-make-in-detail-for-beginners/" target="_blank" rel="noopener">https://opensourceforu.com/2012/06/gnu-make-in-detail-for-beginners/</a><br><a href="https://stackoverflow.com/questions/2532234/how-to-run-a-makefile-in-windows" target="_blank" rel="noopener">https://stackoverflow.com/questions/2532234/how-to-run-a-makefile-in-windows</a><br><a href="https://stackoverflow.com/questions/2532234/how-to-run-a-makefile-in-windows" target="_blank" rel="noopener">https://stackoverflow.com/questions/2532234/how-to-run-a-makefile-in-windows</a></p><hr><h2 id="THE-END"><a href="#THE-END" class="headerlink" title=" THE END ! "></a><font color="read"> <strong>THE END !</strong> </font></h2>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
          <category> 编译工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> makefile </tag>
            
            <tag> Tools </tag>
            
            <tag> Gnu </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>YUV处理工具：图像水平拼接</title>
      <link href="/2018/06/04/%E3%80%90Codecs%E7%B3%BB%E5%88%97%E3%80%91YUV%E5%A4%84%E7%90%86%E5%B7%A5%E5%85%B7%EF%BC%9A%E5%9B%BE%E5%83%8F%E6%B0%B4%E5%B9%B3%E6%8B%BC%E6%8E%A5/"/>
      <url>/2018/06/04/%E3%80%90Codecs%E7%B3%BB%E5%88%97%E3%80%91YUV%E5%A4%84%E7%90%86%E5%B7%A5%E5%85%B7%EF%BC%9A%E5%9B%BE%E5%83%8F%E6%B0%B4%E5%B9%B3%E6%8B%BC%E6%8E%A5/</url>
      
        <content type="html"><![CDATA[<p>Tags:  YUV处理实用小工具<br>[TOC]</p><h2 id="1、YUV图像水平拼接"><a href="#1、YUV图像水平拼接" class="headerlink" title="1、YUV图像水平拼接"></a>1、YUV图像水平拼接</h2><p>功能说明：YUV文件水平拼接，YUV按照y,u,v三个分量顺序排列，支持YUV420P（I420 or YV12）采样格式。</p><h2 id="2、C实现"><a href="#2、C实现" class="headerlink" title="2、C实现"></a>2、C实现</h2><pre><code class="c">/**********************************************************************//Function: horizontal combiner of two yuv image , yuv//support yuv420p（I420 or YV12）//Author&amp;Date: SoaringLee 3rd June 2018//Modified:/*********************************************************************/#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;int main(int argc, char** argv){    int i, j, width, height, frame_size,framenum = 0;    FILE *fin_1, *fin_2, *fout;    unsigned char *y1, *u1, *v1, *y2, *u2, *v2, *y, *u, *v, *tmp_y1, *tmp_u1, *tmp_v1, *tmp_y2, *tmp_u2, *tmp_v2, *tmp_y, *tmp_u, *tmp_v;    printf(&quot;\nUsage: combinerYUV.exe input1 input2 output width height\n\n&quot;);    for (i = 0; i &lt; argc; i++)    {        printf(&quot;Input parameters: %s \n&quot;, argv[i]);    }    if (argc &lt; 6)    {        return -1;    }    fin_1 = fopen(argv[1], &quot;rb&quot;);    if (NULL == fin_1)    {        printf(&quot;ERROR: open %s fail\n&quot;, argv[1]);        return -1;    }    fin_2 = fopen(argv[2], &quot;rb&quot;);    if (NULL == fin_2)    {        printf(&quot;ERROR: open %s fail\n&quot;, argv[2]);        return -1;    }    fout = fopen(argv[3], &quot;wb&quot;);    if (NULL == fout)    {        printf(&quot;ERROR: open %s fail\n&quot;, argv[3]);        return -1;    }    width = atoi(argv[4]);    height = atoi(argv[5]);    frame_size = width*height;    y1 = (unsigned char *)malloc(frame_size * 3 / 2);//yuv1    if (NULL == y1)    {        printf(&quot;ERROR: malloc y1 fail\n&quot;);        return -1;    }    u1 = y1 + width*height;    v1 = u1 + width*height / 4;    y2 = (unsigned char *)malloc(frame_size * 3 / 2);//yuv2    if (NULL == y2)    {        printf(&quot;ERROR: malloc y2 fail\n&quot;);        return -1;    }    u2 = y2 + width*height;    v2 = u2 + width*height / 4;    y = (unsigned char *)malloc(frame_size * 3);//fp_out    if (NULL == y)    {        printf(&quot;ERROR: malloc y fail\n&quot;);        return -1;    }    u = y + width*height * 2;    v = u + width*height / 2;    while ((fread(y1, 1, frame_size*3/2, fin_1) == frame_size*3/2)  &amp;&amp; (fread(y2, 1, frame_size*3/2, fin_2) == frame_size*3/2))    {        //++方法一：逐像素拷贝//         for (i = 0; i &lt; height;++i)//         {//             for (j = 0; j &lt; width; ++j)//             {//                 y[i*width*2 + j] = y1[i*width + j];//                 y[i*width*2 + width + j] = y2[i*width + j];//             }//         }////         for (i = 0; i &lt; height / 2;++i)//         {//             for (j = 0; j &lt; width / 2;++j)//             {//                 u[i*width + j] = u1[i*width / 2 + j];//                 u[i*width + width/2 +j] = u2[i*width / 2 + j];////                 v[i*width + j] = v1[i*width / 2 + j];//                 v[i*width + width/2 + j] = v2[i*width / 2 + j];//             }//         }        //++方法二：逐行拷贝        tmp_y1 = y1;        tmp_u1 = u1;        tmp_v1 = v1;        tmp_y2 = y2;        tmp_u2 = u2;        tmp_v2 = v2;        tmp_y = y;        tmp_u = u;        tmp_v = v;        for (i = 0; i &lt; height; ++i)        {            memcpy(tmp_y, tmp_y1, width);            tmp_y += width;            tmp_y1 += width;            memcpy(tmp_y, tmp_y2, width);            tmp_y += width;            tmp_y2 += width;        }        for (i = 0; i &lt; height / 2; ++i)        {            memcpy(tmp_u, tmp_u1, width / 2);            tmp_u += width / 2;            tmp_u1 += width / 2;            memcpy(tmp_u, tmp_u2, width / 2);            tmp_u += width / 2;            tmp_u2 += width / 2;            memcpy(tmp_v, tmp_v1, width / 2);            tmp_v += width / 2;            tmp_v1 += width / 2;            memcpy(tmp_v, tmp_v2, width / 2);            tmp_v += width / 2;            tmp_v2 += width / 2;        }        fwrite(y, 1, frame_size * 3/2 * 2, fout);        printf(&quot;%dth frame ok!!\n&quot;, framenum);        framenum++;    }    printf(&quot;combinerYUV successfully!! ,total frames: %d\n&quot;,framenum);    free(y1);    y1 = NULL;    free(y2);    y2 = NULL;    free(y);    y = NULL;    fclose(fin_1);    fclose(fin_2);    fclose(fout);    return 0;}</code></pre><h2 id="3、拼接效果图"><a href="#3、拼接效果图" class="headerlink" title="3、拼接效果图"></a>3、拼接效果图</h2><p><strong>拼接后的YUV示意图：</strong><br><img src="/img/20180604214451402.jpg" alt="拼接后的YUV示意图"></p><hr><h2 id="THE-END"><a href="#THE-END" class="headerlink" title=" THE END! "></a><font color="red"> THE END! </font></h2>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 视频处理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> YUV </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>YUV处理工具：文件剪切</title>
      <link href="/2018/05/29/%E3%80%90Codecs%E7%B3%BB%E5%88%97%E3%80%91YUV%E5%A4%84%E7%90%86%E5%B7%A5%E5%85%B7%EF%BC%9A%E6%96%87%E4%BB%B6%E5%89%AA%E5%88%87%E5%8A%9F%E8%83%BD/"/>
      <url>/2018/05/29/%E3%80%90Codecs%E7%B3%BB%E5%88%97%E3%80%91YUV%E5%A4%84%E7%90%86%E5%B7%A5%E5%85%B7%EF%BC%9A%E6%96%87%E4%BB%B6%E5%89%AA%E5%88%87%E5%8A%9F%E8%83%BD/</url>
      
        <content type="html"><![CDATA[<p>Tags:  YUV处理实用小工具</p><p>[TOC]</p><h2 id="1、YUV文件剪切"><a href="#1、YUV文件剪切" class="headerlink" title="1、YUV文件剪切"></a>1、YUV文件剪切</h2><p>功能说明：实现YUV文件剪切，可以设置开始帧和结束帧，裁剪得到任意帧数的YUV数据。</p><h2 id="2、算法实现"><a href="#2、算法实现" class="headerlink" title="2、算法实现"></a>2、算法实现</h2><h3 id="2-1、方法一：C语言实现"><a href="#2-1、方法一：C语言实现" class="headerlink" title="2.1、方法一：C语言实现"></a>2.1、方法一：C语言实现</h3><pre><code class="c">#include &quot;stdio.h&quot;#include &quot;stdlib.h&quot;#include &quot;string&quot;int main(int argc, char** argv){    unsigned char* y;    FILE* fp_input, *fp_out;    int i, width, height, start, stop;    int filelen, frames_no, picturesize, skip_size;    char outname[100];    if (argc &lt; 6)    {        printf(&quot;Usage: extractYUV.exe  input.yuv  width height startframe stopframe\n\n&quot;);        return -1;    }    width = atoi(argv[2]);    height = atoi(argv[3]);    start = atoi(argv[4]);    stop = atoi(argv[5]);    sprintf_s(outname,&quot;%s_%d_%d.yuv&quot;,argv[1],start,stop);    fp_input = fopen(argv[1], &quot;rb&quot;);    if (NULL == fp_input)    {        printf(&quot;open %s fail!\n&quot;,argv[1]);        return -1;    }    fp_out = fopen(outname, &quot;wb&quot;);    if (NULL == fp_out)    {        printf(&quot;open %s fail!\n&quot;,argv[1]);        return -1;    }    picturesize = width*height*3/2;    fseek(fp_input,SEEK_END,SEEK_SET);    filelen = ftell(fp_input);    frames_no = filelen / picturesize;    skip_size = start * picturesize;    fseek(fp_input, skip_size,SEEK_SET);    y = (unsigned char*)malloc(picturesize*sizeof(unsigned char*));    for (i = 0; i &lt; (stop - start); i++)    {        if (fread(y, 1, picturesize, fp_input) == picturesize)        {            fwrite(y, 1, picturesize, fp_out);        }    }    printf(&quot;extractYUV ok!!!, total frames:%d\n&quot;,stop - start);    free(y);    y = NULL;    fclose(fp_input);    fclose(fp_out);    return 0;}</code></pre><h3 id="2-2、方法二：采用ffmpeg命令行实现"><a href="#2-2、方法二：采用ffmpeg命令行实现" class="headerlink" title="2.2、方法二：采用ffmpeg命令行实现"></a>2.2、方法二：采用ffmpeg命令行实现</h3><p>Extract some YUV frames from large yuv File</p><p><strong>从第0帧开始截取30帧：</strong></p><pre><code class="c">ffmpeg -s widthxheight -i input.yuv -c:v rawvideo -filter:v select=&quot;gt(n\, -1)&quot; -vframes 30 out30.yuv</code></pre><p>或者：</p><pre><code class="c">ffmpeg -s widthxheight -i input.yuv -c:v rawvideo -filter:v select=&quot;between(n\, 0\, 29)&quot; out30.yuv</code></pre><p>或者：</p><pre><code class="c">ffmpeg -r 1 -ss 0 -i input.yuv -vcodec copy -vframes 30 output.yuv</code></pre><p><strong>中间截取帧（截取从第30帧到第100帧）：</strong></p><pre><code class="c">ffmpeg -s widthxheight -i input.yuv -c:v rawvideo -filter:v select=&quot;between(n\, 30\, 100)&quot; out.yuv</code></pre><p><strong>根据时间截取帧（截取从第10秒到第20秒 ）：</strong></p><pre><code class="c">//Select only frames contained in the 10-20 time interval://select=between(t\,10\,20)ffmpeg -s widthxheight -i input.yuv -c:v rawvideo -filter:v select=&quot;between(t\, 10\, 20)&quot; out.yuv</code></pre><p>更多ffmpeg命令使用可参考：</p><p><a href="http://processors.wiki.ti.com/index.php/Open_Source_Video_Processing_Tools_-_MPlayer,_FFMpeg,_AviSynth,_MKVToolnix,_MP4Box#Downloads" target="_blank" rel="noopener">http://processors.wiki.ti.com/index.php/Open_Source_Video_Processing_Tools_-_MPlayer,_FFMpeg,_AviSynth,_MKVToolnix,_MP4Box#Downloads</a><br><a href="http://ffmpeg.org/ffmpeg-filters.html#aselect_002c-select" target="_blank" rel="noopener">http://ffmpeg.org/ffmpeg-filters.html#aselect_002c-select</a><br><a href="https://lists.ffmpeg.org/pipermail/ffmpeg-user/2017-February/035335.html" target="_blank" rel="noopener">https://lists.ffmpeg.org/pipermail/ffmpeg-user/2017-February/035335.html</a><br><a href="https://www.bookstack.cn/read/other-doc-cn-ffmpeg/ffmpeg-doc-cn-40.md" target="_blank" rel="noopener">https://www.bookstack.cn/read/other-doc-cn-ffmpeg/ffmpeg-doc-cn-40.md</a></p><hr><h2 id="THE-END！"><a href="#THE-END！" class="headerlink" title=" THE END！"></a><font color="red"> THE END！</font></h2>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 视频处理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> YUV </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>YUV处理工具：文件分割和帧率扩倍功能</title>
      <link href="/2018/05/28/%E3%80%90Codecs%E7%B3%BB%E5%88%97%E3%80%91YUV%E5%A4%84%E7%90%86%E5%B7%A5%E5%85%B7%EF%BC%9A%E6%96%87%E4%BB%B6%E5%88%86%E5%89%B2%E5%92%8C%E5%B8%A7%E7%8E%87%E6%89%A9%E5%80%8D%E5%8A%9F%E8%83%BD/"/>
      <url>/2018/05/28/%E3%80%90Codecs%E7%B3%BB%E5%88%97%E3%80%91YUV%E5%A4%84%E7%90%86%E5%B7%A5%E5%85%B7%EF%BC%9A%E6%96%87%E4%BB%B6%E5%88%86%E5%89%B2%E5%92%8C%E5%B8%A7%E7%8E%87%E6%89%A9%E5%80%8D%E5%8A%9F%E8%83%BD/</url>
      
        <content type="html"><![CDATA[<p>Tags: YUV处理实用小工具</p><p>[TOC]</p><h2 id="1、隔帧分割和帧率扩倍"><a href="#1、隔帧分割和帧率扩倍" class="headerlink" title="1、隔帧分割和帧率扩倍"></a>1、隔帧分割和帧率扩倍</h2><p>功能说明： 实现YUV文件分割为两个子YUV，隔帧写入YUV，实现帧率扩倍功能。</p><h2 id="2、算法实现"><a href="#2、算法实现" class="headerlink" title="2、算法实现"></a>2、算法实现</h2><h3 id="2-1-C实现"><a href="#2-1-C实现" class="headerlink" title="2.1 C实现"></a>2.1 C实现</h3><p>cutYUV.cpp</p><pre><code class="c">/*****************************************************//Function: split  a yuv file to two sub yuv file, fps// increase twice.//Date: 2018-5-30//Author: SoaringLee//Modified:*****************************************************/#include &quot;stdio.h&quot;#include &quot;stdlib.h&quot;#include &quot;string&quot;int main(int argc, char** argv){    unsigned char* y;    FILE* fp_input, *fp_out1, *fp_out2;    int width, height, picturesize, framenum = 0;    printf(&quot;Usage: splitYUV.exe  srcyuv dstyuv1 dstyuv2 width height\n\n&quot;);    if (argc &lt; 5)    {        return -1;    }    width = atoi(argv[4]);    height = atoi(argv[5]);    fp_input = fopen(argv[1], &quot;rb&quot;);    if (NULL == fp_input)    {        printf(&quot;open %s fail!\n&quot;, argv[1]);        return -1;    }    fp_out1 = fopen(argv[2], &quot;wb&quot;);    if (NULL == fp_out1)    {        printf(&quot;open %s fail!\n&quot;, argv[2]);        return -1;    }    fp_out2 = fopen(argv[3], &quot;wb&quot;);    if (NULL == fp_out2)    {        printf(&quot;open %s fail!\n&quot;, argv[3]);        return -1;    }    picturesize = width*height * 3 / 2;//++YUV420    y = (unsigned char*)malloc(picturesize*sizeof(unsigned char*));    while (fread(y, 1, picturesize, fp_input) == picturesize)    {        if (framenum % 2 == 0)        {            fwrite(y, 1, picturesize, fp_out1);        }        else        {            fwrite(y, 1, picturesize, fp_out2);        }        framenum++;    }    printf(&quot;[SplitYUV] split %s to %s and %s successfully!!!\n&quot;, argv[1], argv[2], argv[3]);    free(y);    y = NULL;    fclose(fp_input);    fclose(fp_out1);    fclose(fp_out2);    return 0;}</code></pre><h3 id="2-2、ffmpeg方法"><a href="#2-2、ffmpeg方法" class="headerlink" title="2.2、ffmpeg方法"></a>2.2、ffmpeg方法</h3><p>另外，还可以通过ffmpeg实现隔帧分割的功能：</p><pre><code class="c">ffmpeg -r 2 -s WxH -i rawbitstream.yuv -filter:v select=&quot;mod(n-1\,2)&quot; \-c:v rawvideo -r 1 -format rawvideo -pix_fmt yuv420p -an odd.yuvffmpeg -r 2 -s WxH -i rawbitstream.yuv -filter:v select=&quot;not(mod(n-1\,2))&quot; \-c:v rawvideo -r 1 -format rawvideo -pix_fmt yuv420p -an even.yuv</code></pre><p>更多可以参考：<br><a href="https://superuser.com/questions/573747/drop-every-even-or-odd-frames-using-ffmpeg" target="_blank" rel="noopener">https://superuser.com/questions/573747/drop-every-even-or-odd-frames-using-ffmpeg</a></p><h2 id="3、ffmpeg分段分割"><a href="#3、ffmpeg分段分割" class="headerlink" title="3、ffmpeg分段分割"></a>3、ffmpeg分段分割</h2><p>Extract some YUV frames from large yuv File<br>从第0帧开始截取30帧：</p><pre><code class="c">ffmpeg -s widthxheight -i input.yuv -c:v rawvideo -filter:v select=&quot;gt(n\, -1)&quot; -vframes 30 out30.yuv</code></pre><p>或者：</p><pre><code class="c">ffmpeg -s widthxheight -i input.yuv -c:v rawvideo -filter:v select=&quot;between(n\, 0\, 29)&quot; out30.yuv</code></pre><p>或者：</p><pre><code class="c">ffmpeg -r 1 -ss 0 -i input.yuv -vcodec copy -vframes 30 output.yuv</code></pre><p>更多命令使用参考：</p><ol><li><a href="http://processors.wiki.ti.com/index.php/Open_Source_Video_Processing_Tools_-_MPlayer,_FFMpeg,_AviSynth,_MKVToolnix,_MP4Box#Downloads" target="_blank" rel="noopener">http://processors.wiki.ti.com/index.php/Open_Source_Video_Processing_Tools_-_MPlayer,_FFMpeg,_AviSynth,_MKVToolnix,_MP4Box#Downloads</a></li><li><a href="http://ffmpeg.org/ffmpeg-filters.html#aselect_002c-select" target="_blank" rel="noopener">http://ffmpeg.org/ffmpeg-filters.html#aselect_002c-select</a></li><li><a href="https://lists.ffmpeg.org/pipermail/ffmpeg-user/2017-February/035335.html" target="_blank" rel="noopener">https://lists.ffmpeg.org/pipermail/ffmpeg-user/2017-February/035335.html</a></li><li><a href="https://www.bookstack.cn/read/other-doc-cn-ffmpeg/ffmpeg-doc-cn-40.md" target="_blank" rel="noopener">https://www.bookstack.cn/read/other-doc-cn-ffmpeg/ffmpeg-doc-cn-40.md</a></li></ol><hr><h2 id="THE-END"><a href="#THE-END" class="headerlink" title="THE END! "></a><font color="red">THE END! </font></h2>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 视频处理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> YUV </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>视频编码中的块效应、振铃效应和呼吸效应分析</title>
      <link href="/2018/05/28/%E3%80%90Codecs%E7%B3%BB%E5%88%97%E3%80%91%E8%A7%86%E9%A2%91%E7%BC%96%E7%A0%81%E4%B8%AD%E7%9A%84%E5%9D%97%E6%95%88%E5%BA%94%E3%80%81%E6%8C%AF%E9%93%83%E6%95%88%E5%BA%94%E5%92%8C%E5%91%BC%E5%90%B8%E6%95%88%E5%BA%94%E5%88%86%E6%9E%90/"/>
      <url>/2018/05/28/%E3%80%90Codecs%E7%B3%BB%E5%88%97%E3%80%91%E8%A7%86%E9%A2%91%E7%BC%96%E7%A0%81%E4%B8%AD%E7%9A%84%E5%9D%97%E6%95%88%E5%BA%94%E3%80%81%E6%8C%AF%E9%93%83%E6%95%88%E5%BA%94%E5%92%8C%E5%91%BC%E5%90%B8%E6%95%88%E5%BA%94%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="1、块效应"><a href="#1、块效应" class="headerlink" title="1、块效应"></a>1、块效应</h2><p>（1）概念：</p><pre><code> 主要是由视频图像采用基于块的编码方式和量化造成相邻块之间存在明显差异的现象，在视频编码中人眼察觉到的小块边界处的不连续。</code></pre><p>（2）产生原因：</p><p>1、编码过程中对残差进行DCT变换是基于块的，使得块与块之间的相关性被忽略了；</p><p>2、对DCT系数进行量化，不同的图像块做了不同的处理。</p><p>（3）解决方案：</p><p>  在视频编码中，为了解决或减小块效应，很多视频编码标准（H264，H265，SVAC）中采用了去块滤波Deblock的方案。</p><h2 id="2、振铃效应"><a href="#2、振铃效应" class="headerlink" title="2、振铃效应"></a>2、振铃效应</h2><p>（1）概念：</p><pre><code>图像处理中，对一幅图像进行滤波处理，若选用的频域滤波器具有陡峭的变化，则会使滤波图像产生“振铃”，所谓“振铃”，就是指输出图像的灰度剧烈变化处产生的震荡，就好像钟被敲击后产生的空气震荡。</code></pre><p>（2）产生原因：</p><p>   主要是由于DCT变换后对高频分量进行滤波操作导致。</p><p>（3）解决方案：</p><p>   在视频编码中，为了解决或减小振铃效应，H265和SVAC2中采用了SAO样点滤波偏移的方案。</p><h2 id="3、呼吸效应"><a href="#3、呼吸效应" class="headerlink" title="3、呼吸效应"></a>3、呼吸效应</h2><p>（1）概念：</p><p>   视频编码中的呼吸效应是指由于I帧的插入造成图像质量忽然变好，切换到P帧后又忽然变差。</p><p>在视频监控中，为了保证传输，通常会把I帧编小，在这种情况下，会导致I帧质量变差的时候画质突然变差然后再慢慢变好，怎么解决呼吸效应？</p><p>（2）分析：</p><p>呼吸效应在静止的场景下比较容易观察出来，运动场景中，大部分的图像内容都在变化，不容易发现。尤其在低码率的视频监控场景下，呼吸效应比较明显。</p><p>产生的主要原因：I帧和P帧的编码模式和编码质量的不同，导致视觉上图像不连续。</p><p>（3）解决方案：</p><p>一般情况下，CBR（固定码率）码控方式比CQP（固定QP）的呼吸效应更加严重。因此将码控模式修改为CQP方式在一定程度上可以减弱呼吸效应。<br>H264/5可以调节I帧P帧直接qp的偏差，控制I帧和P帧的大小比例关系，I帧的qp越小，I帧越大，图像越清楚，在一定程度上提升了整体图像质量，呼吸效应在一定程度上可以得到缓解；但是I帧也不能调的过大，在CBR模式下，I帧把全部带宽都吃掉了，P帧就只能编的更模糊一些，反而加重了呼吸效应；在实际调节过程中，就是通过调整intraQpDelta/intraQpOffset这类的参数来调节I帧大小；在ISP中，如果有3DSR功能，针对静止场景，可以有效改善呼吸效应。该解决方案参考：<a href="https://blog.csdn.net/szfhy/article/details/79882903" target="_blank" rel="noopener">https://blog.csdn.net/szfhy/article/details/79882903</a><br>HISI提出了前滤波编码的方案，基于HISI编码器的硬件实现，对I帧的编码数据进行滤波操作然后再编码，可以改善呼吸效应，对应MPI接口为HI_MPI_VENC_GetDeBreathEffect和HI_MPI_VENC_SetDeBreathEffect。<br>HISI芯片解决方案中，各种码率控制方式中都提供了s32IPQpDelta参数用于调节呼吸效应，该值表示I帧相对P帧的QP差值，正数表示I帧QP小于P帧的QP。<br>有童鞋知道更好的解决方案吗？</p><hr><h2 id="THE-END"><a href="#THE-END" class="headerlink" title="THE END! "></a><font color="red"><strong>THE END!</strong> </font></h2>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 编解码 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Codecs </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>YUV处理工具：文件拼接</title>
      <link href="/2018/05/28/%E3%80%90Codecs%E7%B3%BB%E5%88%97%E3%80%91YUV%E5%A4%84%E7%90%86%E5%B7%A5%E5%85%B7%EF%BC%9A%E6%96%87%E4%BB%B6%E6%8B%BC%E6%8E%A5%E5%8A%9F%E8%83%BD/"/>
      <url>/2018/05/28/%E3%80%90Codecs%E7%B3%BB%E5%88%97%E3%80%91YUV%E5%A4%84%E7%90%86%E5%B7%A5%E5%85%B7%EF%BC%9A%E6%96%87%E4%BB%B6%E6%8B%BC%E6%8E%A5%E5%8A%9F%E8%83%BD/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="1、功能说明"><a href="#1、功能说明" class="headerlink" title="1、功能说明"></a>1、功能说明</h2><p>YUV文件拼接，可以设置两个YUV文件的帧数，将两个YUV文件的三个分量顺序拼接，只支持YUV420P采样格式。</p><h2 id="2、增加功能"><a href="#2、增加功能" class="headerlink" title="2、增加功能"></a>2、增加功能</h2><p>Modified: 2018-09-20 Soaringlee</p><ul><li>输入YUV文件长度检查，需要拼接的文件长度不能超过YUV本身长度；</li><li>可以设置两幅YUV分别重复的次数。</li></ul><h2 id="3、功能实现-C语言"><a href="#3、功能实现-C语言" class="headerlink" title="3、功能实现(C语言)"></a>3、功能实现(C语言)</h2><pre><code>#include &quot;stdio.h&quot;#include &quot;stdlib.h&quot;#include &quot;string.h&quot;int main(int argc, char** argv){    unsigned char* y;    FILE* fp_yuv1, *fp_yuv2, *fp_yuv3;    int width, height, len1, len2, picturesize;    int i, yuv_len1, yuv_len2, dup1, dup2, total_frm_num1, total_frm_num2, dup1_b, dup2_b;    if (argc &lt; 10)    {     printf(&quot;Usage: connectYUV.exe src2file src2file dstfile width height len1 len2 dup1 dup2\n\n&quot;);         printf(&quot;Notice: the width and height of those two yuv must be same!!!\n&quot;);         printf(&quot;Notice: dup1 is the number of replication for srcfile1, and dup2 is the number of replicaiton for srcfile2.\n&quot;);         return -1;    }        for(i=0; i&lt;argc;i++)        {          printf(&quot;%s &quot;, argv[i]);        }        printf(&quot;\n&quot;);    fp_yuv1 = fopen(argv[1], &quot;rb&quot;);    if (NULL == fp_yuv1)    {        printf(&quot;ERROR: open %s fail!\n&quot;, argv[1]);        return -1;    }    fp_yuv2 = fopen(argv[2], &quot;rb&quot;);    if (NULL == fp_yuv2)    {        printf(&quot;ERROR: open %s fail!\n&quot;, argv[2]);        return -1;    }    fp_yuv3 = fopen(argv[3], &quot;wb&quot;);    if (NULL == fp_yuv3)    {        printf(&quot;ERROR: open %s fail!\n&quot;, argv[3]);        return -1;    }    width = atoi(argv[4]);    height = atoi(argv[5]);    len1 = atoi(argv[6]);    len2 = atoi(argv[7]);    dup1 = atoi(argv[8]);    dup2 = atoi(argv[9]);    picturesize = width *height * 3 / 2; //++YUV420    // yuv输入长度检查    fseek(fp_yuv1, 0, SEEK_END);    yuv_len1 = ftell(fp_yuv1);    total_frm_num1 = yuv_len1 / picturesize;    printf(&quot;total_frame_num1: %d\n&quot;, total_frm_num1);    fseek(fp_yuv1, 0, SEEK_SET);    fseek(fp_yuv2, 0, SEEK_END);    yuv_len2 = ftell(fp_yuv2);    total_frm_num2 = yuv_len2 / picturesize;    printf(&quot;total_frame_num2: %d\n&quot;, total_frm_num2);    fseek(fp_yuv2, 0, SEEK_SET);    if( len1 &gt; total_frm_num1 || len2 &gt; total_frm_num2)    {        printf(&quot;ERROR: len1 &gt; frame_num1 or len2 &gt; frame_num2!\n&quot;);        return -1;    }    y = (unsigned char*)malloc(picturesize*sizeof(unsigned char*));    if (NULL == y)    {        printf(&quot;ERROR: malloc y fail!\n&quot;);    }    do{    for (i = 0; i &lt; len1; i++)    {        if (fread(y, 1, picturesize, fp_yuv1) == picturesize)        {            fwrite(y, 1, picturesize, fp_yuv3);        }    }        fseek(fp_yuv1, 0, SEEK_SET);//  特别注意，每次读取之后需要重置读指针位置。        dup1--;       } while(dup1);    do{    for (i = 0; i &lt; len2; i++)    {        if (fread(y, 1, picturesize, fp_yuv2) == picturesize)        {            fwrite(y, 1, picturesize, fp_yuv3);        }    }       fseek(fp_yuv2, 0, SEEK_SET); // 特别注意，每次读取之后需要重置读指针位置。       dup2--;    } while(dup2);    printf(&quot;connect yuv %s and %s ==&gt; %s successfully, total frames: %d\n&quot;, argv[1], argv[2], argv[3], len1*dup1_b+len2*dup2_b);    free(y);    y = NULL;    fclose(fp_yuv1);    fclose(fp_yuv2);    fclose(fp_yuv3);    return 0;}</code></pre><h2 id="THE-END"><a href="#THE-END" class="headerlink" title="THE END! "></a><font color="red">THE END! </font></h2>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 视频处理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> YUV </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>YUV处理工具：文件比较功能</title>
      <link href="/2018/05/21/%E3%80%90Codecs%E7%B3%BB%E5%88%97%E3%80%91YUV%E5%A4%84%E7%90%86%E5%B7%A5%E5%85%B7%EF%BC%9A%E6%96%87%E4%BB%B6%E6%AF%94%E8%BE%83%E5%8A%9F%E8%83%BD/"/>
      <url>/2018/05/21/%E3%80%90Codecs%E7%B3%BB%E5%88%97%E3%80%91YUV%E5%A4%84%E7%90%86%E5%B7%A5%E5%85%B7%EF%BC%9A%E6%96%87%E4%BB%B6%E6%AF%94%E8%BE%83%E5%8A%9F%E8%83%BD/</url>
      
        <content type="html"><![CDATA[<p>Tags: YUV处理工具：文件比较功能</p><p>[TOC]</p><h2 id="1、方法一-将YUV读取到buffer中，然后每帧逐字节比较。C语言实现"><a href="#1、方法一-将YUV读取到buffer中，然后每帧逐字节比较。C语言实现" class="headerlink" title="1、方法一: 将YUV读取到buffer中，然后每帧逐字节比较。C语言实现"></a>1、方法一: 将YUV读取到buffer中，然后每帧逐字节比较。C语言实现</h2><pre><code class="c">#include&lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string&gt;int main(int argc, char **argv){    FILE *fin_1 = NULL;    FILE *fin_2 = NULL;    FILE *fout = NULL;    int srcwidth = 0, srcheight = 0;    int framesize = 0, in1_size = 0, in2_size = 0;    int srcframenum = 0;    unsigned char *buffer1 = NULL;    unsigned char *buffer2 = NULL;    if (argc!=5)    {        printf(&quot;Usage: CompareYUV.exe yuv0 yuv1 width height&quot;);        return -1;    }    fin_1 = fopen(argv[1],&quot;rb&quot;);    if (!fin_1)    {        printf(&quot;Open input yuv0 failed!\n&quot;);    }    fin_2 = fopen(argv[2], &quot;rb&quot;);    if (!fin_2)    {        printf(&quot;Open input yuv1 failed!\n&quot;);    }    fout = fopen(&quot;compare_result.txt&quot;, &quot;a+&quot;);    if (!fout)    {        printf(&quot;Open compare_result.txt failed!\n&quot;);    }    srcwidth = atoi(argv[3]);//width    srcheight = atoi(argv[4]);//height    framesize = srcheight*srcwidth * 3 / 2;//++YUV420采样格式    buffer1 = (unsigned char *)malloc(framesize*sizeof(unsigned char*));    buffer2 = (unsigned char *)malloc(framesize*sizeof(unsigned char*));    if ((buffer1 == NULL) ||(buffer2 == NULL))    {        printf(&quot;malloc buffer1 or buffer2 failed!\n&quot;);    }    fprintf(fout, &quot;%s VS %s!    &quot;, argv[1], argv[2]);    while ((fread(buffer1, 1, framesize, fin_1) == framesize)&amp;&amp;(fread(buffer2, 1, framesize, fin_2) == framesize))    {        int i = 0;        for (i = 0; i &lt; framesize; i++)        {            if (buffer1[i] != buffer2[i])            {                fprintf(fout, &quot;framenum:%d  &quot;, srcframenum);                fprintf(fout, &quot;DISMATCH!\n&quot;);                return -1;            }        }        srcframenum++;    }    fprintf(fout, &quot;framenum:%d  &quot;, srcframenum);    fprintf(fout, &quot;MATCH!\n&quot;);    free(buffer1);    buffer1 = NULL;    free(buffer2);    buffer2 = NULL;    fclose(fin_1);    fclose(fin_2);    fclose(fout);    return 0;}</code></pre><h2 id="2、方法二：Python中filecmp模块"><a href="#2、方法二：Python中filecmp模块" class="headerlink" title="2、方法二：Python中filecmp模块"></a>2、方法二：Python中filecmp模块</h2><p>filecmp模块用于比较文件及文件夹的内容，它是一个轻量级的工具，使用非常简单。python标准库还提供了difflib模块用于比较文件的内容。</p><p>filecmp定义了两个函数，用于方便地比较文件与文件夹：</p><pre><code class="c">filecmp.cmp(f1, f2[, shallow])</code></pre><p>比较两个文件的内容是否匹配。参数f1, f2指定要比较的文件的路径。可选参数shallow指定比较文件时是否需要考虑文件本身的属性（通过os.stat函数可以获得文件属性）。如果文件内容匹配，函数返回True，否则返回False。</p><h2 id="3、两种方法的比较说明"><a href="#3、两种方法的比较说明" class="headerlink" title="3、两种方法的比较说明"></a>3、两种方法的比较说明</h2><p>说明：第一种C实现的方法比较基础，第二种Python函数的方法比较简洁。</p><h2 id="THE-END"><a href="#THE-END" class="headerlink" title="THE END! "></a><font color="red">THE END! </font></h2>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 视频处理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> YUV </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言中两种结构体成员初始化方式：顺序和乱序</title>
      <link href="/2018/05/14/%E3%80%90C%E7%B3%BB%E5%88%97%E3%80%91%E4%B8%A4%E7%A7%8D%E7%BB%93%E6%9E%84%E4%BD%93%E6%88%90%E5%91%98%E5%88%9D%E5%A7%8B%E5%8C%96%E6%96%B9%E5%BC%8F%EF%BC%9A%E9%A1%BA%E5%BA%8F%E5%92%8C%E4%B9%B1%E5%BA%8F/"/>
      <url>/2018/05/14/%E3%80%90C%E7%B3%BB%E5%88%97%E3%80%91%E4%B8%A4%E7%A7%8D%E7%BB%93%E6%9E%84%E4%BD%93%E6%88%90%E5%91%98%E5%88%9D%E5%A7%8B%E5%8C%96%E6%96%B9%E5%BC%8F%EF%BC%9A%E9%A1%BA%E5%BA%8F%E5%92%8C%E4%B9%B1%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>&ensp; &ensp;   C语言中的结构体类型在进行成员初始化时，我们通常采用顺序初始化的方式。今天，在看同事写的代码时，发现还可以采用乱序的方式进行初始化，并且这种方式可以明确指定每个成员的值，看起来比较清晰。</p><h2 id="1、参考"><a href="#1、参考" class="headerlink" title="1、参考"></a>1、参考</h2><p><a href="https://blog.csdn.net/m0_38023255/article/details/78860458" target="_blank" rel="noopener">关于linux中内核编程中结构体的赋值操作 （结构体指定初始化）</a><br><a href="https://www.cnblogs.com/aaronLinux/p/5768615.html" target="_blank" rel="noopener">C基础–结构体成员初始化方式</a><br><a href="https://blog.csdn.net/shaohuiyang/article/details/77621461" target="_blank" rel="noopener">浅谈结构体内变量赋值问题</a><br><a href="https://www.cnblogs.com/tangshiguang/p/6735402.html" target="_blank" rel="noopener">C—动态内存分配之malloc与realloc的区别</a></p><h2 id="2、两种结构体成员初始化方式：顺序和乱序"><a href="#2、两种结构体成员初始化方式：顺序和乱序" class="headerlink" title="2、两种结构体成员初始化方式：顺序和乱序"></a>2、两种结构体成员初始化方式：顺序和乱序</h2><p><strong>顺序：</strong></p><pre><code class="c">typedef struct _data_t {    int a;    int b;}data_t;data_t data = {10,20};</code></pre><p><strong>乱序：</strong></p><pre><code class="c">typedef struct _data_t {    int a;    int b;}data_t;data_t data = {   .a = 10,   .b = 20,};</code></pre><h2 id="3、编程实战"><a href="#3、编程实战" class="headerlink" title="3、编程实战"></a>3、编程实战</h2><pre><code class="c">#include &lt;stdio.h&gt;#include &lt;Windows.h&gt;typedef struct _circle_s{    float radius;    int perimeter;} circle_s;int main(int argc, char **argv){#if 0 //结构体顺序初始化    circle_s cir = {10.0, 20};#endif#if 1 //结构体乱序初始化，需要支持C99规范的编译器支持    circle_s cir =    {        .radius = 20.0,        .perimeter = 40,    };#endif    printf(&quot;radius: %f, perimeter: %d\n&quot;, cir.radius, cir.perimeter);    system(&quot;pause&quot;);    return 0;}</code></pre><blockquote><p>注：</p><ul><li>结构体乱序初始化是C99中的新特性，需要支持C99规范的编译器支持，比如VS2013编译器cl.exe，但是VS2010编译器就不支持C99规范（支持C89规范）。</li><li>linux内核中就是采用乱序这种方式初始化struct。</li></ul></blockquote><h2 id="THE-END"><a href="#THE-END" class="headerlink" title="THE END! "></a><font color="red">THE END! </font></h2><hr>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python中获取当前目录和子目录下所有文件或指定文件的方法</title>
      <link href="/2018/05/08/%E3%80%90Python%E7%B3%BB%E5%88%97%E3%80%91Python%E4%B8%AD%E8%8E%B7%E5%8F%96%E5%BD%93%E5%89%8D%E7%9B%AE%E5%BD%95%E5%92%8C%E5%AD%90%E7%9B%AE%E5%BD%95%E4%B8%8B%E6%89%80%E6%9C%89%E6%96%87%E4%BB%B6%E6%88%96%E6%8C%87%E5%AE%9A%E6%96%87%E4%BB%B6%E7%9A%84%E6%96%B9%E6%B3%95/"/>
      <url>/2018/05/08/%E3%80%90Python%E7%B3%BB%E5%88%97%E3%80%91Python%E4%B8%AD%E8%8E%B7%E5%8F%96%E5%BD%93%E5%89%8D%E7%9B%AE%E5%BD%95%E5%92%8C%E5%AD%90%E7%9B%AE%E5%BD%95%E4%B8%8B%E6%89%80%E6%9C%89%E6%96%87%E4%BB%B6%E6%88%96%E6%8C%87%E5%AE%9A%E6%96%87%E4%BB%B6%E7%9A%84%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="方法一：os-listdir"><a href="#方法一：os-listdir" class="headerlink" title="方法一：os.listdir()"></a>方法一：os.listdir()</h2><pre><code>（1）获取当前目录及子目录下所有文件路径列表：getallfiles.pyimport osimport sysallfile = []def get_all_file(rawdir):      allfilelist=os.listdir(rawdir)      for f in allfilelist:            filepath=os.path.join(rawdir,f)            if os.path.isdir(filepath):                  get_all_file(filepath)            allfile.append(filepath)      return allfileif __name__==&#39;__main__&#39;:      if(len(sys.argv) &lt; 2):            print(&quot;Usage: getallfiles.py rawdir&quot;)            exit()      rawdir = sys.argv[1]      #current = os.getcwd()      allfiles = get_all_file(rawdir)      print allfiles</code></pre><p>在命令行中输入:python getallfiles.py E:\</p><p>就会列出E盘下面所有目录（包括子目录）下的所有文件。</p><p>（2）获取当前目录及子目录下指定格式文件路径：get_format_files.py</p><pre><code># _*_coding=UTF-8_*_import osimport reimport sys##获取指定目录下指定格式的所有文件路径列表def get_format_file(rawdir):    isfile = 0    if os.path.isdir(rawdir):        allfiles = os.listdir(rawdir)        files = [rawdir+&quot;/&quot;+f for f in allfiles if re.search(&#39;txt$&#39;,f)]    elif os.path.isfile(rawdir):        iffile = 1        files = [rawdir]    else:        files = []        print(&quot;ERROR: &quot;+ rawdir+&quot; is not a dir or file!&quot;)    return [files, isfile]#获取文件名称def get_file_name(fullfilename):    tmp = fullfilename.strip() #去除前后不必要的空格    name = os.path.split(tmp)[-1] # 提取文件名,不包含路径    return os.path.splitext(name)[0] #提取文件名,不包含后缀</code></pre><p>在命令行中输入:python get_format_files.py E:\</p><p>就会列出E盘下面所有目录（包括子目录）下的指定格式的所有文件。</p><h2 id="方法二：os-walk"><a href="#方法二：os-walk" class="headerlink" title="方法二：os.walk()"></a>方法二：os.walk()</h2><p>（1）获取当前目录及子目录下所有文件路径列表：getallfiles_v2.py</p><pre><code>import osimport sysallfiles = []def get_all_file(rawdir):      for root,dirs,files in os.walk(rawdir):            for f in files:                  #if(re.search(&#39;mp4$&#39;),f):                  allfiles.append(os.path.join(root,f))            for dirname in dirs:                  get_all_file(os.path.join(root,dirname))      return allfilesif __name__==&#39;__main__&#39;:      if(len(sys.argv) &lt; 2):            print(&quot;Usage: getallfiles.py rawdir&quot;)            exit()      rawdir = sys.argv[1]      #current = os.getcwd()      allfiles = get_all_file(rawdir)      print allfiles</code></pre><p>在命令行中输入:python getallfiles_v2.py E:\</p><p>就会列出E盘下面所有目录（包括子目录）下的所有文件。</p><h2 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h2><p><a href="https://www.cnblogs.com/sudawei/archive/2013/09/29/3346055.html" target="_blank" rel="noopener">https://www.cnblogs.com/sudawei/archive/2013/09/29/3346055.html</a></p><p><a href="https://blog.csdn.net/KGzhang/article/details/72964785" target="_blank" rel="noopener">https://blog.csdn.net/KGzhang/article/details/72964785</a></p><h2 id="THE-END"><a href="#THE-END" class="headerlink" title=" THE END! "></a><font color="red"> THE END! </font></h2>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python中执行可执行文件的四种方法</title>
      <link href="/2018/05/08/%E3%80%90Python%E7%B3%BB%E5%88%97%E3%80%91Python%E4%B8%AD%E6%89%A7%E8%A1%8C%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6%E7%9A%84%E5%9B%9B%E7%A7%8D%E6%96%B9%E6%B3%95/"/>
      <url>/2018/05/08/%E3%80%90Python%E7%B3%BB%E5%88%97%E3%80%91Python%E4%B8%AD%E6%89%A7%E8%A1%8C%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6%E7%9A%84%E5%9B%9B%E7%A7%8D%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><p>分类：Python函数用法</p><p>主要分析一下subprocess.call,subprocess.Popen与os.system，os.popen调用命令的用法与区别</p><h2 id="1、subprocess-call"><a href="#1、subprocess-call" class="headerlink" title="1、subprocess.call( )"></a>1、subprocess.call( )</h2><pre><code class="python">import subprocessret = subprocess.call(cmd,shell=True)</code></pre><p>cmd命令行中可以是字符串或者是序列（字符串列表list）的形式，shell=True表示会让subprocess.call接受字符串类型的变量作为命令，并调用shell去执行这个字符串，当shell=False时，subprocess.call只接受数组变量作为命令，并将数组的第一个元素作为命令，剩下的全部作为该命令的参数。</p><p>ret表示返回的可执行文件的返回值。</p><h2 id="2、subprocess-Popen"><a href="#2、subprocess-Popen" class="headerlink" title="2、subprocess.Popen()"></a>2、subprocess.Popen()</h2><pre><code>import subprocess  proc = subprocess.Popen(&#39;cmd&#39;, shell=True)  proc.communicate()  ret = proc.returncodeor：import subprocess  proc = subprocess.Popen(&#39;cmd&#39;, shell=True)  ret = proc.wait()</code></pre><p>用法同上，ret返回的是可执行文件的返回值。</p><h2 id="3、os-system"><a href="#3、os-system" class="headerlink" title="3、os.system()"></a>3、os.system()</h2><pre><code>import osret = os.system(cmd)</code></pre><p>需要注意的是，ret返回的是脚本的退出状态码。</p><h2 id="4、os-popen"><a href="#4、os-popen" class="headerlink" title="4、os.popen()"></a>4、os.popen()</h2><pre><code>import osret=os.popen(cmd)</code></pre><p>需要注意的是，ret返回的是可执行文件的返回值，不是脚本的退出状态码。</p><h2 id="THE-END"><a href="#THE-END" class="headerlink" title=" THE END!"></a><font color="red"> THE END!</font></h2>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DSP通用优化方法</title>
      <link href="/2018/02/18/%E3%80%90%E4%BC%98%E5%8C%96%E7%B3%BB%E5%88%97%E3%80%91%E4%B9%8BDSP%E4%BC%98%E5%8C%96%E6%96%B9%E6%B3%95/"/>
      <url>/2018/02/18/%E3%80%90%E4%BC%98%E5%8C%96%E7%B3%BB%E5%88%97%E3%80%91%E4%B9%8BDSP%E4%BC%98%E5%8C%96%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="1、参考"><a href="#1、参考" class="headerlink" title="1、参考"></a>1、参考</h2><p><a href="https://blog.csdn.net/xhttmq/article/details/54913039" target="_blank" rel="noopener">TI DSP TMS320C66x学习笔记之DSP优化经验</a></p><h2 id="2、DSP介绍和特点"><a href="#2、DSP介绍和特点" class="headerlink" title="2、DSP介绍和特点"></a>2、DSP介绍和特点</h2><p>DSP是英文Digital Signal Process的简称，即数字信号处理器，DSP芯片内部采用程序和数据分开的哈佛结构，具有特殊的DSP指令和不同的功能单元，实现多级流水操作，完成并行计算。可以用来快速实现各种数字信号处理算法。</p><p>DSP特点：<br>DSP芯片一般具有如下的一些主要特点：</p><ul><li>单指令周期内可完成一次乘法和一次加法；</li><li>程序和数据空间分开，可以同时访问指令和数据；</li><li>可以并行执行多个操作；</li><li>流水线操作，使取指、译码和执行等操作可以重叠执行。</li></ul><h2 id="3、DSP常用优化方法"><a href="#3、DSP常用优化方法" class="headerlink" title="3、DSP常用优化方法"></a>3、DSP常用优化方法</h2><h3 id="3-1、DMA"><a href="#3-1、DMA" class="headerlink" title="3.1、DMA"></a>3.1、DMA</h3><p>DMA：直接存储器存储模式，通常用于DDR和L2之间交换数据，这样可以减少Cache miss，加快DDR的读写速度，提高数据传输速率。<br>在DMA模式下，CPU只须向DMA控制器下达指令，让DMA控制器来处理数据的传送，数据传送完毕再把信息反馈给CPU，这样就很大程度上减轻了CPU资源占用率，可以大大节省系统资源。<br><strong>DMA传输：</strong><br>在实现DMA传输时，是由DMA控制器直接掌管总线，因此，存在着一个总线控制权转移问题。即DMA传输前，CPU要把总线控制权交给DMA控制器。而在结束DMA传输后，DMA控制器应立即把总线控制权再交回给CPU。</p><p>一个完整的DMA传输过程经过下面3个步骤：<br>CPU初始化DMA—-&gt;DMA启动—–&gt;DMA完成数据拷贝<br><strong>DMA常用技巧：</strong><br>乒乓操作<br>A组：数据拷贝—》数据计算—-》数据拷贝—-》数据计算<br>B组：初始化—–》数据拷贝—–》数据计算—-》数据拷贝</p><h3 id="3-2、编译选项"><a href="#3-2、编译选项" class="headerlink" title="3.2、编译选项"></a>3.2、编译选项</h3><p>参考自：<a href="https://blog.csdn.net/xhttmq/article/details/54913039" target="_blank" rel="noopener">TI DSP TMS320C66x学习笔记之DSP优化经验</a></p><h4 id="3-2-1、-c6x的编译的常用选项"><a href="#3-2-1、-c6x的编译的常用选项" class="headerlink" title="3.2.1、 c6x的编译的常用选项"></a>3.2.1、 c6x的编译的常用选项</h4><p><strong>（一）c6x的编译程序为“cl6x.exe”使用的方法</strong></p><pre><code>Cl6x [options] [filenames]</code></pre><p>Cl6x：   编译程序<br>Options：  编译选项<br>Filenames：  C或汇编源文件</p><blockquote><p>说明：<br>编译选项是一个字母或者两个字母，对大小写不敏感。<br>编译选项的前面需要有一个“－”符号。<br>一个字母的选项可以合并在一起。比如“－sgq”与“－s －g －q”相同。<br>两个字母的选项如果第一个字母相同也可以合并在一起。比如“－mgt”与“－mg －mt”相同。</p></blockquote><p><strong>（二）有关优化的选项</strong></p><pre><code>-mt：   表示在程序中没有使用alaising技术，这使得编译器可以进行比较好的优化。-o3：   对文件级别进行最强的优化，一般在编译时应该使用这个选项。但是在个别情况下使用这个选项优化程序可能会出现错误（-o2有相同现象，-o0和-o1不会出现错误）。可能是在优化循环，组织流水线的时候发生错误。如果有这种现象出现可以同时使用-g选项，程序优化就不会出现错误，但是优化效果会下降。另外可以调整程序的表达方式，可能会避免编译器发生错误。-pm：   在程序级别进行优化。可以将所以文件联合在一起进行优化，主要有去掉没有被调用的函数、总是常数的变量以及没有使用的函数返回值。建议由程序员自己进行这种优化工作。使用这个选项在win98下编译可能会出现找不到编译程序的情况。-ms0：  不使用冗余循环进行优化，减小程序的大小。一般情况下这个选项对程序大小的优化作用不明显。-mh[n]：去掉流水线的epilog，减小程序的大小。这个选项的作用比较明显。但是有可能出现读取地址超出有效范围的问题，所以要在数据段的开始和结尾处增加一些pading，或者在分配内存时保证数组的前面和后面一段范围内都是有效的地址。可选的参数n给出这种pading的长度字节数。</code></pre><p><strong>（三）保留编译和优化信息的选项</strong></p><pre><code>-k： 保留优化后生成汇编语言文件。-s： 汇编语言文件中加入优化信息，如果没有则加入C语言源程序作为注释。-mw：在汇编语言文件加入软件流水线信息。</code></pre><p><strong>（四）有关调试和剖析的选项</strong></p><pre><code>-g： 允许符号调试，在“out”文件中包含符号信息和行号信息，可以在c语言级别进行调试和剖析。使用联合使用－g、－mt和－o3可以保证能够进行符号调试的情况下最大限度的优化。-mg：允许profile优化后的程序。 在“out”文件中包含符号信息和很少的行号信息。允许在c语言的函数基本进行剖析。如果联合使用这两个选项，－g选项可能被忽略，结果与只用－mg相同。</code></pre><p><strong>（五）其它类型</strong></p><pre><code>-mln： 生成大内存模式的程序。-ml0： 缺省情况下将集合变量（数组和结构）作为far型。-ml1： 缺省情况下将全部函数作为far型-ml2： 等于-ml0加-ml1-ml3： 缺省情况下将全部数据和函数作为far型</code></pre><p><strong>（六）建议使用的编译方式</strong></p><pre><code>Cl6x －gk －mt －o3 －mw －ss  “filename”方式1用于程序的调试，这种方式具有比较强的优化能力，并且支持符号调试。在编译的过程中不会发生错误。由于生成的“out”文件中包含了符号信息和行号信息，所以比较大。Cl6x －k －mgt －o3 －mw －ss  “filename”方式2用于程序的剖析（profile），这种方式的优化能力几乎最强（绝大多数情况下与方式3相同），并且支持对程序进行profile。文件中只包含了符号信息和很少的行号信息，所以“out”文件比较小。Cl6x －k －mt －o3 －mw －ss  “filename”方式3用于最终的发行版本程序，可以对程序进行最强的优化，并且去掉了全部的符号和行号信息，所以“out”文件比较小。由多个文件组成的程序应该编写makefile，将编译参数放在该文件中，并在其中说明使用的编译器的版本号。</code></pre><p><strong>（七）连接参数</strong></p><pre><code>－heap： 指定堆的大小－stack： 指定栈的大小连接的各种选项应该统一放在“cmd”文件中</code></pre><h3 id="3-3、C代码优化"><a href="#3-3、C代码优化" class="headerlink" title="3.3、C代码优化"></a>3.3、C代码优化</h3><h4 id="3-3-1、使用内嵌函数Intrinsic"><a href="#3-3-1、使用内嵌函数Intrinsic" class="headerlink" title="3.3.1、使用内嵌函数Intrinsic"></a>3.3.1、使用内嵌函数Intrinsic</h4><p>TMS320C6000提供的内嵌函数是一种直接映射为内嵌TMS320C6000汇编指令的特殊函数，调用内嵌函数对程序的可读性影响不大，同时可以达到优化效果。内嵌函数用下划线（_）开头，使用方法同调用普通函数一样。</p><p>例如：_dotpu4, _extu<br>举个例子：</p><pre><code>for(j=0; j&lt;width; j++){  sum += data[j];}</code></pre><p>使用内嵌函数优化后：</p><pre><code>for(j=0; j&lt;width; j++){  sum += _dotpu4(_amem4(data[j],0x01010101));}</code></pre><h4 id="3-3-2、利用软件流水"><a href="#3-3-2、利用软件流水" class="headerlink" title="3.3.2、利用软件流水"></a>3.3.2、利用软件流水</h4><p>软件用于安排循环指令，使循环的多次迭代以并行方式执行，这也是DSP主频低、效率高的主要原因。当使用编译器的-o2和-o3选项时，编译器使用软件流水优化源代码并且从程序中收集相关的优化信息。</p><h4 id="3-3-3、循环处理"><a href="#3-3-3、循环处理" class="headerlink" title="3.3.3、循环处理"></a>3.3.3、循环处理</h4><p>（1）循环计数：逆序计数效率更高。<br>（2）消除冗余循环<br>（3）循环展开</p><hr><h2 id="THE-END"><a href="#THE-END" class="headerlink" title=" THE END! "></a><font color="red"> THE END! </font></h2>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 优化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DSP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Valgrind工具检测内存错误实例分析</title>
      <link href="/2017/10/15/%E3%80%90Tools%E7%B3%BB%E5%88%97%E3%80%91Valgrind%E5%B7%A5%E5%85%B7%E6%A3%80%E6%B5%8B%E5%86%85%E5%AD%98%E9%94%99%E8%AF%AF%E5%AE%9E%E4%BE%8B%E5%88%86%E6%9E%90/"/>
      <url>/2017/10/15/%E3%80%90Tools%E7%B3%BB%E5%88%97%E3%80%91Valgrind%E5%B7%A5%E5%85%B7%E6%A3%80%E6%B5%8B%E5%86%85%E5%AD%98%E9%94%99%E8%AF%AF%E5%AE%9E%E4%BE%8B%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<p>Tag: Valgrind工具检测内存错误<br>[TOC]</p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>&ensp; &ensp; Valgrind是一个检测内存问题的开源工具，可以用于检测linux下应用程序的内存泄漏问题。但是对于静态数组越界的问题，valgrind是检测不出来的，对于这个问题，可以采用converity静态检查。这个工具对于内存泄漏诊断非常有用，特整理下面相关问题。</p><h2 id="1、内存泄漏"><a href="#1、内存泄漏" class="headerlink" title="1、内存泄漏"></a>1、内存泄漏</h2><h3 id="1-1-错误提示"><a href="#1-1-错误提示" class="headerlink" title="1.1  错误提示"></a>1.1  错误提示</h3><pre><code>are definitely lost in loss</code></pre><h3 id="1-2-C源代码mem-leak-c"><a href="#1-2-C源代码mem-leak-c" class="headerlink" title="1.2  C源代码mem_leak.c"></a>1.2  C源代码mem_leak.c</h3><pre><code class="c">#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;void memcheck(){  char* p = (char*)malloc(20);}int main(){  memcheck();  return 0;}</code></pre><h3 id="1-3-使用命令"><a href="#1-3-使用命令" class="headerlink" title="1.3 使用命令"></a>1.3 使用命令</h3><pre><code>gcc -o memleak  -g  mem_check.cvalgrind --track-fds=yes --leak-check</code></pre><h3 id="1-4-检测结果"><a href="#1-4-检测结果" class="headerlink" title="1.4 检测结果"></a>1.4 检测结果</h3><p><img src="/img/20171015193538630.jpg" alt="检测结果"></p><h2 id="2、文件指针资源泄漏"><a href="#2、文件指针资源泄漏" class="headerlink" title="2、文件指针资源泄漏"></a>2、文件指针资源泄漏</h2><h3 id="2-1-错误提示"><a href="#2-1-错误提示" class="headerlink" title="2.1 错误提示"></a>2.1 错误提示</h3><pre><code>  FILE DESCRIPTORS:4 open at exit</code></pre><h3 id="2-2-源代码"><a href="#2-2-源代码" class="headerlink" title="2.2 源代码"></a>2.2 源代码</h3><pre><code class="c">#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;void fopencheck(){  FILE* p = fopen(&quot;test.txt&quot;,&quot;w&quot;);}int main(){  fopencheck();  return 0;}</code></pre><h3 id="2-3-测试结果"><a href="#2-3-测试结果" class="headerlink" title="2.3 测试结果"></a>2.3 测试结果</h3><p><img src="/img/20171015195349549.jpg" alt="测试结果"></p><h2 id="3、动态内存越界"><a href="#3、动态内存越界" class="headerlink" title="3、动态内存越界"></a>3、动态内存越界</h2><h3 id="3-1-错误提示"><a href="#3-1-错误提示" class="headerlink" title="3.1 错误提示"></a>3.1 错误提示</h3><pre><code>   Invalid write</code></pre><h3 id="3-2-源代码"><a href="#3-2-源代码" class="headerlink" title="3.2 源代码"></a>3.2 源代码</h3><pre><code class="c">#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;void memcheck(){  char* p = malloc(1);  *(short*)p = 2;  free(p);}int main(){  memcheck();  return 0;}</code></pre><h3 id="3-3-测试结果"><a href="#3-3-测试结果" class="headerlink" title="3.3 测试结果"></a>3.3 测试结果</h3><p><img src="/img/20171015200458150.jpg" alt="测试结果"></p><h2 id="4、无法检测数组越界"><a href="#4、无法检测数组越界" class="headerlink" title="4、无法检测数组越界"></a>4、无法检测数组越界</h2><h3 id="4-1错误提示"><a href="#4-1错误提示" class="headerlink" title="4.1错误提示"></a>4.1错误提示</h3><pre><code>     无法对分配在栈上的静态数组检测越界</code></pre><h3 id="4-2-源代码"><a href="#4-2-源代码" class="headerlink" title="4.2 源代码"></a>4.2 源代码</h3><pre><code class="c">#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;void memcheck(){   char array[3];   strcpy(array,&quot;hello&quot;);}int main(){  memcheck();  return 0;}</code></pre><h3 id="4-3-检测结果"><a href="#4-3-检测结果" class="headerlink" title="4.3 检测结果"></a>4.3 检测结果</h3><p><img src="/img/20171015201303623.jpg" alt="检测结果"></p><h2 id="5、内存释放两次或多次"><a href="#5、内存释放两次或多次" class="headerlink" title="5、内存释放两次或多次"></a>5、内存释放两次或多次</h2><h3 id="5-1-错误提示"><a href="#5-1-错误提示" class="headerlink" title="5.1 错误提示"></a>5.1 错误提示</h3><pre><code>  Invalid free()/delete/delete[]/realloc()</code></pre><h3 id="5-2-源代码"><a href="#5-2-源代码" class="headerlink" title="5.2 源代码"></a>5.2 源代码</h3><pre><code class="c">#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;void memcheck(){  char* p = (char*)malloc(20);   free(p);   free(p);}int main(){  memcheck();  return 0;}</code></pre><h3 id="5-3-测试结果"><a href="#5-3-测试结果" class="headerlink" title="5.3 测试结果"></a>5.3 测试结果</h3><p><img src="/img/20171015201642392.jpg" alt="测试结果"></p><h2 id="6、使用野指针"><a href="#6、使用野指针" class="headerlink" title="6、使用野指针"></a>6、使用野指针</h2><h3 id="6-1-错误提示"><a href="#6-1-错误提示" class="headerlink" title="6.1 错误提示"></a>6.1 错误提示</h3><pre><code>    Invalid write of size</code></pre><h3 id="6-2-源代码"><a href="#6-2-源代码" class="headerlink" title="6.2 源代码"></a>6.2 源代码</h3><pre><code class="c">#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;void memcheck(){  char* p = (void*)0x80808080;  *p = 10;}int main(){  memcheck();  return 0;}</code></pre><h3 id="6-3-测试结果"><a href="#6-3-测试结果" class="headerlink" title="6.3 测试结果"></a>6.3 测试结果</h3><p><img src="/img/20171015202025812.jpg" alt="测试结果"></p><h2 id="7、释放野指针"><a href="#7、释放野指针" class="headerlink" title="7、释放野指针"></a>7、释放野指针</h2><h3 id="7-1-错误提示"><a href="#7-1-错误提示" class="headerlink" title="7.1 错误提示"></a>7.1 错误提示</h3><pre><code>   Invalid free()/delete/delete[]/realloc()</code></pre><h3 id="7-2-源代码"><a href="#7-2-源代码" class="headerlink" title="7.2 源代码"></a>7.2 源代码</h3><pre><code class="c">#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;void memcheck(){  char* p;  free(p);}int main(){  memcheck();  return 0;}</code></pre><h3 id="7-3-测试结果"><a href="#7-3-测试结果" class="headerlink" title="7.3 测试结果"></a>7.3 测试结果</h3><p><img src="/img/20171015202216834.jpg" alt="测试结果"></p><h2 id="8、valgrind的主要参数"><a href="#8、valgrind的主要参数" class="headerlink" title="8、valgrind的主要参数"></a>8、valgrind的主要参数</h2><pre><code>-h  --help显示所有选项的帮助，包括内核和选定的工具。--help-debug与--help相同，并且还能显示通常只有valgrind的开发人员使用的调试选项。--version显示valgrind内核的版本号-q, --quiet安静的运行，只打印错误信息（被调试的程序错误信息）。-v, --verbose：显示详细信息。-tool=&lt;toolname&gt;[default:memcheck]运行toolname指定的Valgrind,例如：memcheck，addrcheck,cachegrind等。--log-file=&lt;file&gt;指定valgrind把它所有的信息输出到指定为文件中。--trace-children=&lt;yes|no&gt;[default:no]当这个选项打开时，valgrind会跟踪到子进程中，这通常会导致困惑，而且通常不是你所期望的，默认关闭。</code></pre><h2 id="9、常见错误"><a href="#9、常见错误" class="headerlink" title="9、常见错误"></a>9、常见错误</h2><pre><code>malloc/free: in use at exit      内存在退出前没有释放invalid write of size               非法写入内存，一般为数组越界invalid read of size               非法读内存：一般为数组越界definitely lost /possibly lost /still reachable in loss record 内存未释放invalid free()/delete/delete[]  同一指针被多次释放source and destination overlay 一般是使用strncpy,memcpy引起syscall param contains uninitialized byte 调用系统函数时传入了未初始化的变量conditional jump or move depends on uninitialized value 条件判断时使用了未初始化的变量access not with mapped region/stack overflow 栈溢出mismatch free()/delete/delete[]/new  delete/malloc/free搭配错误</code></pre><hr><h2 id="THE-END"><a href="#THE-END" class="headerlink" title="THE END! "></a><font color="red"><strong>THE END!</strong> </font></h2>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
          <category> 调试工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> valgrind </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Windows平台下内存泄露分析工具：WinDbg</title>
      <link href="/2017/10/09/%E3%80%90Tools%E7%B3%BB%E5%88%97%E3%80%91Windows%E5%B9%B3%E5%8F%B0%E4%B8%8B%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7%EF%BC%9AWinDbg/"/>
      <url>/2017/10/09/%E3%80%90Tools%E7%B3%BB%E5%88%97%E3%80%91Windows%E5%B9%B3%E5%8F%B0%E4%B8%8B%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7%EF%BC%9AWinDbg/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>&ensp; &ensp; 在linux平台中可以采用valgrind进行动态内存诊断分析（具体参见博文：<a href="https://soaringleefighting.github.io/2017/10/15/%E3%80%90Tools%E7%B3%BB%E5%88%97%E3%80%91Valgrind%E5%B7%A5%E5%85%B7%E6%A3%80%E6%B5%8B%E5%86%85%E5%AD%98%E9%94%99%E8%AF%AF%E5%AE%9E%E4%BE%8B%E5%88%86%E6%9E%90/">Valgrind工具检测内存错误实例分析</a>），这里介绍一种在Windows平台下进行内存分析的工具： WinDbg。</p><h2 id="1、WinDbg安装"><a href="#1、WinDbg安装" class="headerlink" title="1、WinDbg安装"></a>1、WinDbg安装</h2><p>WinDbg32位下载地址：<a href="https://docs.microsoft.com/zh-cn/windows-hardware/drivers/debugger/debugger-download-tools" target="_blank" rel="noopener">https://docs.microsoft.com/zh-cn/windows-hardware/drivers/debugger/debugger-download-tools</a></p><h2 id="2、环境配置"><a href="#2、环境配置" class="headerlink" title="2、环境配置"></a>2、环境配置</h2><p>计算机——》右击——》属性——》高级系统设置——》环境——》系统变量——》Path——》编辑——》变量值处后加入：</p><pre><code>C:\Program Files\Debugging Tools for Windows(x86)</code></pre><p>注意：此路径请参考个人的安装路径。</p><h2 id="3、利用工具umdh（user-mode-dump-heap）分析"><a href="#3、利用工具umdh（user-mode-dump-heap）分析" class="headerlink" title="3、利用工具umdh（user-mode dump heap）分析"></a>3、利用工具umdh（user-mode dump heap）分析</h2><p>（1）由于在安装路径下有 gflags.exe、umdh.exe 这两个可执行文件，且在步骤2中已加入环境变量，下一步可直接在dos界面输入命令；</p><p>（2）桌面左下角-》开始 处输入cmd命令，打开dos界面窗口后，输入命令：gflags.exe，会出现下图，并按照下图进行相关设置：</p><p><img src="/img/20130923092120500.jpg" alt="umdh分析配置1"><br><img src="/img/20130923092059484.jpg" alt="umdh分析配置2"></p><p>（3）gflags标志设置好后，开启cmd</p><pre><code>gflags.exe /i memoryleak.exe +ust</code></pre><p>键入要定位内存泄露的程序gflags.exe /I memroyleak.exe（程序名称）+ust</p><p>如图成功后，开启memoryleak.exe程序，即运行需要测试的程序。</p><h2 id="4、利用umdh创建heap快照"><a href="#4、利用umdh创建heap快照" class="headerlink" title="4、利用umdh创建heap快照"></a>4、利用umdh创建heap快照</h2><p>命令格式：umdh–pn:memoryleak.exe(程序名称) –f:snap1.log(日志名称)</p><p>程序运行一段时间后或者程序占用内存增加时，将memoryleak.exe退出。</p><p>然后再次创建heap快照，命令行无差别，snap1.log改为snap2.log或者其他。</p><p>设置好程序的符号路径，如下图：<br><img src="/img/20130923092304187.jpg" alt="heap快照"></p><p>设置好后可以开始分析heap前后两个快照的差异</p><p>分析差异命令：umdh –d snap1.log snap2.log –f:result.txt</p><p>分析完成后查看结果result.txt，可以指定具体的输出文件夹，不指定的话，输出在桌面的个人文件夹《以自己名字命名的文件夹》</p><p>红色为umdh定位出来的泄露点，我们在查看源代码</p><p>这样我们就可以修改代码中内存泄露的地方了。</p><p>注意：利用Umdh创建Heap快照 步骤设置程序的符号路径，此符号路径是一个在线网址，因此需要电脑联网；对于我们来说只能通过下载符号离线包的方式，离线包的路径为：</p><p><a href="https://developer.microsoft.com/en-us/windows/hardware/download-symbols" target="_blank" rel="noopener">https://developer.microsoft.com/en-us/windows/hardware/download-symbols</a></p><p>关键词:Download Windows Symbol Packages</p><p>但是不下载此包，符号路径会自动设置为 %windir%\symbols 即windows自带的符号路径，目前未发现问题</p><h2 id="5、常用命令"><a href="#5、常用命令" class="headerlink" title="5、常用命令"></a>5、常用命令</h2><p><a href="https://blog.csdn.net/SoaringLee_fighting/article/details/80514344" target="_blank" rel="noopener">https://blog.csdn.net/SoaringLee_fighting/article/details/80514344</a><br><a href="https://blog.csdn.net/SoaringLee_fighting/article/details/79089237" target="_blank" rel="noopener">https://blog.csdn.net/SoaringLee_fighting/article/details/79089237</a></p><p>参考：<br><a href="http://blog.csdn.net/chenyujing1234/article/details/11918987" target="_blank" rel="noopener">http://blog.csdn.net/chenyujing1234/article/details/11918987</a><br><a href="http://blog.csdn.net/listener51/article/details/78106185" target="_blank" rel="noopener">http://blog.csdn.net/listener51/article/details/78106185</a></p><hr><h2 id="THE-END"><a href="#THE-END" class="headerlink" title="THE END!"></a><font color="red"><strong>THE END!</strong></font></h2>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
          <category> 调试工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> windbg </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>通过批处理脚本命令行编译VS工程</title>
      <link href="/2017/09/25/%E3%80%90PE%E7%B3%BB%E5%88%97%E3%80%91%E9%80%9A%E8%BF%87%E6%89%B9%E5%A4%84%E7%90%86%E8%84%9A%E6%9C%AC%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%BC%96%E8%AF%91VS%E5%B7%A5%E7%A8%8B/"/>
      <url>/2017/09/25/%E3%80%90PE%E7%B3%BB%E5%88%97%E3%80%91%E9%80%9A%E8%BF%87%E6%89%B9%E5%A4%84%E7%90%86%E8%84%9A%E6%9C%AC%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%BC%96%E8%AF%91VS%E5%B7%A5%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Visual Studio IDE本身具有编译链接以及调试分析的功能，是一款非常强大的代码调试和阅读的软件。但通常windows平台下的库的生成采用批处理脚本的方式来编译VS工程会更加的方便，而且不需要打开VS软件。</p><p>下面以Mpeg4的开源实现Xvid的工程libxvidcore.sln为例，整理一下通过批处理脚本命令行编译VS工程的通用方法。</p><h2 id="一、命令行编译通用模板"><a href="#一、命令行编译通用模板" class="headerlink" title="一、命令行编译通用模板"></a>一、命令行编译通用模板</h2><pre><code>@rem 说明：Windows平台命令行编译脚本@rem 作用：通过批处理脚本命令行编译VS工程@echo off@rem usage: build.bat Release/Debug Win32/x64@rem set build_config=&quot;Debug|Win32&quot;@rem set build_config=&quot;Release|Win32&quot;@rem set build_config=$ALL@rem 当前环境设置只在本文件中有效@setlocal@rem &quot;命令行输入参数&quot;set build=%1set platform=%2set build_config=&quot;%build%|%platform%&quot;@echo %date% %time%  &gt;build.log@rem 当前脚本所在路径@echo &quot;编译目录...&quot;@echo %~dp0set build_root = %~dp0@rem 各种文件和路径set VCVARS=&quot;%VS120COMNTOOLS%../../VC/vcvarsall.bat&quot;set DEVENV=&quot;%VS120COMNTOOLS%../IDE/devenv.exe&quot;@rem 设置解决方案路径set SOlUTION=&quot;%~dp0libxvidcore.sln&quot;@echo &quot;解决方案...&quot;@echo %SOLUTION%@rem 检查文件路径配置if not exist %VCVARS% echo &quot;VCVARS不存在！&quot; &amp;goto endif not exist %DEVENV% echo &quot;DEVENV不存在！&quot; &amp;goto endif not exist %SOlUTION% echo &quot;SOlUTION不存在！&quot; &amp;goto end@rem 删除输出文件if exist build.log del build.log@rem 编译环境配置@echo &quot;环境配置...&quot;if %platform%==&quot;Win32&quot;  (     echo &quot;Windows 32位环境配置...&quot;     call %VCVARS% x86)if %platform%==&quot;x64&quot; (     echo &quot;Windows 64位环境配置...&quot;     call %VCVARS% x86_amd64)@echo build_config:%build_config%,please waiting@echo &quot;开始编译&quot;%DEVENV% %SOlUTION% /rebuild %build_config% /out build.log@rem 打印编译信息@rem notepad build.logtype build.logcopy %~dp0bin\xvidcore.dll  %~dp0..\lib\copy %~dp0bin\xvidcore.lib  %~dp0..\lib\:end@rem pause@endlocal</code></pre><p>这里主要涉及到了devenv.exe命令的使用以及windows编译环境的设置（详见Windows平台命令行中使用vcvarsall.bat配置编译环境）。</p><h2 id="二、Devenv-exe的用法"><a href="#二、Devenv-exe的用法" class="headerlink" title="二、Devenv.exe的用法"></a>二、Devenv.exe的用法</h2><p>devenv[solutionfile | projectfile | anyfile.ext] [switches]<br>devenv 的第一个参数通常是一个解决方案文件(.sln)或项目文件(.vcproj)。如果您希望在编辑器中自动打开文件，也可以使用任何其他文件作为第一个参数。当您输入项目文件时，IDE会在项目文件的父目录中查找与该项目文件具有相同基名称的 .sln 文件。如果不存在这样的 .sln 文件，IDE 将查找引用该项目的单个 .sln 文件。如果不存在这样的单个.sln 文件，则 IDE 将创建一个具有默认 .sln 文件名且未保存的解决方案，其基名称与项目文件的基名称相同。</p><p>命令行编译:</p><pre><code>devenv solutionfile.sln /buildsolutionconfig [ /project projectnameorfile [ /projectconfig name ] ]</code></pre><p>devenv可用的命令行开关:</p><pre><code>/Build使用指定的解决方案配置生成解决方案或项目。例如“Debug”。如果可能存在多个平台，则配置名称必须用引号括起来并且包含平台名称。例如“Debug|Win32”。/Clean删除生成结果。/Command启动 IDE 并执行该命令。/Deploy生成并部署指定的生成配置。/Edit在此应用程序的运行实例中打开指定文件。如果没有正在运行的实例，则启动一个具有简化窗口布局的新实例。/LCID设置 IDE 中用于用户界面的默认语言。/Log将 IDE 活动记录到指定的文件以用于故障排除。/NoVSIP禁用用于 VSIP 测试的 VSIP 开发人员许可证密钥。/Out将生成日志追加到指定的文件中。/Project指定生成、清理或部署的项目。必须和 /Build、/Rebuild、/Clean 或 /Deploy 一起使用。/ProjectConfig重写解决方案配置中指定的项目配置。例如“Debug”。如果可能存在多个平台，则配置名称必须用引号括起来并包含平台名称。例如“Debug|Win32”。必须和 /Project 一起使用。/Rebuild先清理，然后使用指定配置生成解决方案或项目。/ResetAddin移除与特定外接程序关联的命令和命令用户界面。/ResetSettings恢复 IDE 的默认设置，还可以重置为指定的 VSSettings 文件。/ResetSkipPkgs清除所有添加到 VSPackages 的 SkipLoading 标记。/Run编译并运行指定的解决方案。/RunExit编译并运行指定的解决方案然后关闭 IDE。/SafeMode以安全模式启动 IDE，加载最少数量的窗口。/Upgrade升级项目或解决方案以及其中的所有项目。并相应地创建这些文件的备份。有关备份过程的更多信息，请参见“Visual Studio 转换向导”上的帮助。</code></pre><h2 id="三、参考"><a href="#三、参考" class="headerlink" title="三、参考"></a>三、参考</h2><p><a href="http://blog.csdn.net/listener51/article/details/76039146" target="_blank" rel="noopener">http://blog.csdn.net/listener51/article/details/76039146</a></p><h2 id="四、更多说明（type命令和more命令查看文件内容）"><a href="#四、更多说明（type命令和more命令查看文件内容）" class="headerlink" title="四、更多说明（type命令和more命令查看文件内容）"></a>四、更多说明（type命令和more命令查看文件内容）</h2><pre><code>@rem 打印编译信息@rem notepad build.logtype build.log</code></pre><p>在没有安装notepad软件的计算机中运行该脚本时，就会出现报错；因此我们可以直接将编译信息打印到cmd窗口中：</p><p>利用Windows cmd自带的type命令或者more命令可以查看文件内容。</p><p>linux下，可能会用到cat或都是more命令，windows下可以使用type或more命令。</p><pre><code>type：查看文件内容；more：分段查看文件内容，more +100 abc.txt，从第100行开始查看abc.txt文件内容</code></pre><p>参考：<a href="https://blog.csdn.net/shilian_h/article/details/7108599" target="_blank" rel="noopener">https://blog.csdn.net/shilian_h/article/details/7108599</a></p><h2 id="THE-END"><a href="#THE-END" class="headerlink" title=" THE END! "></a><font color="red"> THE END! </font></h2>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 工程化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 批处理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>查看dll导出的符号的方法以及Depends.exe反汇编工具介绍</title>
      <link href="/2017/09/24/%E3%80%90PE%E7%B3%BB%E5%88%97%E3%80%91%E6%9F%A5%E7%9C%8Bdll%E5%AF%BC%E5%87%BA%E7%9A%84%E7%AC%A6%E5%8F%B7%E7%9A%84%E6%96%B9%E6%B3%95%E4%BB%A5%E5%8F%8ADepends.exe%E5%8F%8D%E6%B1%87%E7%BC%96%E5%B7%A5%E5%85%B7%E4%BB%8B%E7%BB%8D/"/>
      <url>/2017/09/24/%E3%80%90PE%E7%B3%BB%E5%88%97%E3%80%91%E6%9F%A5%E7%9C%8Bdll%E5%AF%BC%E5%87%BA%E7%9A%84%E7%AC%A6%E5%8F%B7%E7%9A%84%E6%96%B9%E6%B3%95%E4%BB%A5%E5%8F%8ADepends.exe%E5%8F%8D%E6%B1%87%E7%BC%96%E5%B7%A5%E5%85%B7%E4%BB%8B%E7%BB%8D/</url>
      
        <content type="html"><![CDATA[<p>[TOC]<br>动态库dll中到底有哪些函数和符号呢？这里介绍两种工具来查看：</p><h2 id="1、dumpbin命令-VS命令，使用时需要开启VS编译环境"><a href="#1、dumpbin命令-VS命令，使用时需要开启VS编译环境" class="headerlink" title="1、dumpbin命令(VS命令，使用时需要开启VS编译环境)"></a>1、dumpbin命令(VS命令，使用时需要开启VS编译环境)</h2><pre><code>dumpbin -exports MyDll.dll    查看dll中导出的函数和变量</code></pre><p>e.g:</p><p><img src="/img/20170924220411679.jpg" alt="dumpbin命令使用"></p><h2 id="2、Depends-exe"><a href="#2、Depends-exe" class="headerlink" title="2、Depends.exe"></a>2、Depends.exe</h2><p>官方下载地址：<a href="http://www.dependencywalker.com/" target="_blank" rel="noopener">http://www.dependencywalker.com/</a></p><p><img src="/img/20170924221108830.jpg" alt="Depends"></p><p>注：该工具列出的是隐式链接的DLL模块，无法列出显式（也就是用LoadLibrary导入）的。</p><p>参考:</p><p><a href="http://blog.csdn.net/scythe666/article/details/47165533(Depends.exe的介绍)" target="_blank" rel="noopener">http://blog.csdn.net/scythe666/article/details/47165533(Depends.exe的介绍)</a></p><p><a href="http://blog.csdn.net/klarclm/article/details/7712680" target="_blank" rel="noopener">http://blog.csdn.net/klarclm/article/details/7712680</a></p><p><a href="http://jingyan.baidu.com/article/ff411625c7e60812e48237d5.html" target="_blank" rel="noopener">http://jingyan.baidu.com/article/ff411625c7e60812e48237d5.html</a></p><hr><h2 id="THE-END"><a href="#THE-END" class="headerlink" title="THE END!"></a><font color="red"><strong>THE END!</strong></font></h2>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
          <category> 调试工具 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Windows平台下为可执行文件或动态库dll添加版本信息和图标</title>
      <link href="/2017/09/22/%E3%80%90PE%E7%B3%BB%E5%88%97%E3%80%91Windows%E5%B9%B3%E5%8F%B0%E4%B8%8B%E4%B8%BA%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6%E6%88%96%E5%8A%A8%E6%80%81%E5%BA%93dll%E6%B7%BB%E5%8A%A0%E7%89%88%E6%9C%AC%E4%BF%A1%E6%81%AF%E5%92%8C%E5%9B%BE%E6%A0%87/"/>
      <url>/2017/09/22/%E3%80%90PE%E7%B3%BB%E5%88%97%E3%80%91Windows%E5%B9%B3%E5%8F%B0%E4%B8%8B%E4%B8%BA%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6%E6%88%96%E5%8A%A8%E6%80%81%E5%BA%93dll%E6%B7%BB%E5%8A%A0%E7%89%88%E6%9C%AC%E4%BF%A1%E6%81%AF%E5%92%8C%E5%9B%BE%E6%A0%87/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>1、平常我们可以看到在Windows可执行文件中，右键属性中含有文件版本，文件名称和版本等信息，本文讲述怎么添加这些信息。<br>2、在实际开发中，可能需要为Windows可执行文件exe添加图标，这个功能对于识别可执行文件还是很有用的。一般VS编译后的exe图标是默认图标，下面讲述为exe添加图标的方法。</p><h2 id="1、Windows平台下为可执行文件或动态库dll添加版本信息"><a href="#1、Windows平台下为可执行文件或动态库dll添加版本信息" class="headerlink" title="1、Windows平台下为可执行文件或动态库dll添加版本信息"></a>1、Windows平台下为可执行文件或动态库dll添加版本信息</h2><h3 id="1-1-方法一"><a href="#1-1-方法一" class="headerlink" title="1.1 方法一"></a>1.1 方法一</h3><p>VS工程中建立资源文件，编译即可</p><p>这种方法比较简单，是借助VS工程，文件版本的信息其实是通过资源文件编译进去的。</p><h3 id="1-2-方法二"><a href="#1-2-方法二" class="headerlink" title="1.2 方法二"></a>1.2 方法二</h3><p>MinGW或者Cygwin环境下为dll或exe添加版本信息</p><p>1、打开cmd,输入：</p><pre><code>call &quot;%VS120COMNTOOLS%../../VC/vcvarsall.bat&quot;call &quot;E:\ProfessionalSoftware\MinGW\msys\1.0\msys.bat&quot;</code></pre><p>启动VS2010编译环境和MinGW环境，这里是为了使用命令windres和rc命令。</p><p>2、创建一个test.c文件：</p><pre><code class="c">#include &quot;stdio.h&quot;int add(int a, int b){    return a + b;}int main(int argc, char** argv){    printf(&quot;********************&quot;);}</code></pre><p>3、创建资源文件Res.rc文件：</p><pre><code>1 VERSIONINFOFILEVERSION    0,1,22,33PRODUCTVERSION 1,0,0,0FILEFLAGS 0x1LFILEOS 0x40004LFILETYPE 0x1LFILESUBTYPE 0x1LBEGIN   BLOCK &quot;StringFileInfo&quot;   BEGIN     BLOCK &quot;080904E4&quot;     BEGIN    VALUE &quot;CompanyName&quot;, &quot;My Company Name&quot;    VALUE &quot;FileDescription&quot;, &quot;My excellent application&quot;    VALUE &quot;FileVersion&quot;, &quot;6000&quot;    VALUE &quot;InternalName&quot;, &quot;my_app&quot;    VALUE &quot;LegalCopyright&quot;, &quot;My Name&quot;    VALUE &quot;OriginalFilename&quot;, &quot;my_app.exe&quot;    VALUE &quot;ProductName&quot;, &quot;My App&quot;    VALUE &quot;ProductVersion&quot;, &quot;6000&quot;     END   END   BLOCK &quot;VarFileInfo&quot;   BEGIN      VALUE &quot;Translation&quot;, 0x809, 1252   END</code></pre><p>4、编译链接，将资源文件rc转换成res文件，然后链接到dll或exe中</p><pre><code>gcc -c test.c -o test.owindres Res.rc -O coff -o obj.resgcc -o test test.o obj.res或者：cl -c test.cwindres Res.rc -O coff -o obj.reslink test.obj obj.res</code></pre><p>另外一种方法就是采用rc命令将res文件转换成rc文件。</p><pre><code>cl -DWIN64 -c obj.c -Foobjrc -DWIN64 -fo obj.res obj.rclink obj.obj obj.res</code></pre><p>好的，现在就可以右键属性查看可执行文件的版本信息了。</p><h2 id="2、Windows平台下为可执行文件添加图标"><a href="#2、Windows平台下为可执行文件添加图标" class="headerlink" title="2、Windows平台下为可执行文件添加图标"></a>2、Windows平台下为可执行文件添加图标</h2><h3 id="2-1-方法一：VS工程中直接添加图标"><a href="#2-1-方法一：VS工程中直接添加图标" class="headerlink" title="2.1 方法一：VS工程中直接添加图标"></a>2.1 方法一：VS工程中直接添加图标</h3><p>在项目中添加资源文件（*.rc），在资源视图中，右键资源文件，选择“添加资源”，在弹出的菜单选择添加类型-图标（icon），点击“导入”按钮，在弹出的选择对话框选择自己想要添加的程序图标文件（*.ico），保存资源文件后重新编译，即可看到编译出来的exe的图标即为刚刚选择的图标。</p><p>1、右击项目属性，添加资源，资源类型选择Icon，然后导入需要添加的图标ICON。<br>2、重新编译工程。</p><p><img src="/img/20181229212656338.png" alt="图标修改"></p><h3 id="2-2-方法二：-直接添加资源文件进行编译"><a href="#2-2-方法二：-直接添加资源文件进行编译" class="headerlink" title="2.2 方法二： 直接添加资源文件进行编译"></a>2.2 方法二： 直接添加资源文件进行编译</h3><p>res.rc文件如下：</p><pre><code>///////////////////////////////////////////////////////////////////////////////// Icon//// Icon with lowest ID value placed first to ensure application icon// remains consistent on all systems.IDI_ICON1               ICON                    &quot;Panda.ico&quot;#endif    // 中文(简体，中国) resources/////////////////////////////////////////////////////////////////////////////</code></pre><p>如下图所示：<br>exe文件图标、exe运行的任务栏图标和运行窗口标题栏都修改为了指定图标。<br><img src="/img/2018122921311977.png" alt="图标修改"></p><h2 id="3、相关知识"><a href="#3、相关知识" class="headerlink" title="3、相关知识"></a>3、相关知识</h2><p>1). <a href="https://blog.csdn.net/SoaringLee_fighting/article/details/80596261" target="_blank" rel="noopener">Windows资源文件rc定义和使用</a><br>2). <a href="https://blog.csdn.net/SoaringLee_fighting/article/details/78067493" target="_blank" rel="noopener">Windows平台下为可执行文件或动态库dll添加版本信息</a><br>3). <a href="https://blog.csdn.net/SoaringLee_fighting/article/details/81662054" target="_blank" rel="noopener">动态库dll通过资源文件配置右击属性-详细信息的方法</a></p><h2 id="THE-END"><a href="#THE-END" class="headerlink" title=" THE END! "></a><font color="red"> <strong>THE END!</strong> </font></h2>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 工程化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Windows </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>通过SecureCRT远程登录telnet连接虚拟机的linux系统（CentOS/Ubuntu）</title>
      <link href="/2017/09/17/%E3%80%90Tools%E7%B3%BB%E5%88%97%E3%80%91%E9%80%9A%E8%BF%87SecureCRT%E8%BF%9C%E7%A8%8B%E7%99%BB%E5%BD%95telnet%E8%BF%9E%E6%8E%A5%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%9A%84linux%E7%B3%BB%E7%BB%9F/"/>
      <url>/2017/09/17/%E3%80%90Tools%E7%B3%BB%E5%88%97%E3%80%91%E9%80%9A%E8%BF%87SecureCRT%E8%BF%9C%E7%A8%8B%E7%99%BB%E5%BD%95telnet%E8%BF%9E%E6%8E%A5%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%9A%84linux%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="1、-题记"><a href="#1、-题记" class="headerlink" title="1、 题记"></a>1、 题记</h2><p>周末在家里闲来无事，想着之前安装了SecureCRT，就尝试着利用这个软件telnet连接虚拟机中的linux系统。之前虚拟机VMvare Workstation里安装的是CentOS，现在尝试采用桌面级linux系统Ubuntu进行测试。</p><h2 id="2、准备材料"><a href="#2、准备材料" class="headerlink" title="2、准备材料"></a>2、准备材料</h2><ul><li><p>虚拟机：VMvare Workstation</p></li><li><p>Linux系统：Ubuntu</p></li><li><p>远程登录软件：SecureCRT或者Xshell</p></li></ul><h2 id="3、步骤（这里以ubuntu系统为例说明）"><a href="#3、步骤（这里以ubuntu系统为例说明）" class="headerlink" title="3、步骤（这里以ubuntu系统为例说明）"></a>3、步骤（这里以ubuntu系统为例说明）</h2><h3 id="3-1、"><a href="#3-1、" class="headerlink" title="3.1、"></a>3.1、</h3><p>首先是设置虚拟机中Ubuntu采用的网络连接方式为仅主机模式（host-only），这种方式与主机共享专用网络。</p><h3 id="3-2、"><a href="#3-2、" class="headerlink" title="3.2、"></a>3.2、</h3><p>查看主机的网络连接设置，找到如图示三个连接<br><img src="/img/0_1314841363UK0x.gif" alt="网络连接设置"></p><p>其中，VMnet8和NAT方式相关，本文暂不讨论。这里VMnet1和host-only相关，设置VMnet1的ip如下，其中“177”可以换成不冲突的任意子网，而1不可更改，这里的1表示分配给主机的子网内ip，即全部完成后虚拟机ping192.168.177.1就会ping通主机。<br><img src="/img/20170917091412006.jpg" alt="网络连接详细信息"></p><h3 id="3-3、"><a href="#3-3、" class="headerlink" title="3.3、"></a>3.3、</h3><p>登录Ubuntu系统，采用ifconfig命令查看ens33网卡或者eth0网卡的IP地址：<br><img src="/img/20170917091929396.jpg" alt="ifconfig命令"></p><p><font color="red">注意：这里需要设置虚拟机中ubuntu系统的IP地址和主机IP地址在同一个网段内，图中已经设置好了。</font></p><p>如果不在同一个网段内，可以采用如下两种方法进行修改IP地址：</p><p>（1）修改主机IP地址，修改VMnet1中的IP地址和ubuntu中的IP地址在同一个网段内；</p><p>（2）修改虚拟机ubuntu中的IP地址和主机IP在一个网段内；</p><p>修改成功的标志就是主机和虚拟机中的ubuntu系统可以互相ping通。</p><p>主机ping虚拟机中的ubuntu系统：<br><img src="/img/20170917102047024.jpg" alt="主机ping虚拟机"></p><p>虚拟机中的ubuntu系统ping本地主机：<br><img src="/img/20170917102406805.jpg" alt="虚拟机ping主机"></p><h3 id="3-4、"><a href="#3-4、" class="headerlink" title="3.4、"></a>3.4、</h3><p>查看虚拟机中的ubuntu系统是否安装ssh服务和客户端，这个比较重要。</p><p>参考：<a href="https://www.linuxidc.com/Linux/2017-12/149623.htm" target="_blank" rel="noopener">https://www.linuxidc.com/Linux/2017-12/149623.htm</a></p><p><strong>检查安装SSH语句：</strong></p><pre><code>&quot;rpm -aq|grep openssh-server&quot;</code></pre><p>如没有安装（Ubuntu默认没有安装ssh）openssh-server，就需要找其他途径安装，如主机下载rpm传上去，或用iso安装该rpm包（可参考其他文章）；如没有root权限（Ubuntu默认没有root密码，执行”sudo passwd root”语句来修改root密码），切换root权限检查SSH服务语句：有进程ID的话说明已经启动。</p><p><strong>安装ssh-server和ssh-client的方法：</strong></p><pre><code>sudo apt install ssh-server ssh-client</code></pre><p>SSH 为 SecureShell 的缩写，由 IETF 的网络工作小组（NetworkWorkingGroup）所制定；SSH 是一种安全协议，主要用于给远程登录会话数据进行加密，保证数据传输的安全。利用 SSH 协议可以有效防止远程管理过程中的信息泄露问题。</p><p><strong>更新源列表</strong></p><p>打开”终端窗口”，输入 “sudo apt-get update” –&gt; 回车 –&gt; “输入当前登录用户的管理员密码” –&gt; 回车，就可以了。</p><p><strong>安装 SSH</strong></p><p>在 “终端窗口” 输入</p><pre><code>&quot;sudo apt-get install openssh-server&quot;</code></pre><p>–&gt; 回车 –&gt; 输入 “y” –&gt; 回车 –&gt; 安装完成.</p><pre><code>sudo apt-get install openssh-server</code></pre><p>查看 SSH 服务是否启动</p><p>打开”终端窗口”，输入 “sudo ps -e | grep ssh” –&gt; 回车 –&gt; 有 sshd，说明 ssh 服务已经启动，如果没有启动，输入 “sudo service ssh start” –&gt; 回车 –&gt; ssh 服务就会启动。</p><h3 id="3-5、"><a href="#3-5、" class="headerlink" title="3.5、"></a>3.5、</h3><p>打开SecureCRT，设置登录的hostname（虚拟机ubuntu系统的IP地址），ssh2端口为22，Firewall设置为none。然后就可以打开输入ubuntu系统的账号和密码，然后就可以成功登录了！</p><p>利用SecureCRT访问和操作linux系统确实很爽，不再受限于虚拟机的狭小空间。</p><p>注意：虚拟机可以实现与主机的互联，但是不能使用虚拟机上网这是host-only模式的局限。要想联网下载所需的安装包，可切换成NAT模式或者桥接模式。</p><p>关于虚拟机中的三种网络模式可以参见：<a href="http://www.linuxidc.com/Linux/2016-09/135521.htm" target="_blank" rel="noopener">http://www.linuxidc.com/Linux/2016-09/135521.htm</a></p><h2 id="4、参考"><a href="#4、参考" class="headerlink" title="4、参考"></a>4、参考</h2><p><a href="http://blog.csdn.net/lzx_bupt/article/details/6738186" target="_blank" rel="noopener">http://blog.csdn.net/lzx_bupt/article/details/6738186</a><br><a href="http://www.cnblogs.com/xiazh/archive/2010/08/13/1798844.html" target="_blank" rel="noopener">http://www.cnblogs.com/xiazh/archive/2010/08/13/1798844.html</a></p><hr><h2 id="THE-END"><a href="#THE-END" class="headerlink" title="THE END!"></a><font color="red"><strong>THE END!</strong></font></h2>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
          <category> Linux工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android NDK Build 用法</title>
      <link href="/2017/08/14/%E3%80%90%E7%BC%96%E8%AF%91%E5%B7%A5%E5%85%B7%E3%80%91Android%20NDK%20Build%20%E7%94%A8%E6%B3%95/"/>
      <url>/2017/08/14/%E3%80%90%E7%BC%96%E8%AF%91%E5%B7%A5%E5%85%B7%E3%80%91Android%20NDK%20Build%20%E7%94%A8%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="1、ndk-build的用法"><a href="#1、ndk-build的用法" class="headerlink" title="1、ndk-build的用法"></a>1、ndk-build的用法</h2><p>Android NDKr4引入了一个新的、小巧的shell脚本ndk-build，来简化源码编译。</p><p>该文件位于NDK根目录，进入你的工程根目录或子目录之后，在命令行下调用即可。例如：</p><pre><code>    cd $PROJECT    $NDK/ndk-build</code></pre><p>NDK指向你的NDK的安装目录，PROJECT指向你的android工程目录。建议将ndk-build所在目录加入PATH环境变量或设置alias。</p><h2 id="2、ndk-build的选项"><a href="#2、ndk-build的选项" class="headerlink" title="2、ndk-build的选项"></a>2、ndk-build的选项</h2><p>所有给ndk-build的选项都会直接传给GNU Make，由make运行NDK的编译脚本。几个常见调用方式如下：</p><pre><code>ndk-build                   编译ndk-build clean          清掉二进制文件ndk-build NDK_DEBUG=1     编译为可调试版的二进制文件ndk-build NDK_DEBUG=0     编译为release版ndk-build V=1                       执行ndk-build且打印出它所执行的详细编译命令。ndk-build -B                          强制重新编译ndk-build -B V=1                   -B 和 V=1 的组合ndk-build NDK_LOG=1          打印出内部的NDK日志信息（用于调试NDK自己）ndk-build NDK_APPLICATION_MK=&lt;文件路径&gt;      用这里指定的路径寻找Application.mk文件</code></pre><p>注意：这里不是官方Documents中说的NDK_APP_APPLICATION_MK，而是NDK_APPLICATION_MK!</p><pre><code>ndk-build -C &lt;project路径&gt;  先cd进入&lt;project路径&gt;，然后执行ndk-build。</code></pre><h2 id="3、Debug版本-Vs-Release版本"><a href="#3、Debug版本-Vs-Release版本" class="headerlink" title="3、Debug版本 Vs Release版本"></a>3、Debug版本 Vs Release版本</h2><p>在NDKr5中，ndk-build做了一些改进，使得在release和debug之间切换更容易了。即通过 NDK_DEBUG 变量：</p><pre><code>ndk-build NDK_DEBUG=1    编译出的共享库带调试信息，是debug版本ndk-build NDK_DEBUG=0    编译出的共享库不带调试信息，是release版本</code></pre><p>如果没有指定NDK_DEBUG，则会从 AndroidManifest.xml中获取（查看 <application> 元素是否有 android:debuggable=”true”）。</application></p><p>注意：如果你的SDK是SDKr8或更高，完全不需要修改AndroidManifest.xml。因为如果你想编译出debug版安装包（在命令行下执行 ant debug或用ADT），SDK的工具会自动选择用NDK_DEBUG=1编译出的共享库。NDK编译出的debug版和release版的object文件存放在不同的目录（例如 obj/local/<abi>/objs 和 obj/local/<abi>/objs-debug），避免了在release和debug之间切换而重新编译所有文件。</abi></abi></p><h2 id="4、ndk-build的使用条件"><a href="#4、ndk-build的使用条件" class="headerlink" title="4、ndk-build的使用条件"></a>4、ndk-build的使用条件</h2><p>总体来说，必须安装GNU Make 3.81 以上版本的make才能正常使用ndk-build和NDK。</p><h2 id="5、ndk-build的实质"><a href="#5、ndk-build的实质" class="headerlink" title="5、ndk-build的实质"></a>5、ndk-build的实质</h2><p>ndk-build 其实就是对GNU Make的封装，它的目的是调用正确的NDK编译脚本，它等价于 make -f $NDK/build/core/build-local.mk [参数]</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://ticktick.blog.51cto.com/823160/1425857" target="_blank" rel="noopener">http://ticktick.blog.51cto.com/823160/1425857</a></p><hr><h2 id="THE-END！"><a href="#THE-END！" class="headerlink" title=" THE  END！"></a><font color="red"> <strong>THE  END！</strong></font></h2>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
          <category> 编译工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
